<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>HadoopExpriment</title>
      <link href="2021/05/30/Hadoop/"/>
      <url>2021/05/30/Hadoop/</url>
      
        <content type="html"><![CDATA[<p>图片我懒得搬了，要一张一张的改路径太麻烦了</p><h2 id="实验三"><a href="#实验三" class="headerlink" title="实验三"></a>实验三</h2><p>七、实验步骤</p><p>（一）Hbase shell 命令</p><p>1.启动hadoop</p><p>cd /usr/local/hadoop</p><p>./sbin/start-all.sh</p><p>2.启动hbase和hbase shell</p><p>cd /usr/local/hbase</p><p>./bin/start-hbase.sh</p><p>./bin/hbase shell</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps14.jpg" alt="img"> </p><p>l 进入HBase Shell命令行模式以后，用户可以通过输入Shell命令操作HBase数据库。</p><p>\3. 用list命令查看当前HBase数据库中已经创建了哪些表</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps15.jpg" alt="img"> </p><p>\4. 若已存在student表，则删除</p><p>disable ‘student’</p><p>drop ‘student’</p><p>\5. 用create命令创建表</p><p>create ‘student’,’Sname’,’Ssex’,’Sage’,’Sdept’,’course’</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps16.jpg" alt="img"> </p><p>\6. 查看数据</p><p>l HBase中有两个用于查看数据的命令：1. get命令，用于查看表的某一行数据；2. scan命令用于查看某个表的全部数据</p><p>get ‘student’,’20202020’</p><p>scan ‘student’</p><p>\7. 用put命令将自己的姓名、学号添加到student表中。例如姓名为‘Zhangsan’，学号‘20202020’:</p><p>put ‘student’,’20202020’,’Sname’,’Zhangsan’</p><p>l 即为student表添加了学号为20202020，名字为Zhangsan的一行数据，其行键为20202020</p><p>put ‘student’,’20202020’,’course:math’,’80’</p><p>l 即为20202020行下的course列族的math列添加了一个数据。</p><p>\8. 在HBase中用delete以及deleteall命令进行删除数据操作，它们的区别是：1. delete用于删除一个数据，是put的反向操作；2. deleteall操作用于删除一行数据。</p><p>delete ‘student’,’20202020’,’Ssex’</p><p>l 删除了student表中20202020行下的Ssex列的所有数据。</p><p>get ‘student’，‘20202020’</p><p>l 查看是否删除成功</p><p>deleteall ‘student’,’20202020’</p><p>l 删除了student表中的95001行的全部数据。</p><p>\8. 查询表历史数据</p><p>1）在创建表的时候，指定保存的版本数（假设指定为5）</p><p>create ‘teacher’,{NAME=&gt;’username’,VERSIONS=&gt;5}</p><p>2）插入数据然后更新数据，使其产生历史版本数据，注意：这里插入数据和更新数据都是用put命令</p><p>put ‘teacher’,’91001’,’username’,’Mary’</p><p>put ‘teacher’,’91001’,’username’,’Mary1’</p><p>put ‘teacher’,’91001’,’username’,’Mary2’</p><p>put ‘teacher’,’91001’,’username’,’Mary3’</p><p>put ‘teacher’,’91001’,’username’,’Mary4’  </p><p>put ‘teacher’,’91001’,’username’,’Mary5’</p><p>3）查询时，指定查询的历史版本数。默认会查询出最新的数据。（有效取值为1到5）</p><p>get ‘teacher’,’91001’,{COLUMN=&gt;’username’,VERSIONS=&gt;5}</p><p>\9. 退出HBase数据库表操作</p><p>exit</p><p>l 注意：这里退出HBase数据库是退出对数据库表的操作，而不是停止启动HBase数据库后台运行。</p><p>\10. 停止HBase运行</p><p>bin/stop-hbase.sh</p><p>11.关闭Hadoop</p><p>./sbin/stop-all.sh  </p><p>（二）Java API编程实例</p><p>\1. 启动hadoop，启动hbase(运行java代码时一定要保证hbase是启动状态)</p><p>cd /usr/local/hadoop</p><p>./sbin/start-all.sh</p><p>cd /usr/local/hbase</p><p>./bin/start-hbase.sh</p><p>2.在Eclipse中新建Java Project（Project名字为你名字的拼音，注意下图框起来部分）——&gt;新建Class</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps17.png" alt="img"><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps18.jpg" alt="img"> </p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps19.jpg" alt="img"> </p><p>\3. 在工程中导入外部jar包</p><p>l 在项目名称上右键选Property，在弹出的对话框左侧列表中选择Java Build Path，如下图所示：选择Add External JARs</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps20.png" alt="img"><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps21.jpg" alt="img"> </p><p>l 导入hbase安装目录中的lib（usr/local/hbase/lib,注意目录不要选错）文件中的所有jar包</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps22.jpg" alt="img"> </p><p>4.编写代码并运行</p><p>l 在Linux系统中打开浏览器，输入网址<a href="http://dblab.xmu.edu.cn/blog/install-hbase/%E5%A4%8D%E5%88%B6%E4%BB%A3%E7%A0%81%E3%80%82">http://dblab.xmu.edu.cn/blog/install-hbase/复制代码。</a></p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps23.jpg" alt="img"> </p><p>l 复制完成后，编译运行，Run as Java Application。运行成功后如图</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps24.jpg" alt="img"> </p><p>\5. 进入Hbase shell</p><p>scan ‘Score’ </p><p>\6. 在Eclipse中执行其它语句（除了createTable语句外，每人任选两条以上语句执行，每次执行一条，在Eclipse执行完后在shell中查看结果。）</p><p>l 主函数中的语句请任选两条执行，只需删除其前的//，并将其它语句注释掉即可，如：执行insertRow时请将其他语句注释</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps25.jpg" alt="img"> </p><p>l 执行完成后在shell中查看结果</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps26.jpg" alt="img"> </p><p>7.关闭hbase和hadoop</p><p>bin/stop-hbase.sh</p><p>./sbin/stop-all.sh  </p><h2 id="实验四"><a href="#实验四" class="headerlink" title="实验四"></a>实验四</h2><p>七、实验步骤</p><p>（一）安装 Hadoop-Eclipse-Plugin</p><p>进入本地文件系统的“下载”文件夹，单击右键，点在终端打开。</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps45.jpg" alt="img"> </p><p>l 在终端中输入命令(或者直接在文件系统中将该jar包拷贝到/usr/local/eclipse/plugins/中)</p><p>sudo cp hadoop-eclipse-plugin-2.6.0.jar /usr/local/eclipse/plugins/</p><p>l 复制完成后 使用以下命令，查看该jar包是否复制成功。</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps46.jpg" alt="img"> </p><p>l 在shell中运行以下命令重启 Eclipse </p><p>/usr/lib/eclipse/eclipse -clean</p><p>（二）在hadoop的HDFS文件系统中新建输入文件夹</p><p>1.启动hadoop</p><p>cd /usr/local/hadoop</p><p>./sbin/start-all.sh</p><p>2.在HDFS中创建用户目录</p><p>l 本实验环境的Hadoop为伪分布式，伪分布式读取的则是 HDFS 上的数据。要使用 HDFS，首先需要创建用户目录。（已存在该文件夹则跳过这步）</p><p>bin/hdfs dfs -mkdir -p /user/hadoop</p><p>l 接着将 etc/hadoop 中的文件作为输入文件复制到分布式文件系统中，即将 /usr/local/hadoop/etc/hadoop 复制到分布式文件系统中的 /user/hadoop/input 中。上一步已创建了用户目录 /user/hadoop ，因此命令中就可以使用相对目录如 input，其对应的绝对路径就是 /user/hadoop/input:</p><p>bin/hdfs dfs -put etc/hadoop/*.xml input</p><p>l 查看input中的文件</p><p>bin/hdfs dfs –ls /user/hadoop/input</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps47.jpg" alt="img"> </p><p>l 程序统计的就是这些文件中的词频。</p><p>l 也可以自己创建文件拷贝到hdfs中进行统计。</p><p>（三） 配置 Hadoop-Eclipse-Plugin</p><p>1.启动Eclipse</p><p>l 启动 Eclipse 后就可以在左侧的Project Explorer中看到 DFS Locations</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps48.jpg" alt="img"> </p><p>\2. 进一步配置插件</p><p>l 第一步，选择 Window 菜单下的 Preference。</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps49.jpg" alt="img"> </p><p>l 此时会弹出一个窗体，窗体的左侧会多出 Hadoop Map/Reduce 选项，点击此选项，选择 Hadoop 的安装目录（如/usr/local/hadoop，Ubuntu不好选择目录，直接输入就行）。</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps50.jpg" alt="img"> </p><p>l 第二步：切换 Map/Reduce 开发视图，选择 Window 菜单下选择 Open Perspective -&gt; Other，弹出一个窗体，从中选择 Map/Reduce 选项即可进行切换。</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps51.jpg" alt="img"> </p><p>l 第三步：建立与 Hadoop 集群的连接，点击 Eclipse软件右下角的 Map/Reduce Locations 面板，在面板中单击右键，选择 New Hadoop Location。</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps52.png" alt="img"><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps53.jpg" alt="img"> </p><p>l 在弹出来的 General 选项面板中，General 的设置要与 Hadoop 的配置一致。一般两个 Host 值是一样的，如果是伪分布式，填写 localhost 即可，另外我们使用的<a href="http://dblab.xmu.edu.cn/blog/install-hadoop/">Hadoop伪分布式配置</a>，设置 fs.defaultFS 为 hdfs://localhost:9000，则 DFS Master 的 Port 要改为 9000。Map/Reduce(V2) Master 的 Port 用默认的即可，Location Name 随意填写。</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps54.jpg" alt="img"> </p><p>（四）在 Eclipse 中操作 HDFS 中的文件</p><p>l 配置好后，点击左侧 Project Explorer 中的 MapReduce Location （点击三角形展开）就能直接查看 HDFS 中的文件列表了，双击可以查看内容，右键点击可以上传、下载、删除 HDFS 中的文件，无需再通过繁琐的 hdfs dfs -ls 等命令进行操作了。</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps55.jpg" alt="img"> </p><p>（五）在 Eclipse 中创建 MapReduce 项目</p><p>l 点击 File 菜单，选择 New -&gt; Project…选择 Map/Reduce Project，点击 Next。</p><p>l 填写 Project name 为 WordCount 即可，点击 Finish 就创建好了项目。</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps56.jpg" alt="img"> </p><p>l 右键点击刚创建的 WordCount 项目，选择 New -&gt; Class</p><p>l 需要填写两个地方：在 Package 处填写 org.apache.hadoop.examples；在 Name 处填写 WordCount。</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps57.jpg" alt="img"> </p><p>l 创建 Class 完成后，在 Project 的 src 中就能看到 WordCount.java 这个文件。将如下 WordCount 的代码复制到该文件中。</p><p>l 用linux浏览器打开网址复制WordCount代码<a href="http://dblab.xmu.edu.cn/blog/hadoop-build-project-using-eclipse/">http://dblab.xmu.edu.cn/blog/hadoop-build-project-using-eclipse/</a></p><p>（六）通过 Eclipse 运行 MapReduce</p><p>l 在运行 MapReduce 程序前，还需要将 /usr/local/hadoop/etc/hadoop 中将有修改过的配置文件（如伪分布式需要修改 core-site.xml 和 hdfs-site.xml，本镜像已完成修改），以及 log4j.properties 复制到 WordCount 项目下的 src 文件夹（~/workspace/WordCount/src）中。在shell中完成复制。</p><p>cp /usr/local/hadoop/etc/hadoop/core-site.xml ~/workspace/WordCount/src</p><p>cp /usr/local/hadoop/etc/hadoop/hdfs-site.xml ~/workspace/WordCount/src</p><p>cp /usr/local/hadoop/etc/hadoop/log4j.properties ~/workspace/WordCount/src</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps58.jpg" alt="img"> </p><p>l 复制完成后，务必右键点击 WordCount 选择 refresh 进行刷新（不会自动刷新，需要手动刷新），可以看到文件结构如下所示：</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps59.jpg" alt="img"> </p><p>l 点击工具栏中的 Run 图标，或者右键点击 Project Explorer 中的 WordCount.java，选择 Run As -&gt; Run on Hadoop，就可以运行 MapReduce 程序了。不过由于没有指定参数，运行时会提示 “Usage: wordcount “，需要通过Eclipse设定一下运行参数。</p><p>l 右键点击刚创建的 WordCount.java，选择 Run As -&gt; Run Configurations，在此处可以设置运行时的相关参数（如果 Java Application 下面没有 WordCount，那么需要先双击 Java Application）。切换到 “Arguments” 栏，在 Program arguments 处填写 “input output” 就可以了。</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps60.jpg" alt="img"> </p><p>l 设定参数后，再次运行程序，可以看到运行成功的提示。</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps61.jpg" alt="img"> </p><p>l 可以在Shell中查看结果：</p><p>./bin/hdfs dfs –cat output/*</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps62.jpg" alt="img"> </p><p>l 提示：如果提示错误“-Syntax error, parameterized types are only availble if source level is 1.5 or greater”。单击错误提示图标，在弹出的对话框中，在Change project compliance and JRE to 1.5 这行文字上双击，就可以让错误信息消失。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>基于RNN、LSTM神经网络的基金净值预测</title>
      <link href="2021/05/30/LSTMkeras/"/>
      <url>2021/05/30/LSTMkeras/</url>
      
        <content type="html"><![CDATA[<blockquote><p>都是神经网络惹的祸</p></blockquote><p>&nbsp; &nbsp; &nbsp; &nbsp; 这个月花了将近100G的流量，大半都拿来下学习视频了。上次写了个爬虫把基金数据爬下来了，说是要数据分析一波，头脑热了一个礼拜，每天晚上都在搞神经网络的代码，光是装TensorFlow环境就搞了我3个晚上，到处在网上找代码学习，本来就差最后一步就把要程序跑出来了，结果卡在了反归一化上面，输入输出维度不匹配，又搞了好几天，终于神经网络把我劝退了。我发现这样是行不通的，整得太浮躁了，不懂计算原理直接啃代码，连输入输出是什么都不懂，一些基本的激活函数、归一函数、评价模型都不懂想直接调包也没那么容易，出结果<br></p><p>&nbsp; &nbsp; &nbsp; &nbsp;后来大概过了大半个月，机缘巧合正好需要用到机器学习，我拾起了之前留下的烂摊子，慢慢（假的）基础知识学习，又搞起了机器学习。<br></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 今天终于能把神经网络跑出来了😁好久没更新博客了，主要是最近没啥时间搞自己的东西，作业都写不完</p><h2 id="大家好，我是调包侠"><a href="#大家好，我是调包侠" class="headerlink" title="大家好，我是调包侠"></a>大家好，我是调包侠</h2><p>虽然把神经网络跑出来了，中间还有些小问题，预测效果也不是很好，但是能跑出来</p><p>我就非常开心了，后面会再把基础打扎实一些。<br></p><p>先看效果图：</p><p><img src="/2021/05/30/LSTMkeras/%E9%A2%84%E6%B5%8B.png" alt="预测"></p><p>两条线基本拟合度不是很好，甚至可以说两条线没什么关系，细节波动预测不到，但是大致走势还比较正确（已经调整过很多种方案了，这是还比较像人样的）<br></p><p>看看他的过去：可以说是毫不相干😡<br></p><p>最开始这是纯RNN模型</p><p><img src="/2021/05/30/LSTMkeras/RNN.png" alt="RNN"></p><p>后来我改成了LSTM模型，发现更离谱：（后来我把模型的第一层改成LSTM就得到了图一）</p><p><img src="/2021/05/30/LSTMkeras/LSTM.png"></p><p>大概可以看出加入LSTM模型，预测值将会变得更趋于平缓，我猜可能是因为LSTM模型对长期记忆性导致的<br></p><p>其中存在的问题是每次Epoch的val_loss值都是不变，而且loss值为什么都是nan，我去看了网上说是每次训练出来的权重不变（或者说没有更新），或者是模型错误造成的，俺不懂怎么办了，百思不得其解，有没有懂得大佬指点一下，感激涕零😭<img src="/2021/05/30/LSTMkeras/%E6%8D%9F%E5%A4%B1%E5%80%BC.png" alt="损失值"></p><h2 id="下面康康学习过程"><a href="#下面康康学习过程" class="headerlink" title="下面康康学习过程"></a>下面康康学习过程</h2><p>好多包，我好爱</p><pre><code class="line-numbers language-python">import numpy as npimport tensorflow as tffrom tensorflow.keras.layers import Dropout, Dense, SimpleRNN, LSTMimport matplotlib.pyplot as pltimport osimport pandas as pdfrom sklearn.preprocessing import MinMaxScalerfrom sklearn.metrics import mean_squared_error, mean_absolute_errorimport math</code></pre><p>导入数据和数据预处理：</p><pre><code class="line-numbers language-python">yiliao = pd.read_csv('./SH600519.csv')#print(yiliao)training_set = yiliao.iloc[0:2426 - 300, 2:3].values  #前（1975-300）天的净值作为训练集，表格从0开始计数，2:3是提取[1:2）列，前闭后开，故提取出第二列净值test_set = yiliao.iloc[2426 - 300:, 2:3].values  #后300天的开盘价作为测试集#归一化sc = MinMaxScaler(feature_range=(0, 1))  #定义归一化；缩放到（0,1）之间training_set_scaled = sc.fit_transform(training_set)  #求得训练集的最大最小值这些训练集固有的属性，并在训练集上进行归一化test_set = sc.fit_transform(test_set)  #利用训练集的属性对测试集进行归一化</code></pre><p>还是数据预处理，将数据训练集和测试集划分</p><pre><code class="line-numbers language-python">测试集：csv表格中的前1975-300=1675天的数据#利用for循环，遍历整个训练集，提取训练集中连续60天的开盘价作为输入特征x_train,第61天的数据作为标签，for循环共构建1975-300-60=1615for i in range(60, len(training_set_scaled)):    x_train.append(training_set_scaled[i - 60:i, 0])    y_train.append(training_set_scaled[i: 0])#打乱训练集顺序np.random.seed(7)np.random.shuffle(x_train)np.random.seed(7)np.random.shuffle(y_train)tf.random.set_seed(7)#将训练集由list格式变为array格式x_train, y_train = np.array(x_train), np.array(y_train)#此处整个数据集送入，送入样本数为x_train.shape[0]及1615组数据x_train = np.reshape(x_train, (x_train.shape[0], 60, 1))#测试集：csv表格中后300天数据#...省略for i in range(60, len(test_set)):    x_test.append(test_set[i - 60:i, 0])    y_test.append(test_set[i, 0])#测试集变arry并reshape为符合RNN输入要求：[送入样本数， 循环核时间展开步数， 每个时间步输入的特征个数]x_test, y_test = np.array(x_test), np.array(y_test)x_test = np.reshape(x_test, (x_test.shape[0], 60, 1))</code></pre><p>设定模型：</p><pre><code class="line-numbers language-python">model = tf.keras.Sequential([    SimpleRNN(80, return_sequences=True),    Dropout(0.2),    SimpleRNN(100),    Dropout(0.2),    Dense(1)])model.compile(optimizer=tf.keras.optimizers.Adam(0.001),loss='mean_squared_error')  #损失函数用均方误差</code></pre><p>保存训练好的模型：</p><pre><code class="line-numbers language-python">checkpoint_sava_path = "./checkpoint/jijin.ckpt"if os.path.exists(checkpoint_sava_path + '.index'):    print('--------load the model--------')    model.load_weights(checkpoint_sava_path)cp_callback = tf.keras.callbacks.ModelCheckpoint(filepath=checkpoint_sava_path,                                                 save_weights_only=True,                                                 save_best_only=True,                                                 monitor='val_loss')history = model.fit(x_train, y_train, batch_size=128, epochs=5, validation_data=(x_test, y_test), validation_freq=1,                    callbacks=[cp_callback])model.summary()file = open('./weight.txt', 'w')  #参数提取for v in model.trainable_variables:    file.write(str(v.name) + '\n')    file.write(str(v.shape) + '\n')    file.write(str(v.numpy()) + '\n')file.close()loss = history.history['loss']val_loss = history.history['val_loss']</code></pre><p>画出损失函数图：</p><pre><code>plt.plot(loss, label='Training Loss')plt.plot(val_loss, label='Validation Loss')plt.title('Training and Validation Loss')plt.legend()plt.show()</code></pre><p>测试集输入模型开始预测：</p><pre><code class="line-numbers language-python">predicted_stock_price = model.predict(x_test)# 对预测数据还原--从（0-1）反归一化到原始范围predicted_stock_price = sc.inverse_transform(predicted_stock_price)# 对真实数据还原--从0-1）反归一化到原始范围real_stock_price = sc.inverse_transform(test_set[60:])# 画出真实数据和预测数据对比曲线plt.plot(real_stock_price, color='red', label='Jijin Price')plt.plot(predicted_stock_price, color='blue', label='Predicted Jijin Price')plt.title('Jijin Price Prediction')plt.xlabel('Time')plt.ylabel('Jijin Price')plt.legend()plt.show()</code></pre><p>评价模型：</p><pre><code class="line-numbers language-python">mse = mean_squared_error(predicted_stock_price, real_stock_price)# 均方根误差rmse = math.sqrt(mean_squared_error(predicted_stock_price, real_stock_price))# 平均绝对误差mae = mean_absolute_error(predicted_stock_price, real_stock_price)</code></pre><p>以上<br></p><p><strong>完整代码会上传到我的<a href="https://github.com/yuukyou-chan">Github</a>，欢迎fock，顺便求助一下俺的问题555</strong></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 神经网络 </tag>
            
            <tag> LSTM </tag>
            
            <tag> RNN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习入门笔记</title>
      <link href="2021/05/21/ML/"/>
      <url>2021/05/21/ML/</url>
      
        <content type="html"><![CDATA[<h1 id="一、数据处理"><a href="#一、数据处理" class="headerlink" title="一、数据处理"></a>一、数据处理</h1><h2 id="缺失值判断："><a href="#缺失值判断：" class="headerlink" title="缺失值判断："></a>缺失值判断：</h2><ol><li><p><code>pd.isnull(movie)</code> 如果是缺失值返回true；</p><p>返回结果是一张表，表里填满 true和false；</p></li><li><p>判断整张表是否有缺失值：</p><p><code>np.any(pd.isnull(movie))</code></p><p>反三：any-all      isnull-notnull</p><p>返回结果为一个值：true/false</p></li></ol><h2 id="缺失值删除和替换"><a href="#缺失值删除和替换" class="headerlink" title="缺失值删除和替换"></a>缺失值删除和替换</h2><ol><li><p><code>movie(“列变量名”).fillna(value=movie["列变量名"].mean(), inplace=True)</code>  </p><p>替换变量函数：fillna( )</p><p>.mean()：用该列平均值替换NaN值</p><p>inplace=Ture:   不创建新的对象，直接对原始对象进行修改；</p><p>inplace=False：对数据进行修改，创建并返回新的对象承载其修改结果。</p></li><li><p>替换所有缺失值：</p><pre><code class="line-numbers language-python">for i in movie.columns：    #遍历列  if np.any(pd.isnull(movie[i])) == True:  #如果此列有NaN值        movie[i].fillna(value=movie[i].mean(), inplace=True)np.any(pd.isnull(movie))  #检测是否替换完成</code></pre></li><li><p>删除缺失值（整张表中）</p><p><code>data = movie.dropna()</code></p></li><li><p>缺失值不是NaN的处理情况</p><p>如将 “？”替换成np.nan</p><p><code>wis = wis.replace(to_replace='?',value=np.NaN)</code></p></li></ol><h2 id="数据离散化"><a href="#数据离散化" class="headerlink" title="数据离散化"></a>数据离散化</h2><p><code>pd.qcut(data,q)</code></p><h2 id="数据合并"><a href="#数据合并" class="headerlink" title="数据合并"></a>数据合并</h2><p><code>pd.concat({data, data_dummies}, axis=1)</code> axis参数表作用方向：此句中的axis=1表示两张表按行(水平方向)拼接</p><p><code>pd.merge(left, right, how="inner", left_on=None,right_on=None)</code></p><h2 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h2><p>seaborn库介绍</p><ul><li>seaborn.implot() 可以再绘制二维散点图时自动完成回归拟合</li><li>data=  ：关联数据集</li><li>hue=“</li></ul><p>matplotlin库介绍</p><p>绘制柱状图：</p><p><img src="/2021/05/21/ML/ML%5C%E6%9F%B1%E7%8A%B6%E5%9B%BE.png" alt="image-20210523160542346"></p><h2 id="数据归一化"><a href="#数据归一化" class="headerlink" title="数据归一化"></a>数据归一化</h2><pre><code class="line-numbers language-python">from sklearn.preprocessing import MinMaxScaler</code></pre><p><img src="/2021/05/21/ML/ML%5C%E6%95%B0%E6%8D%AE%E5%BD%92%E4%B8%80%E5%8C%96.png" alt="image-20210528115638416"></p><p><img src="/2021/05/21/ML/ML%5C%E5%BD%92%E4%B8%80%E5%8C%96%E5%AE%9E%E4%BE%8B.png" alt="image-20210528131156366"></p><h2 id="数据标准化"><a href="#数据标准化" class="headerlink" title="数据标准化"></a>数据标准化</h2><p><img src="/2021/05/21/ML/ML%5C%E6%95%B0%E6%8D%AE%E6%A0%87%E5%87%86%E5%8C%96API.png" alt="image-20210528131816039"></p><p>实例：修改归一化实例图中的<code>transfer = StandardScaler</code> 即可</p><h2 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h2><p>API：<code>sklearn.linear_model.LinearRegression()</code></p><p>属性：LinearRegression.coef_：回归系数</p><p><img src="/2021/05/21/ML/ML%5C%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92.png" alt="image-20210523163608946"></p><p>优化算法:</p><ul><li>正规方程(直接矩阵运算求w权重,如果特征多求解速度慢,只能在线性回归总运用),</li><li>梯度下降(沿着切线向下的方向，递归迭代计算权重,广泛使用)：找到当误差最小时，最优自变量|权重|参数</li><li>性能评估：使用均方误差；<br>适用场景：</li><li>小规模数据建议LinearRegression(不能解决过拟合问题)和岭回归；</li><li>大规模用SGDRegressor：随机梯度下降</li></ul><h3 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h3><p>目的：求出当误差最小时，最优自变量|权重|参数</p><p><code>sklearn.linear_model.SGDRegression()</code></p><ul><li>包：from sklearn.linear_model import SGDRegressor</li><li>支持loss函数(损失类型),和正则化惩罚项来拟合线性回归模型</li><li>loss=‘squared_loss’:默认普通最小二乘法</li><li>可以用网络搜索算法来优化学习率和梯度迭代次数</li><li>fit_intercept=True :是否计算偏置</li><li>learning_rate=‘invscaling’:学习率</li><li>‘invscaling’：学习率算法 包含 “comstant”,“optimal”,‘invscaling’,</li></ul><p>对于常数值的学习率可以使用<strong>“comstant”</strong>==0</p><p>max_iter=None,梯度迭代次数<br>SGDRegressor.coef_:查看回归系数函数</p><p><img src="/2021/05/21/ML/ML%5Cimage-20210528133121562.png" alt="image-20210528133121562"></p><p><img src="/2021/05/21/ML/ML%5C%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E5%B8%B8%E7%94%A8%E5%B8%B8%E6%95%B0.png" alt="image-20210528133745820"></p><p><code>learning_rate = "constant" </code>指学习率为常数，但是一般常数学习率效果不好，需要使用动态变化的学习率（invscaling）</p><p>eta0：<strong>一般取值 0.01 ~ 0.001 为宜</strong></p><h2 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h2><p>思想：输入最原始、最基本的数据，通过模型来进行特征工程，进行更高级的特征学习（多个特征值聚合成一个特征值），然后通过传入的数据来确定合适的参数，让模型更好的拟合数据。</p><p>激活函数：</p><ul><li>作用：增加模型的非线性分割能力，提供鲁棒性（健壮性），缓解梯度消失，加速模型收敛</li><li>常用sigmoid：（0-1）、tanh</li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 数据挖掘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库学习笔记（持续更新4.18）</title>
      <link href="2021/04/17/DataBase/"/>
      <url>2021/04/17/DataBase/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章：绪论"><a href="#第一章：绪论" class="headerlink" title="第一章：绪论"></a>第一章：绪论</h1><h1 id="第二章：关系型数据库"><a href="#第二章：关系型数据库" class="headerlink" title="第二章：关系型数据库"></a>第二章：关系型数据库</h1><blockquote><h3 id="1、一些概念"><a href="#1、一些概念" class="headerlink" title="1、一些概念"></a>1、一些概念</h3></blockquote><p>关系：实体与实体之间的联系（可以看做一张二维表）、</p><p>候选码：若关系中的一个属性或属性组的值能够唯一地标识一个元组，且他的真子集不能唯一的标识一个元组，则称这个属性或属性组做候选码。</p><p>主码：若一个关系有多个候选码，则选定其中一个为主码</p><p>主属性：候选码的各个属性成为主属性</p><p>全码：表中的所有属性都是这个表的候选码，则称为全码</p><p><strong>外键（外码）</strong>：<mark>如果公共关键字在一个关系中是主键，那么这个公共关键字被称为另一个关系的外键。</mark></p><p>关系三种类型：①基本表（基本关系）②查询表③视图表</p><p>关系模式：关系的描述称为关系模式（即为表头）</p><blockquote><h3 id="2、关系完整性"><a href="#2、关系完整性" class="headerlink" title="2、关系完整性"></a>2、关系完整性</h3></blockquote><ol><li>实体完整性：实体完整性要求每个数据表都必须有主键，而作为主键的所有字段，其属性必须是独一及<strong>非空值</strong>。</li><li>参照完整性：参照的关系中的属性值必须能够在被参照关系找到或者取空值</li><li>用户定义完整性</li></ol><blockquote><h3 id="3、列级完整性约束和表级完整性约束"><a href="#3、列级完整性约束和表级完整性约束" class="headerlink" title="3、列级完整性约束和表级完整性约束"></a>3、列级完整性约束和表级完整性约束</h3></blockquote><p>列级约束有六种：Primary key（主键）、foreign key（外键） 、 unique（唯一）、 check （检查）、default （默认）、not null/ null（非空/空值 ）<br>表级约束有四种：Primary key（主键）、foreign key（外键） 、 unique（唯一）、 check （检查）</p><p><strong>只能是列级完整性约束</strong>：default （默认）、not null/ null（非空/空值 ）</p><h1 id="第三章：SQL语句"><a href="#第三章：SQL语句" class="headerlink" title="第三章：SQL语句"></a>第三章：SQL语句</h1><blockquote><h3 id="1、数据类型"><a href="#1、数据类型" class="headerlink" title="1、数据类型"></a>1、数据类型</h3></blockquote><p><img src="/2021/04/17/DataBase/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B1.png" alt="数据类型1"></p><p><img src="/2021/04/17/DataBase/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B2.png" alt="数据类型2"></p><blockquote><h3 id="2、基本表的定义、修改与删除"><a href="#2、基本表的定义、修改与删除" class="headerlink" title="2、基本表的定义、修改与删除"></a>2、基本表的定义、修改与删除</h3></blockquote><h5 id="基本操作语句"><a href="#基本操作语句" class="headerlink" title="基本操作语句"></a>基本操作语句</h5><h5 id="表的定义"><a href="#表的定义" class="headerlink" title="表的定义"></a>表的定义</h5><pre><code class="line-numbers language-sql">create table student (    列名 数据类型 列级完整性约束    sno char(9) unique,    ssex char(2),    primary KEY(sno),    foreing key(sno) refferences student(sno));</code></pre><h5 id="表的修改"><a href="#表的修改" class="headerlink" title="表的修改"></a>表的修改</h5><h5 id="表的删除"><a href="#表的删除" class="headerlink" title="表的删除"></a>表的删除</h5><blockquote><h3 id="3、数据查询"><a href="#3、数据查询" class="headerlink" title="3、数据查询"></a>3、数据查询</h3></blockquote><p><strong>数据查询是数据库的<mark>核心操作</mark></strong></p><p>查询的一般格式（块）为：</p><pre><code class="line-numbers language-sql">select  目标列表达式from 表明或视图名where 条件表达式group by 列名 having 选择组的条件order by 列名 asc/desc（升降序）</code></pre><p><mark><strong>执行顺序为</strong></mark>：from→where→select</p><h4 id="一、单表查询："><a href="#一、单表查询：" class="headerlink" title="一、单表查询："></a>一、单表查询：</h4><ol><li><p><strong>选择表中的若干列</strong></p><p>（1）查询指定列</p><pre><code class="line-numbers language-sql">select Sname，Sno，Sdeptfrom Student；</code></pre><p>（2）查询所有列</p><pre><code class="line-numbers language-sql">select *from Student；</code></pre><p>（3）查询经过计算的值</p><p>select语句中的目标表达式可以是表中的<strong>属性列</strong>，也可以是<strong>表达式</strong>，还可以是<strong>字符串常量</strong>、<strong>函数</strong>等</p><p>例：查询全体学生的姓名及其出生年份</p><pre><code class="line-numbers language-sql">select Sname，'Year of Birth' birth，2021-Sage   /*当前年份-年龄*/from Student；</code></pre><p>输出结果为：</p><table><thead><tr><th align="center">Sname</th><th align="center">birth</th><th align="center">2021-Sage</th></tr></thead><tbody><tr><td align="center">李勇</td><td align="center">Year of Birth</td><td align="center">1994</td></tr><tr><td align="center">李晨</td><td align="center">Year of Birth</td><td align="center">1995</td></tr></tbody></table><p>注意：上方代码块中的<code> 'Year of Birth' birth</code>表示将’Year of Birth’列命名为birth，中间用空格号分隔开</p><br></li><li><p><strong>选择表中的若干元组</strong></p></li></ol><p>（1）消除取值重复的行</p><p><strong>distinct</strong>：消除取值重复的行<code> select distinct Sno</code><br></p><p>若没有指定<code>distinct</code>关键字则默认为all</p><p>（2）查询满足条件的元组</p><p><strong>where</strong>：查询满足条件的元组</p><p><img src="/2021/04/17/DataBase/%E5%B8%B8%E7%94%A8%E6%9F%A5%E8%AF%A2%E6%9D%A1%E4%BB%B6.png" alt="常用查询条件"></p><pre><code class="line-numbers language-sql">①比较大小where Sdept='cs'where Sage&lt;20②确定范围where Sage between 20 and 23③确定集合where Sedpt in('CS','MA','IS')④字符分配  %：代表任意长度（可以为0）的字符串。  _：代表任意单个字符where Sname like'_阳%'（查询第二个字为阳的学生）⑤涉及空值的查询where Grade is null⑥多充条件查询使用 and 或者 or，通常 and的优先级高于 or，可以使用括号改变优先级where Sdept='CS'and Sage&lt;20注：实际上 in是多个 or运算符的缩写</code></pre><br><p>   3.<strong>order by语句</strong></p><p>升序：ASC</p><p>降序：DESC</p><p><strong>默认为升序</strong></p><p>例：查询结果按所在的系的系号升序排列，同一系中的学生按年龄降序排列：</p><p><code>order by Sdept，Sage desc</code></p><br><ol start="4"><li><strong>聚集函数</strong></li></ol><p><img src="/2021/04/17/DataBase/DataBase%5C%E8%81%9A%E9%9B%86%E5%87%BD%E6%95%B0.png" alt="聚集函数"></p><p><code>查询学生总人数：select count(distinct Sno)</code></p><p><code>计算平均成绩：select avg(Grade)</code></p><br><ol start="5"><li><strong>group by 语句</strong></li></ol><p>group by子句将查询结果按某一列或多列的值分组，值相等的为一组。</p><pre><code class="line-numbers language-sql">求各个课程号及相应选课人数select Con,count(Sno)from scgroup by Con***查询选修了三门以上课程的学生学号select Snofrom scgroup by Snohaving count()***求选课在三门以上（包括三门）且各门课程均及格的学生的学号及其总成绩，查询结果按总成绩降序列出select sno,sum(score)from scwhere score&gt;=60group by snohaving count(*)&gt;=3order by sum(score)desc执行过程：1.from   取出整个sc2.where  筛选score&gt;=60的元组3.group by  将选出的元组按sno分组4.having  筛选选课三门以上的分组5.select  将选中的组中提取学号和总成绩6.order by  将选取结果排序先用where语句查询效率更高，如果直接用group则将会在sc表中的所有元组进行分组，若先用where则group将在筛选出来的元组中进行分组，提高了查询效率。</code></pre><p>执行顺序为：where→group by→having</p><p>辨析：where作用于<strong>基本表</strong>或者<strong>视图</strong>，having作用于<strong>组</strong></p><br><h4 id="二、连接查询"><a href="#二、连接查询" class="headerlink" title="二、连接查询"></a>二、连接查询</h4><p><strong>1.等值于非等值连接查询</strong></p><p><code>where student.sno = sc.sno</code></p><p>以上比较运算符‘ = ’可以有：=、&gt;、&lt;、&gt;=、&lt;=</p><p><em>此时连接查询的where句子用来连接两个表的条件称为<strong>连接条件</strong>或者*<em>连接谓词</em></em></p><p>*连接谓词中的列名称为<strong>连接字段</strong>（student.sno）</p><br><p><strong>2.自身连接</strong></p><br><p><strong>3.外连接</strong></p><p>定义：有时想以学生标student为主体，列出每个学生的基本情况及选课情况，如果某个学生没有选课，仍把该学生的记录留在结果关系中，而在sc表中的属性值加上NULL，这时就需要外连接。</p><pre><code class="line-numbers language-sql">  </code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库，学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于爬虫爬取基金信息</title>
      <link href="2021/04/11/FundSpyder/"/>
      <url>2021/04/11/FundSpyder/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>  经常看到和听到神经网络这个名词，觉得逼格很高。昨天看了一下机器学习的神经网络算法，是挺高级的，还蛮感兴趣，就是看不懂哈哈哈哈。在B站上看了一个《一小时大话BP神经网络》教我如何从入门到放弃（打脸）。里面涉及的数学统计知识太多了，可惜我是个数学白痴，但是对机器学习确实蛮感兴趣的，神经网络学不明白可以换个简单的机器学习模型试试。后来想着能不能用机器学习预测一下基金走势，随便玩玩不做投资建议，体验一下机器学习的高大上，等我撸出机器学习模型的demo也算是半个涉足过人工智能领域的大学生了哈哈哈哈哈哈哈哈。</p><p>  这篇文章便是为了提供机器学习数据基础——收集基金信息。</p><h2 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h2><ol><li>选择一个好爬的基金网页，这里以天天基金为例（网上关于天天基金爬取教程还蛮多的哈，可能是好抓包）</li><li>打开浏览器的开发工具，切换到network下，点击下一页基金，查看发送的ajax请求。很容易发现有个请求里的jason数据就是我们想要的数据，抓到包就可以开始撸代码了！</li><li>具体代码思路不细说了，看代码注释也比较详细了</li></ol><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><pre><code class="line-numbers language-python">import requestsimport jsonimport reimport pandas as pddf_list = []  #用于存放每页表格for index in range(1,100):  #index是url中的页码，在url中用占位符表示    url = 'http://api.fund.eastmoney.com/f10/lsjz?callback=jQuery1830730414064313736_1618137747657&amp;fundCode=110023&amp;pageIndex={}&amp;pageSize=20&amp;startDate=&amp;endDate=&amp;_=1618137795389'.format(index)    #请求头    headers = {        #防盗链     确定来路        'Referer': 'http://fundf10.eastmoney.com/',        #身份证        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.114 Safari/537.36'    }    # 模拟浏览器发送请求  接收数据    resp = requests.get(url,headers=headers)    html = resp.text    res = re.findall('\((.*?)\)',html) #正则表达式把jquery....去掉    datas = json.loads(res[0])["Data"]["LSJZList"] # res是数组，要用res[0]表示                                                   # json.loads 用于提取字符串中的json格式    # 整理成表的形式    df = pd.DataFrame(datas)    df_list.append(df)  #apend方法：在表末尾添加元素df_data = pd.concat(df_list)df_data.to_csv('易方达医疗保健行业混合 (110023).csv',index=False) #index=false 表示不输出索引值</code></pre><h2 id="爬取结果"><a href="#爬取结果" class="headerlink" title="爬取结果"></a>爬取结果</h2><p>在工程文件路径下生成了一个.csv文件（.csv常用于数据分析）</p><p><img src="/2021/04/11/FundSpyder/1.png" alt="1"></p><p>把这支基金从出生到现在的数据都爬完啦，也就不到2000组（为了便于观看，列名已经修改）</p><p><img src="/2021/04/11/FundSpyder/2.png" alt="2"></p><hr><p>  以上就是数据收集的过程，不知道下篇能不能找到合适的机器学习模型建立，希望能找一个既简单拟合度又不是太离谱的模型吧😚😚😚</p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于java实现自动核查作业程序check</title>
      <link href="2021/03/30/JavaCheck/"/>
      <url>2021/03/30/JavaCheck/</url>
      
        <content type="html"><![CDATA[<h2 id="编写背景"><a href="#编写背景" class="headerlink" title="编写背景"></a>编写背景</h2><p>  大二上学期期末的时候堆了一堆实验报告要交，数据结构2个实验，java4个实验，还有线代截图要收，每次收作业即使通知同学们按规定命名文件但还有很多同学不按规定命名五花八门啥都有，每次收作业都要收个1 个多小时才能收齐，期末都没得时间复习了<span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p>  然后刚好那个学期学了java，对java还比较感兴趣和熟悉，刚一考完试我就开始动手了，边学边写花了我5个小时。整个代码的实现逻辑都是自己想的，然后剩下一下没学过的类和方法在网上学习。之前用python写过一个差不多的十几行的代码实现“微信群接龙”查找名字，这个程序也是借鉴了上次的思想。</p><p>  这是V1.0版本的，功能只有查找没交作业名单的功能，本来第二次更新V2.0的时候加入了自动重命名功能的，但是我今天在打开NetBeans的时候之前写代码都不见了55555，Github上也找不到（我记得当时备份了yue），现在这个代码还是我翻聊天记录找的，之前复制给别的班学委留下来的记录（还好当时发给别人过）。不然真的惨死了，真的一点都想不起来之前怎么写的了。</p><p>  <strong>V2.0</strong>版本虽然新增了自动重命名功能，但是我当时并没有把学号加进去，当时是有思路的，但嫌麻烦是懒得弄了，看需要吧，如果我或者大家需要自动重命名功能的话我到时会在重新写一个完整的。</p><p>  <strong>V3.0</strong>版本我当时是想做一个GUI然后打包的，方便大家使用，本来是想在暑假做的，后来暑假。。。（懂得都懂）结果现在关于GUI的知识也都已经忘完了，随缘<span class="github-emoji"><span>🙏</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f64f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>。如果哪天心血来潮的话再上线吧。</p><p>  话不多说，开干！</p><hr><p>——2021.4.1更新：已经在github上找到V2.0版本的代码了，一下文章是V2.0的文档。代码版本管理真的太重要了，之前的git操作都忘了差不多了，看来得重新再看看git原理了<span class="github-emoji"><span>✊</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/270a.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，顺便吐槽一下github打开真的太慢了，每次打开都好久好久都毛火完了，是不是该考虑转gitee了，有没有用过gitee的伙伴分享一下体验<span class="github-emoji"><span>🙏</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f64f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>🙏</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f64f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><h2 id="使用前的准备工作"><a href="#使用前的准备工作" class="headerlink" title="使用前的准备工作"></a>使用前的准备工作</h2><ol><li>Java开发环境，我们老师推荐我们用的是NetBeans，当然其他的也可以</li><li>一个存放了班级所有名字的.txt文件，注意格式每一行放一个人名</li><li>如果使用重命名功能，千万千万记得备份一份，万一重命名出现了BUG名字就乱套了</li><li>重命名功能可能不太稳定注意备份测试后使用</li></ol><h2 id="代码原理"><a href="#代码原理" class="headerlink" title="代码原理"></a>代码原理</h2><p>  一共两个类：</p><ol><li>Check类：是主类，包含核心查找方法以及人名的读取</li><li>FileNames类：主要包含关于文件操作的属性和方法</li></ol><h4 id="核心查找方法的原理："><a href="#核心查找方法的原理：" class="headerlink" title="核心查找方法的原理："></a>核心查找方法的原理：</h4><p>  第一步：创建全体名单数组（allName[]）</p><p>  用一个.txt文件按行存放每个同学的名字（可以从班级名字表中复制），再按行读取每个名字存到一个字符串数组（allName[]）里，这样就能确保每个名字独占一个数组空间。</p><p>  第二步：创建包含所有文件名的字符串型变量（txt）</p><p>  把下载的同学们的作业文件名也分别存到一个字符串型数组（name[]）里，再把每个文件名取出来集中放到一个字符串变量（txt）中。</p><p>  第三步：在txt中查找allName中的每一个元素</p><p>  使用java String 类中的contain方法即可实现。</p><h4 id="重命名方法原理："><a href="#重命名方法原理：" class="headerlink" title="重命名方法原理："></a>重命名方法原理：</h4><p>等待更新……</p><h2 id="源代码展示"><a href="#源代码展示" class="headerlink" title="源代码展示"></a>源代码展示</h2><p>Check类：（又重新添加了很多注释，应该不难看懂）</p><pre><code class="line-numbers language-java">package check;import java.io.File;import java.io.FileReader;import java.io.IOException;import java.io.LineNumberReader;/** * * @author Yuukyou *///check类public class Check {    String[] allName= new String[50];                                     //数组allNme用于存放完整的班级名单，默认长度为50，可根据具体人数修改    String txt = "";                                                                 //初始化txt变量            /***该方法用于全体人名的读取和写入***/   public  void printByFileReader(String filePath) throws IOException{        File file = new File("E:\\全体名单.txt");                                //打开存放有全体名单的txt文本文件，每一行存放一个人名        FileReader fileReader = new FileReader(file);        LineNumberReader reader = new LineNumberReader(fileReader);  //创建reader对象用于读取每一行的人名        String txt = "";            for(int lines=1;lines&lt;=35;lines++){                              //lines：行数，即读取人名数量，根据具体人数改变        txt = reader.readLine();                                           //txt记录每一次读取到的人名        allName[lines]=txt;                                                 //将每次txt中的人名存放到allName数组       // System.out.println("第"+lines+"行的内容是"+allName[lines]);     //此行用于测试是否存放成功   }        reader.close();        fileReader.close();}      /***check方法用于检测没交作业的同学***/  public void check(String[] all,String txt){                 //txt存放所有文件名            for(int i=1;i&lt;=35;i++){          boolean status =txt.contains(all[i]);                                //每次取全体名单中的一个元素，在txt中查找          if(!status) {              System.out.println(all[i]+"未交作业");}                        //若不存在则输出未交作业名单          }            }       public static void main(String[] args) throws IOException  {        // TODO code application logic here        FileNames Newname = new FileNames();        Newname.FileName("E:\\电商1903作业\\电商1903java实验报告\\实验一");        Check Allname  = new Check();        Allname.printByFileReader("E:\\全体名单.txt");        Allname.check(Allname.allName,Newname.FileName("E:\\电商1903作业\\电商1903java实验报告\\实验一"));          }    }</code></pre><p>FileNames类：（一些被注释掉的代码块是当时写代码时候的其他版本，没注释的是慢慢调式过来能用的版本，大家也可以自己把注释的代码块删了）</p><pre><code class="line-numbers language-java">package check;import java.io.File;import java.io.IOException;/** * * @author Yuukyou */public class FileNames {        static String partaddress = "E:\\电商1903作业\\电商1903java实验报告\\实验二";    static String alladdress = "E:\\全体名单.txt";    static String partName = "";  //调用txt前先使用FileName方法    public FileNames() {    }         public static String FileName(String filePath){        File file =new File(filePath);                        //传入        String[] name = file.list();                           //String[] list() : 返回一个字符串数组，这些字符串指定file路径下的所有文件和目录  ==》列出文件名        String txt="";        for(int i=1;i&lt;name.length;i++){                 //将所有文件名从数组name中取出，放到txt变量中            txt+=name[i];        }      //   测试 System.out.println(txt);        return txt;}           public static String GetFileName(String filePath) {        File file = new File(filePath);        String[] name = file.list();        //String txt="";        for (int i = 0; i &lt; name.length; i++) {            partName += name[i];        }           //System.out.println(partName);        return partName;    }                 public static void Rename(String filePath) throws IOException {        File file = new File(filePath);        String[] filename = new String[50];       // file.renameTo(new File(filePath));        //读取文件夹下的文件，存进一个文件数组        File[] listfile = file.listFiles();              //读取每个文件名称，找下标对应                       String[] name = file.list();       // for(int l=0;l&lt;name.length;l++){       // System.out.println(name[l]);}        int k= 0;        for (k=0; k &lt; name.length; k++) {            filename[k] += name[k];         System.out.println("第"+k+"个文件名"+filename[k]);        }              //  File file = new File(partaddress);     /* FileReader fileReader = new FileReader(file);        LineNumberReader reader = new LineNumberReader(fileReader);        String txt = "";    for(int lines=0;lines&lt;=35;lines++){        txt = reader.readLine();        filename[lines]=txt;        System.out.println("第"+lines+"行的内容是"+filename[lines]);    }*/        //遍历重命名         Check check = new Check();         check.printByFileReader(alladdress);        Check Allname = new Check();        Allname.printByFileReader(alladdress);        //System.out.println();        FileNames partname = new FileNames();        partname.GetFileName(partaddress);        //System.out.println(partname.FileName(partaddress));        for (int i = 1; i &lt; listfile.length; i++) {            if (listfile[i].isFile()) {               // boolean status = false;                for (int j = 0; j &lt;= Allname.allName.length; j++) {                   boolean  status = filename[i].contains(Allname.allName[j]);    // ！BUG：第0个文件名nulldesktop.ini                    // System.out.println(Allname.allName[j]);                    if (status) {                        String newname = "电商1903-java实验二-" + Allname.allName[j] + ".doc";                        File refile = new File(filePath + File.separator + newname);                        listfile[i].renameTo(refile);                        System.out.println("重命名成功"+newname);                        break;                    }                }                /*  if(check.check(Allname.allName,partname.FileName(partaddress)))                 {                 for(int j=1;j&lt;=35;j++){                 //文件定位                 String newname="电商1903-Java实验二"+Check.allName[j]+".doc";                 File refile=new File(filePath+File.separator+newname);                 listfile[i].renameTo(refile);                 }                 }*/                System.out.println(listfile[i] + "重命名成功！");            }        }    }}</code></pre><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>如果你觉得这篇文章对你还有点用的话，欢迎打赏博主一块小饼干(o^^o)没有小饼干留下你的小脚印也行(^з^)，如果有更好的算法或者功能方面的建议也欢迎评论区或者留言区交流哦(^_^)v</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 学委三件套 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Json格式和Ajax的学习</title>
      <link href="2021/03/22/JsonAndAjax/"/>
      <url>2021/03/22/JsonAndAjax/</url>
      
        <content type="html"><![CDATA[<blockquote><p>JSON格式</p></blockquote><p>基本语法：</p><ul><li><p>对象表示为键值对，数据用逗号分隔</p></li><li><p>花括号保存数组对象</p></li><li><p>方括号保存数组</p><p><strong>JSON 键值对</strong>是用来保存 JavaScript 对象的一种方式，和 JavaScript 对象的写法也大同小异，键/值对组合中的键名写在前面并用双引号 “” 包裹，使用冒号 : 分隔，然后紧接着值：</p><pre><code class="line-numbers language-json">{"name": "QinJiang"}{"age": "3"}{"sex": "男"}</code></pre></li></ul><p><strong>JSON与JavaScript的关系：</strong></p><p>   JSON 是 JavaScript 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串。</p><p><strong>JSON 和 JavaScript 对象互转</strong></p><p>要实现从JSON字符串转换为JavaScript 对象，使用 JSON.parse() 方法：</p><pre><code>var obj = JSON.parse('{"a": "Hello", "b": "World"}');//结果是 {a: 'Hello', b: 'World'}</code></pre><p>要实现从JavaScript 对象转换为JSON字符串，使用 JSON.stringify() 方法：</p><pre><code>var json = JSON.stringify({a: 'Hello', b: 'World'});//结果是 '{"a": "Hello", "b": "World"}'</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Json </tag>
            
            <tag> Ajax </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于IAR&amp;STM32调试过程问题记录</title>
      <link href="2021/03/19/IAR/"/>
      <url>2021/03/19/IAR/</url>
      
        <content type="html"><![CDATA[<h2 id="IAR烧录时提示没有设备连接"><a href="#IAR烧录时提示没有设备连接" class="headerlink" title="IAR烧录时提示没有设备连接"></a>IAR烧录时提示没有设备连接</h2><p>当连接好电脑鼠并且检查线路没有问题并且驱动程序正常运行时，点击调试，出现“STM32 no emulator connected via USB…..”提示。</p><p>在网上查找了很多资料基本上4个问题：</p><pre><code class="line-numbers language-供电">1、板子一定要供电！2、ST-LINK是否接触不良确保ST-LINK跟板子连接完好3、按住reset点击download硬件和接线都没问题情况下，这时候可能是SWD的引脚被占用了，或者被禁用了。这时候ST-LINK自然无法通过SWD跟板子通信，所以才会提示No Target connected。所以，这时候按住reset，再点击download，再松开reset。原理就是在程序运行到SWD引脚占用之前，把新的程序烧录进去，抢个时间差。但是这招不是每次都管用，有概率性失败。但是不要紧，我们还有第四招4、boot0 接高电平download正常程序后，再接回低电平，即可烧录————————————————版权声明：本文为CSDN博主「小康师兄」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/kangweijian/article/details/107564868```</code></pre><p>但是这4个方法我都试过一遍<strong>还是没有解决。</strong></p><p>最后看到一篇文章受到启发：<a href="https://blog.csdn.net/c1063891514/article/details/81545601">https://blog.csdn.net/c1063891514/article/details/81545601</a></p><p>解决方法与链接文章没太大关系</p><p>是这篇文章最后两张图引起了我的注意，便想是不是连接设备接口没设置对，设置好接口果然设备连接成功了！！！具体步骤如下：</p><p>1、右键点击demo-Debug，选择Opotions</p><p><img src="/2021/03/19/IAR/1.jpg" alt="1"></p><p>2、选择Debugger设置Driver为图示<img src="/2021/03/19/IAR/2.jpg" alt="2"></p><p>3、点击Download设置，将图示√上即可<img src="/2021/03/19/IAR/3.jpg" alt="image-3"></p><p>点击OK后IAR即可正常识别设备，记得<em><strong>编译</strong></em>后，再烧录！！</p><p>电脑鼠连接不上电脑这个问题真的困扰了我们队伍好久！找老师又找学长又找老师又找学长,头发都快给我薅没了！体会还蛮深刻的，网络真的是个好东西，不懂的多问问别人，虽然别人不一定能帮你解决问题，但是会给你启发！<br><br>最后发个喜报！我买的域名终于过审了！！！！普天同庆！！！<br></p><p>之前因为重重问题来来回回和腾讯打了5、6个电话，修改又驳回4次信息，最后腾讯还是冒着风险帮我把备案提交给管局的，真的差点我都不想要这个域名了，心底一块石头终于落地了。<br><br></p><p>如果你觉得这篇文章解决了你的问题或者说对你还有用的话，欢迎打赏博主一块小饼干⸜₍๑•⌔•๑ ₎⸝。</p><p>如果有什么问题可以在评论区底下留言哦，欢迎交流<em>⸜( •ᴗ• )⸝</em><br><br><br><br></p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IAR </tag>
            
            <tag> STM32 </tag>
            
            <tag> 电脑鼠 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown&amp;hexo&amp;Git常用操作</title>
      <link href="2021/03/05/GitAndHexo/"/>
      <url>2021/03/05/GitAndHexo/</url>
      
        <content type="html"><![CDATA[<h1 id="常用Hexo-amp-Git操作"><a href="#常用Hexo-amp-Git操作" class="headerlink" title="常用Hexo &amp; Git操作"></a>常用Hexo &amp; Git操作</h1><h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><h3 id="使用hexo新建文章"><a href="#使用hexo新建文章" class="headerlink" title="使用hexo新建文章"></a>使用hexo新建文章</h3><br><ul><li>新建文章命令 ：<code>$ hexo new &lt;title&gt;</code></li></ul><p>输入上行命令之后在post文件夹出现两个文件，title文件夹用于存放图片资源；md文件则用于书写文章。</p><ul><li>在md文件头部信息补充分类信息：<code>categories:</code>(注意空格)</li></ul><p><strong>md常用语法：</strong></p><ol><li><p>标题：<code>#H1    一级标签...</code></p></li><li><p>无序列表：<code>+ 123  /- 123  /* 123</code></p></li><li><p>有序列表：<code>1. ABC  /2. ABC  /3.ABC</code></p></li><li><p>引用说明区块：<code>&gt; 引用内容</code></p></li><li><p>代码块：<code>1.少量代码，单行使用，直接用`包起来   2.大量代码需要多行使用，用三个`包裹起来</code></p></li><li><p>在文章中插入图片：<code>![1](./title/1.jpg)</code></p></li><li><p>链接：<code>链接的文字放在[]中，链接地址放在随后的()中，链接也可以带title属性，链接地址后面空一格，然后用引号引起来:[简书](https://www.jianshu.com "创作你的创作")</code></p></li><li><p>分割线：</p><pre><code class="line-numbers language-markdown">---- - -------**** * *******____ _ _______</code></pre></li><li><p>首行缩进</p><pre><code class="line-numbers language-markdown">&amp;emsp; or &amp;#8195;  表示一个全角的空格&amp;emsp;&amp;emsp; 两个全角的空格（用的比较多）</code></pre></li></ol><br><h3 id="hexo常用命令"><a href="#hexo常用命令" class="headerlink" title="hexo常用命令"></a>hexo常用命令</h3><p><code> $ hexo clean</code> </p><p>清除缓存和已生成静态文件<br></p><br><p><code>$ hexo g</code></p><p>生成静态文件<br></p><br><p><code> $ hexo s</code></p><p>启动服务器<br></p><br><p><code>$ hexo d</code></p><p>部署网站<br></p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><h3 id="使用git管理代码版本"><a href="#使用git管理代码版本" class="headerlink" title="使用git管理代码版本"></a>使用git管理代码版本</h3><h3 id="git常用命令"><a href="#git常用命令" class="headerlink" title="git常用命令"></a>git常用命令</h3><p><code>$ git init</code></p><p>在当前目录新建一个git代码库</p><br><p><code>$ git status</code></p><p>查看跟踪状态</p><br><p><code>$ git add flies（.）</code></p><p>把本地文件添加到暂存区（.  添加当前目录所有文件到暂存区）</p><br><p><code>$ git commit </code></p><p>添加到本地仓库</p><br><p><code>$ git push</code></p><p>添加到远程仓库</p><br><p><code>$ git pull</code></p><p>从远程拉到本地仓库</p><br><p><code>$ git branch</code></p><p>查看分支</p><br><p><code>$ git branch name</code></p><p>新建name分支</p><br><p><code>$ git checkout -b [branch name]</code></p><p>新建一个分支，并切换到该分支</p><br><p><code> $git checkout -d [branch name]</code> </p><p>删除分支</p><br>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git&amp;hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进来随便聊聊叭</title>
      <link href="2021/03/05/MyFristBlog/"/>
      <url>2021/03/05/MyFristBlog/</url>
      
        <content type="html"><![CDATA[<p>非常欢迎你来到我的博客，这是我的第一篇文章，我也不懂要写什么，就随便唠一下吧。</p><h4 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h4><p>​        我先介绍一下我自己吧，00后的大表哥，游手好闲无业网民，最喜欢吃大柳州的螺蛳粉，长板板混（蹲个大佬一起磕招），喜欢摄影，代码小菜鸡，秃头预备选手，只喜欢写一些实用代码（有好的点子一起交流）。</p><h4 id="建站故事"><a href="#建站故事" class="headerlink" title="建站故事"></a>建站故事</h4><p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本来说20年的寒假要搭建这个个人博客的，当时非常幸运地在南京参与电影《非常替身》制作，担任实习剪辑助理一职，由于工作太“闲”了，我就开始对未来思考，于是乎就有了搭建这个博客的想法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一开始我是想搭一个我们学校滑板论坛的，但是考虑到实用性和推广难度就放弃了。然后在寒假断断续续的看了一点vue，学了几天myslq，flag就开始立起来了，说是这个寒假完成，然后回到家就开始玩了。。。剩最后10天开学了，我才抓紧起来，建站过程挺曲折的，一个方面是因为我的拖延，另一个方面源自于自我的不肯定，东一下学js，西一下学vue，学了一下mysql，又想下学期就有数据库的课，现在会不会太着急了，想学Spring又怕跳的太快，只知道wordpress又懒得学php……就这样一直和自己的想法对抗中，好像我就是纠结体本身，终于最后被逼到什么都来不及学，直接建站！事实证明在建站过程中学习，比先学再做来得更高效直接，回顾以前自学python、html、css的时候也是等不及慢慢啃知识点，直接实战了。本在在Gitpage上面部署过一次博客（已经能用的那种），后来又想买个服务器和域名玩一下，就又重新整了一套。</p><p>就好像在博客首页的“送你一颗子弹”一样</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后选择了hexo这个框架也是蛮幸运的，他刚好是基于前端三剑客的框架，不用再学php了（投降）。但是它的缺点是没有直接管理网站文章的后台，随便吧。</p><blockquote><p>就这样这个博客就稀里糊涂的建了起来。</p></blockquote><h4 id="立一些flag"><a href="#立一些flag" class="headerlink" title="立一些flag"></a>立一些flag</h4><blockquote><p>虽然说这个博客是搬别人的框架，但是二次开发我也费了蛮多心血的，改动还是蛮多的，修饰博客的界面就像装潢自己小窝一样。</p></blockquote><p>Flag1：以后在这个博客上面主要发一些学习笔记吧，也会发一些书摘，随笔，可能会上线说说板块</p><p>Flag2：等我学会调用API了会上线识别qq账号留言评论功能，大家就能有头像啦！</p><p>Flag3：“什么时候心血来潮”上线滑板、相册、vlog板块</p><p>Flag4：每周更新两篇文章（！！！一定要做到！！！）</p><p>Flag5：给自己的网站设计一个logo并且用PS或者AI做出来（应该不难）</p><p>Flag6：把写过的代码都上传到github上</p><h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这么辛苦码字就是为了见你一面，留下你的脚印吧我的朋友,非常欢迎评论区或者留言互动！期待你的留言！</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flag </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
