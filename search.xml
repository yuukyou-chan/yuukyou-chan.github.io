<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>VUE头条项目笔记</title>
      <link href="2022/04/01/VUEproject/"/>
      <url>2022/04/01/VUEproject/</url>
      
        <content type="html"><![CDATA[<h2 id="删除文章失败？（JS大数字问题）"><a href="#删除文章失败？（JS大数字问题）" class="headerlink" title="删除文章失败？（JS大数字问题）"></a>删除文章失败？（JS大数字问题）</h2><p>JavaScript 能够准确表示的整数范围在<code>-2^53</code>到<code>2^53</code>之间（不含两个端点），超过这个范围，无法精确表示这个值，这使得 JavaScript 不适合进行科学和金融方面的精确计算。</p><p>关于一些json方法：</p><p><strong>JSON 的常规用途是同 web 服务器进行数据传输。</strong></p><p><strong>在从 web 服务器接收数据时，数据永远是字符串。</strong></p><p><strong>通过 JSON.parse() 解析数据，这些数据会成为 JavaScript 对象。</strong></p><pre><code class="line-numbers language-js">/*将服务器端接受的数据转换为js对象*/JSON.parse()  </code></pre><p><strong>在向 web 服务器发送数据时，数据必须是字符串。</strong></p><p><strong>通过 JSON.stringify() 把 JavaScript 对象转换为字符串。</strong></p><pre><code>/*将js对象转换为字符串发送给服务器*/JSON.stringify()  </code></pre><p>json-bigint 会把超出 JS 安全整数范围的数字转为一个 BigNumber 类型的对象，对象数据是它内部的一个算法处理之后的，我们要做的就是在使用的时候转为字符串来使用。 </p><p>axios 为了方便我们使用数据，它会在内部使用 <code>JSON.parse()</code> 把后端返回的数据转为 JavaScript 对象，</p><pre><code>解决思路：Axios 会在内部使用 JSON.parse 把后端返回的数据转为 JavaScript 数据对象。所以解决思路就是：不要让 axios 使用 JSON.parse 来转换这个数据，而是使用 json-biginit 来做转换处理。axios 提供了一个 API：transformResponse，在这里对返回的原数据进行操作</code></pre>]]></content>
      
      
      <categories>
          
          <category> VUE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VUE项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScrip</title>
      <link href="2022/01/01/JavaScrip/"/>
      <url>2022/01/01/JavaScrip/</url>
      
        <content type="html"><![CDATA[<h3 id="一、super-关键字"><a href="#一、super-关键字" class="headerlink" title="一、super 关键字"></a>一、super 关键字</h3><blockquote><h3 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h3></blockquote><ol><li>super调用父类构造函数</li></ol><p>super关键字可以让子类的构造函数调用父类的构造函数，变量指向上一级</p><pre><code class="line-numbers language-js">    class Father {        constructor(x, y) {            this.x = x;            this.y = y;        }        sum() {            console.log(this.x + this.y);        }    }    class Son extends Father {        constructor(x, y) {            super(x, y); //调用了父类中的构造函数         // this.x = x;         // this.y = y;        }    }        var son = new Son(1, 2);        var son1 = new Son(11, 22);        son.sum();        son1.sum();</code></pre><p>在子类构造函数中如果直接写 this.x  = x ，那么实例化对象时，调用的是子类的构造函数，父类没有得到x、y。 son 想要调用 father 的sum（）方法，sum方法中的x，y都是父类的，所以sum没有办法相加。</p><p> &nbsp; &nbsp;sum中的this.x必须是从sum中构造函数获取的</p><p>    如果构造函数中有super 那么super必须放在最前面</p><ol start="2"><li>super调用父类普通方法</li></ol><pre><code class="line-numbers language-js">    // super 关键字调用父类普通函数    class Father {        say() {            return '我是爸爸';        }    }    class Son extends Father {        say() {            // console.log('我是儿子');            console.log(super.say() + '的儿子');            // super.say() 就是调用父类中的普通函数 say()        }    }    var son = new Son();    son.say();    // 继承中的属性或者方法查找原则: 就近原则    // 1. 继承中,如果实例化子类输出一个方法,先看子类有没有这个方法,如果有就先执行子类的    // 2. 继承中,如果子类里面没有,就去查找父类有没有这个方法,如果有,就执行父类的这个方法(就近原则)&lt;/script&gt;</code></pre><p>在子类中 super.say() 可以直接调用父类的say方法；继承中的属性或者方法查找原则: <strong>就近原则</strong></p><h3 id="二、this关键字"><a href="#二、this关键字" class="headerlink" title="二、this关键字"></a>二、this关键字</h3><blockquote><h3 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h3></blockquote><ol><li>在 ES6 中类没有变量提升，所以必须先定义类，才能通过类实例化对象.</li><li>类里面的共有属性和方法一定要加this使用.</li><li>类里面的this指向问题. </li><li>constructor 里面的this指向实例对象, 方法里面的this 指向这个方法的调用</li></ol><h3 id="三、构造函数和原型"><a href="#三、构造函数和原型" class="headerlink" title="三、构造函数和原型"></a>三、构造函数和原型</h3><blockquote><h3 id="构造函数和原型"><a href="#构造函数和原型" class="headerlink" title="构造函数和原型"></a>构造函数和原型</h3></blockquote><h4 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1. 构造函数"></a>1. 构造函数</h4><p>在 ES6之前 ，对象不是基于类创建的，而是用一种称为构建函数的特殊函数来定义对象和它们的特征。</p><p>创建对象可以通过以下三种方式：</p><ol><li><p>对象字面量</p></li><li><p>new Object()</p></li><li><p>自定义构造函数</p></li></ol><p>构造函数存在的问题：（内存浪费）</p><p>每新建一个构造函数就会开辟一个新的内存空间，同一个函数也会单独开辟新的空间，造成内存浪费。</p><p><img src="/2022/01/01/JavaScrip/Users\19681\AppData\Roaming\Typora\typora-user-images\image-20220104091350513.png" alt="image-20220104091350513"></p><h4 id="2-构造函数原型prototype"><a href="#2-构造函数原型prototype" class="headerlink" title="2.构造函数原型prototype"></a>2.构造函数原型prototype</h4><p>JavaScript 规定，<strong>每一个构造函数都有一个 prototype 属性</strong>，指向另一个对象。注意这个 prototype 就<strong>是一个对象</strong>，这个对象的所有属性和方法，都会被构造函数所拥有。<br><strong>我们可以把那些不变的方法，直接定义在 prototype 对象上，这样所有对象的实例就可以共享这些方法。</strong></p><p>问答？</p><ol><li>原型是什么 ？<br>一个<strong>对象</strong>，我们也称为 prototype 为原型对象。</li><li>原型的作用是什么 ？<br>共享方法。</li></ol><p>一般情况下，将公共属性定义到构造函数里，公共方法定义到原型对象上</p><h4 id="3-对象原型-proto"><a href="#3-对象原型-proto" class="headerlink" title="3. 对象原型__proto__"></a>3. 对象原型__proto__</h4><pre><code class="line-numbers language-js">    function Star(uname, age) {        this.uname = uname;        this.age = age;    }    Star.prototype.sing = function() {        console.log('我会唱歌');    }    var ldh = new Star('刘德华', 18);    var zxy = new Star('张学友', 19);    ldh.sing();    console.log(ldh); // 对象身上系统自己添加一个 __proto__ 指向我们构造函数的原型对象 prototype    console.log(ldh.__proto__ === Star.prototype);    // 方法的查找规则: 首先先看ldh 对象身上是否有 sing 方法,如果有就执行这个对象上的sing    // 如果么有sing 这个方法,因为有__proto__ 的存在,就去构造函数原型对象prototype身上去查找sing这个方法</code></pre><p>方法的<strong>查找规则</strong>:</p><ol><li> 首先先看ldh 对象身上是否有 sing 方法,如果有就执行这个对象上的sing</li><li>如果么有sing 这个方法,因为有__proto__ 的存在,就去构造函数原型对象prototype身上去查找sing这个方法</li></ol><p>对象都会有一个属性 <strong>proto</strong> 指向构造函数的 prototype 原型对象，之所以我们对象可以使用构造函数 prototype 原型对象的属性和方法，就是因为对象有 <strong>proto</strong> 原型的存在。</p><ul><li>__proto__对象原型和原型对象 prototype 是等价的</li><li>__proto__对象原型的意义就在于为对象的查找机制提供一个方向，或者说一条路线，但是它是一个非标准属性，<em>因此实际开发中，不可以使用这个属性，它只是内部指向原型对象 prototype</em></li></ul><h4 id="4-constructor构造函数"><a href="#4-constructor构造函数" class="headerlink" title="4. constructor构造函数"></a>4. constructor构造函数</h4><pre><code class="line-numbers language-js">    function Star(uname, age) {        this.uname = uname;        this.age = age;    }    // 很多情况下,我们需要手动的利用constructor 这个属性指回 原来的构造函数    // Star.prototype.sing = function() {    //     console.log('我会唱歌');    // };    // Star.prototype.movie = function() {    //     console.log('我会演电影');    // }    Star.prototype = {        // 如果我们修改了原来的原型对象,给原型对象赋值的是一个对象,则必须手动的利用constructor指回原来的构造函数        constructor: Star,        sing: function() {            console.log('我会唱歌');        },        movie: function() {            console.log('我会演电影');        }    }    var ldh = new Star('刘德华', 18);    var zxy = new Star('张学友', 19);</code></pre><p>很多情况( 公共函数很多时 )下，我们需要重写原型对象prototype，这时候需要手动的利用constructor 这个属性指回 原来的构造函数，例如上段代码的14行。</p><h4 id="5-构造函数、实例、原型对象三者之间的关系"><a href="#5-构造函数、实例、原型对象三者之间的关系" class="headerlink" title="5. 构造函数、实例、原型对象三者之间的关系"></a>5. 构造函数、实例、原型对象三者之间的关系</h4><p><img src="/2022/01/01/JavaScrip/Users\19681\AppData\Roaming\Typora\typora-user-images\image-20220104101146044.png" alt="image-20220104101146044"></p><p>构造函数是原型对象的父级，原型对象通过构造函数创建出来。</p><p>实例对象通过原型对象指向（找到）构造函数<code>ldh.__proto__.constructor</code></p><h4 id="6-原型链（面试很容易问到）"><a href="#6-原型链（面试很容易问到）" class="headerlink" title="6. 原型链（面试很容易问到）"></a>6. 原型链（<strong>面试很容易问到</strong>）</h4><p><img src="/2022/01/01/JavaScrip/Users\19681\AppData\Roaming\Typora\typora-user-images\image-20220104105434631.png" alt="image-20220104105434631"></p><p>原型对象prototype也是一个对象，它也有也有对象原型__ proto __，它指向Object原型对象prototype，Object原型对象的原型对象指向空。即Object就是所有类的父类。</p><p>面试可能让你画原型链。</p><p>JS的成员查找规则：</p><ol><li>当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性。</li><li>如果没有就查找它的原型（也就是 __proto__指向的 prototype 原型对象）。</li><li>如果还没有就查找原型对象的原型（Object的原型对象）。</li><li>依此类推一直找到 Object 为止（null）。</li><li>__proto__对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线。</li></ol><p>简而言之，顺着原型链往上找（<strong>就近原则</strong>）。</p><p><strong>原型对象this指向（面试常考问题）</strong>：不管是构造函数里面的this还是原型对象里面的this，都指向实例对象。</p><h3 id="四、继承"><a href="#四、继承" class="headerlink" title="四、继承"></a>四、继承</h3><p>ES6之前并没有给我们提供 extends 继承。我们可以通过<strong>构造函数+原型对象</strong>模拟实现继承，被称为组合继承。</p><h4 id="1-1借用构造函数继承父类属性"><a href="#1-1借用构造函数继承父类属性" class="headerlink" title="1.1借用构造函数继承父类属性"></a>1.1借用构造函数继承父类<strong>属性</strong></h4><p>核心原理： 通过 call() 把父类型的 this 指向子类型的 this ，这样就可以实现子类型继承父类型的属性。   </p><pre><code class="line-numbers language-js">    // 父类    function Person(name, age, sex) {      this.name = name;      this.age = age;      this.sex = sex;    }    // 子类    function Student(name, age, sex, score) {      Person.call(this, name, age, sex);  // 此时父类的 this 指向子类的 this，同时调用这个函数      this.score = score;    }    var s1 = new Student('zs', 18, '男', 100);    console.dir(s1); </code></pre><h4 id="1-2借用原型对象继承方法"><a href="#1-2借用原型对象继承方法" class="headerlink" title="1.2借用原型对象继承方法"></a>1.2借用原型对象继承方法</h4><p>没太听懂。保留：P14-P15  P5面试重点</p><h4 id="2-类的本质"><a href="#2-类的本质" class="headerlink" title="2.类的本质"></a>2.类的本质</h4><ol><li>class本质还是function.</li><li> 类的所有方法都定义在类的prototype属性上</li><li> 类创建的实例,里面也有__proto__ 指向类的prototype原型对象</li><li>所以ES6的类它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。</li><li>所以ES6的类其实就是语法糖.</li></ol><p>一些个构造函数的特征（类和构造函数特征一样）：</p><pre><code>    // (1) 构造函数有原型对象prototype     // (2) 构造函数原型对象prototype 里面有constructor 指向构造函数本身    // (3) 构造函数可以通过原型对象添加方法    // (4) 构造函数创建的实例对象有__proto__ 原型指向 构造函数的原型对象</code></pre><h3 id="五、ES5中新增的方法（数组、字符串、对象方法）"><a href="#五、ES5中新增的方法（数组、字符串、对象方法）" class="headerlink" title="五、ES5中新增的方法（数组、字符串、对象方法）"></a>五、ES5中新增的方法（数组、字符串、对象方法）</h3><ol><li>数组：</li></ol><p>(1). forEach()遍历<strong>整个</strong>数组</p><p><code>array.forEach(function(currentValue, index, arr)</code></p><p>currentValue：数组当前项的值<br>index：数组当前项的索引<br>arr：数组对象本身</p><p>(2).filter()筛选数组</p><p><code>array.filter(function(currentValue, index, arr))</code></p><p> filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的<strong>所有</strong>元素,主要用于筛选数组<br>注意它直接返回一个新数组<br> currentValue: 数组当前项的值<br> index：数组当前项的索引<br> arr：数组对象本身</p><p>(3).some()判断数组是否存在某个元素</p><p><code>array.some(function(currentValue, index, arr)</code></p><p> some() 方法用于检测数组中的元素是否满足指定条件.   通俗点 查找数组中是否有满足条件的元素<br>注意它返回值是布尔值, 如果查找到这个元素, 就返回true ,  如果查找不到就返回false.<br><strong>如果找到第一个满足条件的元素,则终止循环. 不在继续查找.</strong><br> currentValue: 数组当前项的值<br> index：数组当前项的索引<br> arr：数组对象本身</p><ol start="2"><li>字符串</li></ol><p>(1).str.trim()去除字符串两端的空格，返回的是一个新的字符串</p><ol start="2"><li>对象</li></ol><p>(1).Object.keys() 用于获取对象自身所有的属性</p><p>效果类似 for…in<br>返回一个由属性名组成的数组</p><p>(2).Object.defineProperty() 定义对象中新属性或修改原有的属性。(<strong>vue2用来实现响应式</strong>)</p><p>Object.defineProperty(obj, prop, descriptor)</p><p>obj：必需。目标对象<br>prop：必需。需定义或修改的属性的名字<br>descriptor：必需。目标属性所拥有的特性</p><p>Object.defineProperty()   第三个参数 descriptor 说明： 以对象形式 { } 书写</p><p> value: 设置属性的值  默认为undefined<br> writable: 值是否可以重写。true | false  默认为false<br> enumerable: 目标属性是否可以被枚举。true | false 默认为 false<br> configurable: 目标属性是否可以被删除或是否可以再次修改特性 true | false  默认为false</p><h3 id="六、函数进阶"><a href="#六、函数进阶" class="headerlink" title="六、函数进阶"></a>六、函数进阶</h3><blockquote><h3 id="函数进阶"><a href="#函数进阶" class="headerlink" title="函数进阶"></a>函数进阶</h3></blockquote><h4 id="1-函数的定义和调用"><a href="#1-函数的定义和调用" class="headerlink" title="1.函数的定义和调用"></a>1.函数的定义和调用</h4><ol><li>函数声明方式 function 关键字 (命名函数)</li><li>函数表达式 (匿名函数)</li><li>new Function() <code>var fn = new Function('参数1','参数2'..., '函数体')</code></li></ol><p>Function 里面参数都必须是字符串格式<br>第三种方式执行效率低，也不方便书写，因此较少使用<br>所有函数都是 Function 的实例(对象)<br>函数也属于对象</p><pre><code class="line-numbers language-js">    // 1. 自定义函数(命名函数)     function fn() {};    // 2. 函数表达式 (匿名函数)    var fun = function() {};    // 3. 利用 new Function('参数1','参数2', '函数体');    var f = new Function('a', 'b', 'console.log(a + b)');</code></pre><h4 id="2-函数的调用方式"><a href="#2-函数的调用方式" class="headerlink" title="2.函数的调用方式"></a>2.函数的调用方式</h4><ol><li>普通函数</li><li>对象的方法</li><li>构造函数</li><li>绑定事件函数</li><li>定时器函数</li><li>立即执行函数</li></ol><pre><code class="line-numbers language-js">    // 1. 普通函数    function fn() {        console.log('人生的巅峰');    }    // fn();   fn.call()        // 2. 对象的方法    var o = {        sayHi: function() {            console.log('人生的巅峰');        }    }    o.sayHi();        // 3. 构造函数    function Star() {};  // 构造函数首字母习惯大写，构造函数本质和普通函数一样，但是构函需要用new调用。    new Star();       // 4. 绑定事件函数    btn.onclick = function() {};   // 点击了按钮就可以调用这个函数    // 5. 定时器函数    setInterval(function() {}, 1000);  这个函数是定时器自动1秒钟调用一次    // 6. 立即执行函数    (function() {        console.log('人生的巅峰');    })();    // 立即执行函数是自动调用</code></pre><h4 id="3-this指向问题"><a href="#3-this指向问题" class="headerlink" title="3.this指向问题"></a>3.this指向问题</h4><table><thead><tr><th>调用方式</th><th>this指向</th></tr></thead><tbody><tr><td>普通函数调用</td><td>Windows</td></tr><tr><td>构造函数调用</td><td>实例对象    原型对象里面的方法也指向实例对象</td></tr><tr><td>对象方法调用</td><td>该方法所属对象</td></tr><tr><td>事件绑定方法</td><td>绑定事件对象</td></tr><tr><td>定时器函数</td><td>Windows</td></tr><tr><td>立即执行函数</td><td>Windows</td></tr></tbody></table><p>3.1改变函数内部this指向：</p><ol><li>call()方法：<code>fun.call(thisArg, arg1, arg2, ...) </code></li></ol><ul><li> thisArg：在 fun 函数运行时指定的 this 值</li><li> arg1，arg2：传递的其他参数</li><li> 返回值就是函数的返回值，因为它就是调用函数</li><li> 因此当我们想改变 this 指向，同时想调用这个函数的时候，可以使用 call，比如继承（具体参考7继承）</li></ul><ol start="2"><li><p>apply方法：<code>fun.apply(thisArg, [argsArray])</code></p><ul><li> thisArg：在fun函数运行时指定的 this 值</li><li> argsArray：传递的值，必须包含在数组里面</li><li> 返回值就是函数的返回值，因为它就是调用函数</li><li> 因此 apply 主要跟数组有关系，比如使用 Math.max() 求数组的最大值</li></ul><pre><code class="line-numbers language-js">var arr = [1,2,3,5,4]var max = Math.max.apply(Math,arr); </code></pre><p>apply()与call()都是改变this指向，apply常用于数组应用方法。</p></li><li><p>bind方法：<code>fun.bind(thisArg, arg1, arg2, ...</code></p></li></ol><ul><li> thisArg：在 fun 函数运行时指定的 this 值</li><li> arg1，arg2：传递的其他参数</li><li> 返回由指定的 this 值和初始化参数改造的<strong>原函数拷贝</strong></li><li>因此当我们只是想改变 this 指向，并且不想调用这个函数的时候，可以使用 bind</li></ul><p>4.call、aplly、bind总结</p><p>相同点:<br>都可以改变函数内部的this指向</p><p>区别点:<br>call 和 apply  会调用函数, 并且改变函数内部this指向.<br>call 和 apply 传递的参数不一样, call 传递参数 aru1, aru2..形式  apply 必须数组形式[arg]<br>bind  不会调用函数, 可以改变函数内部this指向.</p><p>call 经常做继承.<br>apply 经常跟数组有关系.  比如借助于数学对象实现数组最大值最小值<br>bind  不调用函数,但是还想改变this指向. 比如改变定时器内部的this指向.</p><h4 id="4-严格模式"><a href="#4-严格模式" class="headerlink" title="4.严格模式"></a>4.严格模式</h4><p>JavaScript 除了提供正常模式外，还提供了严格模式（strict mode）。ES5 的严格模式是采用具有限制性 JavaScript 变体的一种方式，即在严格的条件下运行 JS 代码。<br>严格模式在 IE10 以上版本的浏览器中才会被支持，旧版本浏览器中会被忽略。<br>严格模式对正常的 JavaScript 语义做了一些更改： </p><ol><li>消除了 Javascript 语法的一些不合理、不严谨之处，减少了一些怪异行为。</li><li>消除代码运行的一些不安全之处，保证代码运行的安全。</li><li>提高编译器效率，增加运行速度。</li><li>禁用了在 ECMAScript 的未来版本中可能会定义的一些语法，为未来新版本的 Javascript 做好铺垫。比如一些保留字如：class, enum, export, extends, import, super 不能做变量名</li></ol><h6 id="4-1严格模式中的变化"><a href="#4-1严格模式中的变化" class="headerlink" title="4.1严格模式中的变化"></a>4.1严格模式中的变化</h6><ol><li><p>变量规定</p><ul><li>在正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，变量都必须先用var 命令声明，然后再使用。</li><li>严禁删除已经声明变量。例如，delete x; 语法是错误的。</li></ul></li><li><p> 严格模式下 this 指向问题</p></li></ol><ul><li><ol><li>以前在全局作用域函数中的 this 指向 window 对象。</li></ol></li><li><ol start="2"><li>严格模式下全局作用域中函数中的 this 是 undefined。</li></ol></li><li><ol start="3"><li>以前构造函数时不加 new也可以 调用,当普通函数，this 指向全局对象</li></ol></li><li><ol start="4"><li>严格模式下,如果 构造函数不加new调用, this 指向的是undefined 如果给他赋值则 会报错</li></ol></li><li><ol start="5"><li>new 实例化的构造函数指向创建的对象实例。</li></ol></li><li><ol start="6"><li>定时器 this 还是指向 window 。</li></ol></li><li><ol start="7"><li>事件、对象还是指向调用者。</li></ol></li></ul><h3 id="七、闭包"><a href="#七、闭包" class="headerlink" title="七、闭包"></a>七、闭包</h3><h4 id="1-什么是闭包？"><a href="#1-什么是闭包？" class="headerlink" title="1.什么是闭包？"></a>1.什么是闭包？</h4><p>闭包（closure）指有权访问另一个函数作用域中变量的<strong>函数</strong>。</p><p>闭包是一个函数</p><h4 id="2-闭包的作用"><a href="#2-闭包的作用" class="headerlink" title="2.闭包的作用"></a>2.闭包的作用</h4><p>延伸了变量的作用范围，保存变量防止销毁</p><pre><code class="line-numbers language-js">&lt;script&gt;        // 闭包（closure）指有权访问另一个函数作用域中变量的函数。        // 一个作用域可以访问另外一个函数的局部变量         // 我们fn 外面的作用域可以访问fn 内部的局部变量        // 闭包的主要作用: 延伸了变量的作用范围        function fn() {            var num = 10;        // function fun() {        //     console.log(num);        // }        // return fun;        return function() {            console.log(num);        }    }    var f = fn();    f();    // 类似于    // var f = function() {    //         console.log(num);    //     }    // var f =  function fun() {    //         console.log(num);    //     }&lt;/script&gt;</code></pre><h4 id="3-闭包案例"><a href="#3-闭包案例" class="headerlink" title="3.闭包案例"></a>3.闭包案例</h4><p>经典面试题：利用闭包的方式得到当前 li 的索引</p><pre><code class="line-numbers language-js">// 2. 利用闭包的方式得到当前小li 的索引号        for (var i = 0; i &lt; lis.length; i++) {            // 利用for循环创建了4个立即执行函数            // 立即执行函数也成为小闭包因为立即执行函数里面的任何一个函数都可以使用它的i这变量            (function(i) {                // console.log(i);                lis[i].onclick = function() {                    console.log(i);                }            })(i);</code></pre><h3 id="八、深拷贝和浅拷贝"><a href="#八、深拷贝和浅拷贝" class="headerlink" title="八、深拷贝和浅拷贝"></a>八、深拷贝和浅拷贝</h3><ol><li>浅拷贝只是拷贝一层, 更深层次对象级别的只拷贝引用（拷贝地址）.</li><li>深拷贝拷贝多层, 每一级别的数据都会拷贝（开辟新的内存空间）.</li><li>Object.assign(target, …sources)    es6 新增方法可以浅拷贝</li></ol><h3 id="九、正则表达式"><a href="#九、正则表达式" class="headerlink" title="九、正则表达式"></a>九、正则表达式</h3><ol><li>56</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 前端，js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>H5实训笔记</title>
      <link href="2021/09/07/H5CSS3/"/>
      <url>2021/09/07/H5CSS3/</url>
      
        <content type="html"><![CDATA[<h2 id="CSS动画"><a href="#CSS动画" class="headerlink" title="CSS动画"></a>CSS动画</h2><p><code>transition:</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> H5 </tag>
            
            <tag> CSS3 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于XGBoost的集成学习算法</title>
      <link href="2021/08/17/XGBoost/"/>
      <url>2021/08/17/XGBoost/</url>
      
        <content type="html"><![CDATA[<p>   2021暑假已过大半，我的大二也即将结束，大二与大三似乎过度得很仓促。不太愿意承认自己马上就要大三了，好像什么都还没做这个夏天又要过去了，好像什么都没做就马上要走出大学的校门了。</p><p>   这个暑假事情是比较多的，要准备9月初数模国赛，大创项目也要准备开题路演，而我又在实习。本来计划这个暑假初步完成大创的前端初稿，沉淀一下前端知识，得推一推了。马上开学而数模计划学习进度才刚过半，距离9月10号没剩几天了，得抓紧了✊练了一套19年国赛D题，本来以为会主要把时间花在模型训练，没想到的是大半时间都卡在数据清洗😅，这道题断断续续给我做了半个月😅下面主要写的是XGBoost模型建立的代码，以及参数调整方法，本项目所用到的所有代码都已上传到<a href="https://github.com/yuukyou-chan/MathModeling2019D">我的Github</a>，包括数据清洗，欢迎学习交流。</p><p>正文分割线</p><hr><p>  &nbsp;在学习集成算法之前，我有学过一点神经网络和智能算法（模拟退火，遗传算法）我发现其实这些算法是有点共性的，智能算法像是神经网络的祖先，里面提到的梯度下降等各种概念特别是遗传算法和非常神经网络神似。</p><p>  集成学习主要分为Bagging，Boosting，前者代表为随机森林，后者为XGBoost、GBDT</p><p>按照我的理解XGBoost就像是用多个小而简单的多项式相加代换一个复杂整体的表达式，就像高数里面最令人头疼泰勒展开式一样。这里算法细节不在具体解释，下面上代码：</p><blockquote><h2 id="代码展示"><a href="#代码展示" class="headerlink" title="代码展示"></a>代码展示</h2></blockquote><p>导包基操：</p><pre><code class="line-numbers language-python"># 导入包import numpy as npimport pandas as pdimport matplotlib.pyplot as pltfrom sklearn.ensemble import RandomForestRegressorimport xgboost as xgb# 导入数据from xgboost import plot_importancedata = pd.read_excel('合并.xls')data.head()# 切分数据集feas = data.columnsfeas_var = feas[0:11]  # 多维输入变量feas_lab = feas[12]  # 输出变量X = data[feas_var]  Y = data[feas_lab]# 切分训练集和测试集from sklearn.model_selection import train_test_splitx_train, x_valid, y_train, y_valid = train_test_split(X, Y, test_size=0.3, random_state=90)</code></pre><p>模型训练：</p><pre><code class="line-numbers language-python"># 训练模型xgb_model = xgb.XGBRegressor(n_estimators=1000, random_state=50, verbosity=1, max_depth=15, min_child_weight=4, gamma=0.6)xgb_model.fit(x_train, y_train, eval_metric='mae', eval_set=[(x_valid, y_valid)], early_stopping_rounds=100)</code></pre><p>模型评价：</p><pre><code class="line-numbers language-python"># 模型评价from sklearn.metrics import mean_absolute_error, mean_squared_error, accuracy_scorexgb_pred = xgb_model.predict(x_valid)print(np.corrcoef(xgb_pred, y_valid)[0, 1] ** 2)    # 相关系数print(mean_squared_error(xgb_pred, y_valid))        #均方误差print(mean_absolute_error(xgb_pred, y_valid))       #平均绝对误差# 准确率# accuracy = accuracy_score(y_valid,xgb_pred)# print('accuarcy:%.2f%%'%(accuracy*100))# 显示重要特征plot_importance(xgb_model)plt.show()</code></pre><p>结果展示：</p><p><img src="https://i.loli.net/2021/08/17/vKdCB5M39DOUVsE.png" alt="评价模型"></p><p>相关系数0.75还算可以吧</p><p><img src="https://i.loli.net/2021/08/17/sOmg9LDoWGawkS2.png" alt="特征重要度"></p><p>很明显压强对于自建点检测值偏差影响较大</p><blockquote><h2 id="参数调整"><a href="#参数调整" class="headerlink" title="参数调整"></a>参数调整</h2></blockquote><p>任何模型训练最头疼的就是参数调整了吧，之前写得神经网络调参也是我最头疼的一块，神经网络参数改动一点点效果也真的改动亿点点，不敢乱调神经网络，还好XGBoost比神经网络好调参，我在网上找到了一些XGBoost调参方法收藏一下。</p><p><img src="https://i.loli.net/2021/08/17/EOILlkZfwx9McNq.png" alt="各项参数"></p><p><img src="https://i.loli.net/2021/08/17/SbfgNotcIuPjKHA.png" alt="参数调节"></p><p>一般先调生成树的个数，一般树个数越多，效果越好，但是树的增加会是代码运行非常缓慢，存在边际效益递减，树的的个数越多，搭配较小的学习率更好。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 集成算法 </tag>
            
            <tag> XGBoost </tag>
            
            <tag> 数据清洗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端常考面试题</title>
      <link href="2021/07/17/front-end-interview/"/>
      <url>2021/07/17/front-end-interview/</url>
      
        <content type="html"><![CDATA[<h2 id="HTML、CSS常考20道"><a href="#HTML、CSS常考20道" class="headerlink" title="HTML、CSS常考20道"></a>HTML、CSS常考20道</h2><ol><li><blockquote><h5 id="行内元素、块级元素以及非替换元素、替换元素的区别（🌟🌟🌟）"><a href="#行内元素、块级元素以及非替换元素、替换元素的区别（🌟🌟🌟）" class="headerlink" title="行内元素、块级元素以及非替换元素、替换元素的区别（🌟🌟🌟）"></a>行内元素、块级元素以及非替换元素、替换元素的区别（🌟🌟🌟）</h5></blockquote><p>行内元素与块级元素的区别：</p><p>1）行内元素与块级元素直观上的区别</p><p>​    行内元素会在一条直线上排列，都是同一行的，水平方向排列</p><p>​    块级元素各占据一行，垂直方向排列。块级元素从新行开始结束接着一个断行。</p><p>2)块级元素可以包含行内元素和块级元素。行内元素不能包含块级元素。</p><p>3)行内元素与块级元素属性的不同，主要是盒模型属性上</p><p>4）行内元素设置width无效，height无效(可以设置line-height)，margin上下无效，padding上下无效</p></li><li><blockquote><h5 id="img的title和alt属性（🌟🌟）"><a href="#img的title和alt属性（🌟🌟）" class="headerlink" title="img的title和alt属性（🌟🌟）"></a>img的title和alt属性（🌟🌟）</h5></blockquote><ul><li>title是全局属性，可以用于所有的html元素</li></ul></li><li><blockquote><h5 id="meta标签的作用以及常用的meta标签（🌟🌟）"><a href="#meta标签的作用以及常用的meta标签（🌟🌟）" class="headerlink" title="meta标签的作用以及常用的meta标签（🌟🌟）"></a>meta标签的作用以及常用的meta标签（🌟🌟）</h5></blockquote></li><li><blockquote><h5 id="DOCTPE标签（🌟🌟🌟）"><a href="#DOCTPE标签（🌟🌟🌟）" class="headerlink" title="DOCTPE标签（🌟🌟🌟）"></a>DOCTPE标签（🌟🌟🌟）</h5></blockquote><ul><li>标准模式、兼容模式</li></ul></li><li><blockquote><h5 id="scrip标签的defer和async（推迟和异步属性）（🌟）"><a href="#scrip标签的defer和async（推迟和异步属性）（🌟）" class="headerlink" title="scrip标签的defer和async（推迟和异步属性）（🌟）"></a>scrip标签的defer和async（推迟和异步属性）（🌟）</h5></blockquote></li><li><blockquote><h5 id="W3C盒模型和怪异盒模型（🌟🌟🌟）"><a href="#W3C盒模型和怪异盒模型（🌟🌟🌟）" class="headerlink" title="W3C盒模型和怪异盒模型（🌟🌟🌟）"></a>W3C盒模型和怪异盒模型（🌟🌟🌟）</h5></blockquote><p><img src="/2021/07/17/front-end-interview/%E6%A0%87%E5%87%86%E7%9B%92%E6%A8%A1%E5%9E%8B.png" alt="标准盒模型"></p><p>​    在标准盒模型下，width和height是内容区域即content的width和height。而盒子总宽度为</p><p>​    在标准模式下，一个块的总宽度= width + margin(左右) + padding(左右) + border(左右)</p><p><img src="/2021/07/17/front-end-interview/IE%E6%88%96%E6%80%AA%E5%BC%82%E7%9B%92%E6%A8%A1%E5%9E%8B.png" alt="怪异盒模型">IE盒模型或怪异盒模型显而易见的区别就是，width和height除了content区域外，还包含padding和border。盒子的总宽度为 一个块的总宽度= width + margin(左右)（即width已经包含了padding和border值）</p></li><li><blockquote><h5 id="水平垂直居中的方法（还有只水平居中、只垂直居中）（🌟🌟🌟）"><a href="#水平垂直居中的方法（还有只水平居中、只垂直居中）（🌟🌟🌟）" class="headerlink" title="水平垂直居中的方法（还有只水平居中、只垂直居中）（🌟🌟🌟）"></a>水平垂直居中的方法（还有只水平居中、只垂直居中）（🌟🌟🌟）</h5></blockquote></li><li><blockquote><h5 id="BFC（🌟🌟🌟）"><a href="#BFC（🌟🌟🌟）" class="headerlink" title="BFC（🌟🌟🌟）"></a>BFC（🌟🌟🌟）</h5></blockquote><ul><li><p>BFC是什么</p><p>BFC(Block formatting context)直译为”块级格式化上下文”</p></li><li><p>触发条件</p><p>1、float的值不是none。</p><p>2、position的值不是static或者relative。</p><p>3、display的值是inline-block、table-cell、flex、table-caption或者inline-flex</p><p>4、overflow的值不是visible</p></li><li><p>特性及作用</p><p>解决</p><ol><li>浮动元素的父元素高度坍塌</li><li>两栏自适应布局</li><li>外边距垂直方向重合</li></ol></li></ul></li><li><blockquote><h5 id="清除浮动的方法（🌟🌟🌟）"><a href="#清除浮动的方法（🌟🌟🌟）" class="headerlink" title="清除浮动的方法（🌟🌟🌟）"></a>清除浮动的方法（🌟🌟🌟）</h5></blockquote><pre><code>    1. 额外标签法（在最后一个浮动标签后，新加一个标签，给其设置clear：both；）      2. 父级添加overflow属性（父元素添加overflow:hidden）（不推荐）      3. 使用after伪元素清除浮动（推荐使用）      4. 使用before和after双伪元素清除浮动</code></pre></li><li><blockquote><h5 id="position属性（绝对、相对、固定定位、粘性定位）（🌟🌟🌟）"><a href="#position属性（绝对、相对、固定定位、粘性定位）（🌟🌟🌟）" class="headerlink" title="position属性（绝对、相对、固定定位、粘性定位）（🌟🌟🌟）"></a>position属性（<strong>绝对、相对、固定定位</strong>、粘性定位）（🌟🌟🌟）</h5></blockquote></li><li><blockquote><h5 id="CSS隐藏元素的方式（🌟🌟🌟）"><a href="#CSS隐藏元素的方式（🌟🌟🌟）" class="headerlink" title="CSS隐藏元素的方式（🌟🌟🌟）"></a>CSS隐藏元素的方式（🌟🌟🌟）</h5></blockquote><ul><li>举例：display：none和visibility：hidden的区别（可以结合重排重绘说明）</li></ul></li><li><p>Flex布局（🌟🌟🌟）</p><ul><li>Flex容器和项目常见属性，举例：常用考察布局</li></ul><p>三个重要概念：轴，对齐，弹性</p></li><li><p>双栏布局、三栏布局（每种布局掌握多种方法）（🌟🌟🌟）</p></li><li><p>重排和重绘（🌟🌟🌟）</p></li><li><p>CSS选择器（🌟🌟）</p><ul><li>了解各个选择器的优先级</li><li>important属性</li></ul><p>ID选择器、标签选择器、类选择器、伪类选择器、属性选择器、结构选择器（6种）</p></li><li><p>CSS动画（难点，代码实现）（🌟🌟）</p><ul><li>animation属性</li><li>transition属性</li></ul></li><li><p>CSS实现三角形（手写实现）（🌟）</p></li><li><p>CSS Sprites（🌟🌟）</p><ul><li>原理和优势</li></ul></li><li><p>CSS长度相关题：px、rem、em（🌟）</p></li><li><p>伪类、伪元素（🌟）</p></li></ol><h2 id="JavaScript高频题"><a href="#JavaScript高频题" class="headerlink" title="JavaScript高频题"></a>JavaScript高频题</h2><ol><li><blockquote><h5 id="js数据类型（🌟🌟🌟）"><a href="#js数据类型（🌟🌟🌟）" class="headerlink" title="js数据类型（🌟🌟🌟）"></a>js数据类型（🌟🌟🌟）</h5></blockquote><ul><li><p>基本类型（6种，null，undefined比较像容易被问到，es6的symbol）</p></li><li><p>引用类型（1种object）</p><p>js中有六种数据类型，包括五种基本数据类型（Number,String,Boolean,Undefined,Null）,和一种复杂数据类型（Object）</p><p><strong>1.Number类型</strong></p><p>Number类型包含整数和浮点数（浮点数数值必须包含一个小数点，且小数点后面至少有一位数字）两种值。</p><p>NaN:非数字类型。特点：① 涉及到的 任何关于NaN的操作，都会返回NaN  ② NaN不等于自身。</p><p>isNaN() 函数用于检查其参数是否是非数字值。</p><p>isNaN(123)  //false  isNaN(“hello”)  //true</p><p><strong>2.String类型</strong></p><p>字符串有length属性。</p><p>字符串转换：转型函数String(),适用于任何数据类型（null,undefined 转换后为null和undefined）；toString()方法（null,defined没有toString()方法）。</p><p><strong>3.Boolean类型</strong></p><p>该类型只有两个值，true和false</p><p><strong>4.Undefined类型</strong></p><p>只有一个值，即undefined值。使用var声明了变量，但未给变量初始化值，那么这个变量的值就是undefined。</p><p><strong>5.Null类型</strong></p><p>null类型被看做空对象指针，前文说到null类型也是空的对象引用。</p><p>三大引用类型</p><p>​        引用类型的赋值其实是对象保存在栈区地址指针的赋值，因此两个变量指向同一个对象，任何的操作都会相互影响，而简单值类型</p><p><strong>1.Object类型</strong></p><p>我们看到的大多数类型值都是Object类型的实例，创建Object实例的方式有两种。</p><p>第一种是使用new操作符后跟Object构造函数，如下所示</p><p>var person = new Object();</p><p>person.name = “Micheal”;</p><p>person.age = 24;</p><p>第二种方式是使用对象字面量表示法，如下所示</p><p>var person = {</p><p>　　name : “Micheal”,</p><p>　　age : 24</p><p>};</p><p><strong>2.Array类型</strong></p><p>数组的每一项可以用来保存任何类型的数据，也就是说，可以用数组的第一个位置来保存字符串，第二个位置保存数值，第三个位置保存对象….另外，数组的大小是可以动态调整的。</p><p>创建数组的基本方式有两种</p><p>第一种是使用Array构造函数，如下所示</p><p>var colors = new Array(“red”,”blue”,”yellow”);</p><p>第二种是使用数组字面量表示法，如下所示</p><p>var colors = [“red”,”blue”,”yellow”];</p><p><strong>3 Function类型</strong></p><p>每个函数都是Function类型的实例，而且都与其他引用类型一样具有属性和方法。函数通常是使用函数声明语法定义的，如下所示</p><p>function sum(num1,num2){</p><p>　　return num1 + num2;</p><p>};</p><p>这和使用函数表达式定义函数的方式相差无几。</p><p>var sun = function (){</p><p>　　return sum1 + sum2;</p><p>};</p></li></ul></li><li><blockquote><h5 id="判断变量的类型（🌟🌟🌟）"><a href="#判断变量的类型（🌟🌟🌟）" class="headerlink" title="判断变量的类型（🌟🌟🌟）"></a>判断变量的类型（🌟🌟🌟）</h5></blockquote><ul><li>typeof</li><li>instanceof及原理</li><li>Object.toString().call()及原理([可以输出对象的内部属性[class]])</li></ul><p>​    <strong>typeof 操作符</strong></p><p>​    由于<code>js</code>中的变量是松散类型的，所以它提供了一种检测当前变量的数据类型的方法，也就是typeof关键字.</p><pre><code class="line-numbers language-js">typeof  123　　 //Numbertypeof  'abc'　　//Stringtypeof   true    //Booleantypeof   undefined  //Undefinedtypeof   null     //Objecttypeof   { }      //Objecttypeof   [ ]      //Objecttypeof   console.log()    //Function</code></pre><p>​    <strong>null类型进行typeof操作符后，结果是object</strong>，原因在于，null类型被当做一个空对象引用。</p><p>​        </p><p>​    <strong>Object.toString().call()</strong></p><p>​    在JavaScript里使用typeof判断数据类型，只能区分基本类型，即：number、string、undefined、boolean、    object。<br>​    对于null、array、function、object来说，使用typeof都会统一返回object字符串。<br>​    要想区分对象、数组、函数、单纯使用typeof是不行的。在JS中，可以通过Object.prototype.toString方法，    判断某个对象之属于哪种内置类型。<br>​    分为null、string、boolean、number、undefined、array、function、object、date、math。</p></li><li><blockquote><h5 id="数据类型转换（🌟🌟）（复杂、适当看看就行）"><a href="#数据类型转换（🌟🌟）（复杂、适当看看就行）" class="headerlink" title="数据类型转换（🌟🌟）（复杂、适当看看就行）"></a>数据类型转换（🌟🌟）（复杂、适当看看就行）</h5></blockquote><ul><li><p>相等==和全等===</p></li><li><p>强制类型转换和隐式转换</p></li><li><p>包装类型</p><p>相等 ==： 先转换类型再比较<br>全等 ===：直接比较，不转换类型，只要是类型不同就不相等，类型相同的看值是否相等<br>Object.is(value1,value2)：ES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。Object.is就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。</p></li></ul><p>​    强制类型转换：通过String（），Number（），Boolean（）函数强制转换</p><p>​    隐式转换：不同类型的变量比较要先转类型，叫做类型转换，类型转换也叫隐式转换。隐式转换通常发生在    运算符加减乘除，等于，还有小于，大于等。</p><pre><code class="line-numbers language-js">console.log(typeof '11')**//输出string**console.log(typeog 11) **//输出number**console.log('11' &lt; 4 ) **//输出false**</code></pre><p>​    1.字符串加数字,数字就会转成字符串。</p><p>​    2.数字减字符串，字符串转成数字。如果字符串不是纯数字就会转成NaN。字符串减数字也一样。两个字符    串相减也先转成数字。</p><p>​    3.乘，除，大于，小于跟减的转换也是一样。</p><pre><code class="line-numbers language-js">console.log(10+'20') //2010console.log(10-'20')//-10 numberconsole.log(10-'one') //NaN not a numberconsole.log(10-'101a') //NaNconsole.log(10*'20') //200 numberconsole.log('10'*'20') //200 numberconsole.log(20/'10') //2 numberconsole.log('20'/'10') //2 numberconsole.log('20'/'one') //NaN</code></pre></li><li><blockquote><h5 id="原型和原型链（🌟🌟🌟）"><a href="#原型和原型链（🌟🌟🌟）" class="headerlink" title="原型和原型链（🌟🌟🌟）"></a>原型和原型链（🌟🌟🌟）</h5></blockquote><ul><li>举例：给一个构造函数，描述构造函数、实例和原型之间的关系（比如说构造函数的prototype属性是指向原型等）</li></ul></li><li><blockquote><h5 id="闭包（🌟🌟🌟）"><a href="#闭包（🌟🌟🌟）" class="headerlink" title="闭包（🌟🌟🌟）"></a>闭包（🌟🌟🌟）</h5></blockquote><ul><li>概念</li><li>优缺点</li></ul></li><li><blockquote><h5 id="call-apply-bind的区别（🌟🌟🌟）"><a href="#call-apply-bind的区别（🌟🌟🌟）" class="headerlink" title="call/apply/bind的区别（🌟🌟🌟）"></a>call/apply/bind的区别（🌟🌟🌟）</h5></blockquote></li><li><blockquote><h5 id="DOM事件流（红宝书P347）和委托事件（P347）（🌟🌟🌟）"><a href="#DOM事件流（红宝书P347）和委托事件（P347）（🌟🌟🌟）" class="headerlink" title="DOM事件流（红宝书P347）和委托事件（P347）（🌟🌟🌟）"></a>DOM事件流（红宝书P347）和委托事件（P347）（🌟🌟🌟）</h5></blockquote><ul><li>捕获、冒泡</li><li>事件委托及好处</li></ul></li><li><blockquote><h5 id="cookie和storage区别（🌟🌟🌟）"><a href="#cookie和storage区别（🌟🌟🌟）" class="headerlink" title="cookie和storage区别（🌟🌟🌟）"></a>cookie和storage区别（🌟🌟🌟）</h5></blockquote><ul><li><p>cookie的构成</p></li><li><p>localStorage和sessionStorage</p><p>举例：cookie的HTTPOnly（加上之后无法通过js获取cookie，从而防止xss攻击）</p></li></ul></li><li><blockquote><h5 id="数组-对象常见的方法（这些方法会不会改变原始值）（🌟🌟）"><a href="#数组-对象常见的方法（这些方法会不会改变原始值）（🌟🌟）" class="headerlink" title="数组/对象常见的方法（这些方法会不会改变原始值）（🌟🌟）"></a>数组/对象常见的方法（这些方法会不会改变原始值）（🌟🌟）</h5></blockquote><ul><li>Array：slice/splice/concat/filter/map/reduce</li><li>Object：key/assign（Object.assign可用于浅拷贝）</li></ul></li><li><blockquote><h5 id="new一个对象时内部发生了什么（🌟）"><a href="#new一个对象时内部发生了什么（🌟）" class="headerlink" title="new一个对象时内部发生了什么（🌟）"></a>new一个对象时内部发生了什么（🌟）</h5></blockquote></li><li><p>防抖和节流（🌟</p></li><li><p>JS动画相关：requestAnimationFrame相比于setlnterval实现动画效果的优势是什么</p></li><li><p>this指向（考察概念，或给一段代码说结果）（🌟🌟）</p></li><li><p>作用域链（🌟）</p></li><li><p>let/var/const（🌟🌟🌟）【15-17是ES6易考点知识，阮一峰ES6入门】</p><p>使用var声明的变量，其作用域为该语句所在的函数内，且存在变量提升现象；<br>使用let声明的变量，其作用域为该语句所在的代码块内，不存在变量提升；<br>使用const声明的是常量，在后面出现的代码中不能再修改该常量的值。</p></li><li><p>异步编程：promise和async await（🌟🌟🌟）</p><ul><li>内部状态</li><li>promise.race和promise.all</li></ul></li><li><p>箭头函数（🌟🌟）</p></li><li><p>JS运行机制（介绍什么是event loop、setTimeout和promise结合题目写结果）</p><ul><li>单线程、解释性语言</li><li>事件循环</li><li>宏任务/微任务</li></ul></li><li><p>实现继承的方式（红宝书P162）（🌟🌟）</p></li><li><p>垃圾回收（P78）（🌟）</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 面经 </tag>
            
            <tag> html </tag>
            
            <tag> css </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HadoopExpriment</title>
      <link href="2021/05/30/Hadoop/"/>
      <url>2021/05/30/Hadoop/</url>
      
        <content type="html"><![CDATA[<p>图片我懒得搬了，要一张一张的改路径太麻烦了</p><h2 id="实验三"><a href="#实验三" class="headerlink" title="实验三"></a>实验三</h2><p>七、实验步骤</p><p>（一）Hbase shell 命令</p><p>1.启动hadoop</p><p>cd /usr/local/hadoop</p><p>./sbin/start-all.sh</p><p>2.启动hbase和hbase shell</p><p>cd /usr/local/hbase</p><p>./bin/start-hbase.sh</p><p>./bin/hbase shell</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps14.jpg" alt="img"> </p><p>l 进入HBase Shell命令行模式以后，用户可以通过输入Shell命令操作HBase数据库。</p><p>\3. 用list命令查看当前HBase数据库中已经创建了哪些表</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps15.jpg" alt="img"> </p><p>\4. 若已存在student表，则删除</p><p>disable ‘student’</p><p>drop ‘student’</p><p>\5. 用create命令创建表</p><p>create ‘student’,’Sname’,’Ssex’,’Sage’,’Sdept’,’course’</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps16.jpg" alt="img"> </p><p>\6. 查看数据</p><p>l HBase中有两个用于查看数据的命令：1. get命令，用于查看表的某一行数据；2. scan命令用于查看某个表的全部数据</p><p>get ‘student’,’20202020’</p><p>scan ‘student’</p><p>\7. 用put命令将自己的姓名、学号添加到student表中。例如姓名为‘Zhangsan’，学号‘20202020’:</p><p>put ‘student’,’20202020’,’Sname’,’Zhangsan’</p><p>l 即为student表添加了学号为20202020，名字为Zhangsan的一行数据，其行键为20202020</p><p>put ‘student’,’20202020’,’course:math’,’80’</p><p>l 即为20202020行下的course列族的math列添加了一个数据。</p><p>\8. 在HBase中用delete以及deleteall命令进行删除数据操作，它们的区别是：1. delete用于删除一个数据，是put的反向操作；2. deleteall操作用于删除一行数据。</p><p>delete ‘student’,’20202020’,’Ssex’</p><p>l 删除了student表中20202020行下的Ssex列的所有数据。</p><p>get ‘student’，‘20202020’</p><p>l 查看是否删除成功</p><p>deleteall ‘student’,’20202020’</p><p>l 删除了student表中的95001行的全部数据。</p><p>\8. 查询表历史数据</p><p>1）在创建表的时候，指定保存的版本数（假设指定为5）</p><p>create ‘teacher’,{NAME=&gt;’username’,VERSIONS=&gt;5}</p><p>2）插入数据然后更新数据，使其产生历史版本数据，注意：这里插入数据和更新数据都是用put命令</p><p>put ‘teacher’,’91001’,’username’,’Mary’</p><p>put ‘teacher’,’91001’,’username’,’Mary1’</p><p>put ‘teacher’,’91001’,’username’,’Mary2’</p><p>put ‘teacher’,’91001’,’username’,’Mary3’</p><p>put ‘teacher’,’91001’,’username’,’Mary4’  </p><p>put ‘teacher’,’91001’,’username’,’Mary5’</p><p>3）查询时，指定查询的历史版本数。默认会查询出最新的数据。（有效取值为1到5）</p><p>get ‘teacher’,’91001’,{COLUMN=&gt;’username’,VERSIONS=&gt;5}</p><p>\9. 退出HBase数据库表操作</p><p>exit</p><p>l 注意：这里退出HBase数据库是退出对数据库表的操作，而不是停止启动HBase数据库后台运行。</p><p>\10. 停止HBase运行</p><p>bin/stop-hbase.sh</p><p>11.关闭Hadoop</p><p>./sbin/stop-all.sh  </p><p>（二）Java API编程实例</p><p>\1. 启动hadoop，启动hbase(运行java代码时一定要保证hbase是启动状态)</p><p>cd /usr/local/hadoop</p><p>./sbin/start-all.sh</p><p>cd /usr/local/hbase</p><p>./bin/start-hbase.sh</p><p>2.在Eclipse中新建Java Project（Project名字为你名字的拼音，注意下图框起来部分）——&gt;新建Class</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps17.png" alt="img"><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps18.jpg" alt="img"> </p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps19.jpg" alt="img"> </p><p>\3. 在工程中导入外部jar包</p><p>l 在项目名称上右键选Property，在弹出的对话框左侧列表中选择Java Build Path，如下图所示：选择Add External JARs</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps20.png" alt="img"><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps21.jpg" alt="img"> </p><p>l 导入hbase安装目录中的lib（usr/local/hbase/lib,注意目录不要选错）文件中的所有jar包</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps22.jpg" alt="img"> </p><p>4.编写代码并运行</p><p>l 在Linux系统中打开浏览器，输入网址<a href="http://dblab.xmu.edu.cn/blog/install-hbase/%E5%A4%8D%E5%88%B6%E4%BB%A3%E7%A0%81%E3%80%82">http://dblab.xmu.edu.cn/blog/install-hbase/复制代码。</a></p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps23.jpg" alt="img"> </p><p>l 复制完成后，编译运行，Run as Java Application。运行成功后如图</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps24.jpg" alt="img"> </p><p>\5. 进入Hbase shell</p><p>scan ‘Score’ </p><p>\6. 在Eclipse中执行其它语句（除了createTable语句外，每人任选两条以上语句执行，每次执行一条，在Eclipse执行完后在shell中查看结果。）</p><p>l 主函数中的语句请任选两条执行，只需删除其前的//，并将其它语句注释掉即可，如：执行insertRow时请将其他语句注释</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps25.jpg" alt="img"> </p><p>l 执行完成后在shell中查看结果</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps26.jpg" alt="img"> </p><p>7.关闭hbase和hadoop</p><p>bin/stop-hbase.sh</p><p>./sbin/stop-all.sh  </p><h2 id="实验四"><a href="#实验四" class="headerlink" title="实验四"></a>实验四</h2><p>七、实验步骤</p><p>（一）安装 Hadoop-Eclipse-Plugin</p><p>进入本地文件系统的“下载”文件夹，单击右键，点在终端打开。</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps45.jpg" alt="img"> </p><p>l 在终端中输入命令(或者直接在文件系统中将该jar包拷贝到/usr/local/eclipse/plugins/中)</p><p>sudo cp hadoop-eclipse-plugin-2.6.0.jar /usr/local/eclipse/plugins/</p><p>l 复制完成后 使用以下命令，查看该jar包是否复制成功。</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps46.jpg" alt="img"> </p><p>l 在shell中运行以下命令重启 Eclipse </p><p>/usr/lib/eclipse/eclipse -clean</p><p>（二）在hadoop的HDFS文件系统中新建输入文件夹</p><p>1.启动hadoop</p><p>cd /usr/local/hadoop</p><p>./sbin/start-all.sh</p><p>2.在HDFS中创建用户目录</p><p>l 本实验环境的Hadoop为伪分布式，伪分布式读取的则是 HDFS 上的数据。要使用 HDFS，首先需要创建用户目录。（已存在该文件夹则跳过这步）</p><p>bin/hdfs dfs -mkdir -p /user/hadoop</p><p>l 接着将 etc/hadoop 中的文件作为输入文件复制到分布式文件系统中，即将 /usr/local/hadoop/etc/hadoop 复制到分布式文件系统中的 /user/hadoop/input 中。上一步已创建了用户目录 /user/hadoop ，因此命令中就可以使用相对目录如 input，其对应的绝对路径就是 /user/hadoop/input:</p><p>bin/hdfs dfs -put etc/hadoop/*.xml input</p><p>l 查看input中的文件</p><p>bin/hdfs dfs –ls /user/hadoop/input</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps47.jpg" alt="img"> </p><p>l 程序统计的就是这些文件中的词频。</p><p>l 也可以自己创建文件拷贝到hdfs中进行统计。</p><p>（三） 配置 Hadoop-Eclipse-Plugin</p><p>1.启动Eclipse</p><p>l 启动 Eclipse 后就可以在左侧的Project Explorer中看到 DFS Locations</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps48.jpg" alt="img"> </p><p>\2. 进一步配置插件</p><p>l 第一步，选择 Window 菜单下的 Preference。</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps49.jpg" alt="img"> </p><p>l 此时会弹出一个窗体，窗体的左侧会多出 Hadoop Map/Reduce 选项，点击此选项，选择 Hadoop 的安装目录（如/usr/local/hadoop，Ubuntu不好选择目录，直接输入就行）。</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps50.jpg" alt="img"> </p><p>l 第二步：切换 Map/Reduce 开发视图，选择 Window 菜单下选择 Open Perspective -&gt; Other，弹出一个窗体，从中选择 Map/Reduce 选项即可进行切换。</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps51.jpg" alt="img"> </p><p>l 第三步：建立与 Hadoop 集群的连接，点击 Eclipse软件右下角的 Map/Reduce Locations 面板，在面板中单击右键，选择 New Hadoop Location。</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps52.png" alt="img"><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps53.jpg" alt="img"> </p><p>l 在弹出来的 General 选项面板中，General 的设置要与 Hadoop 的配置一致。一般两个 Host 值是一样的，如果是伪分布式，填写 localhost 即可，另外我们使用的<a href="http://dblab.xmu.edu.cn/blog/install-hadoop/">Hadoop伪分布式配置</a>，设置 fs.defaultFS 为 hdfs://localhost:9000，则 DFS Master 的 Port 要改为 9000。Map/Reduce(V2) Master 的 Port 用默认的即可，Location Name 随意填写。</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps54.jpg" alt="img"> </p><p>（四）在 Eclipse 中操作 HDFS 中的文件</p><p>l 配置好后，点击左侧 Project Explorer 中的 MapReduce Location （点击三角形展开）就能直接查看 HDFS 中的文件列表了，双击可以查看内容，右键点击可以上传、下载、删除 HDFS 中的文件，无需再通过繁琐的 hdfs dfs -ls 等命令进行操作了。</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps55.jpg" alt="img"> </p><p>（五）在 Eclipse 中创建 MapReduce 项目</p><p>l 点击 File 菜单，选择 New -&gt; Project…选择 Map/Reduce Project，点击 Next。</p><p>l 填写 Project name 为 WordCount 即可，点击 Finish 就创建好了项目。</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps56.jpg" alt="img"> </p><p>l 右键点击刚创建的 WordCount 项目，选择 New -&gt; Class</p><p>l 需要填写两个地方：在 Package 处填写 org.apache.hadoop.examples；在 Name 处填写 WordCount。</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps57.jpg" alt="img"> </p><p>l 创建 Class 完成后，在 Project 的 src 中就能看到 WordCount.java 这个文件。将如下 WordCount 的代码复制到该文件中。</p><p>l 用linux浏览器打开网址复制WordCount代码<a href="http://dblab.xmu.edu.cn/blog/hadoop-build-project-using-eclipse/">http://dblab.xmu.edu.cn/blog/hadoop-build-project-using-eclipse/</a></p><p>（六）通过 Eclipse 运行 MapReduce</p><p>l 在运行 MapReduce 程序前，还需要将 /usr/local/hadoop/etc/hadoop 中将有修改过的配置文件（如伪分布式需要修改 core-site.xml 和 hdfs-site.xml，本镜像已完成修改），以及 log4j.properties 复制到 WordCount 项目下的 src 文件夹（~/workspace/WordCount/src）中。在shell中完成复制。</p><p>cp /usr/local/hadoop/etc/hadoop/core-site.xml ~/workspace/WordCount/src</p><p>cp /usr/local/hadoop/etc/hadoop/hdfs-site.xml ~/workspace/WordCount/src</p><p>cp /usr/local/hadoop/etc/hadoop/log4j.properties ~/workspace/WordCount/src</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps58.jpg" alt="img"> </p><p>l 复制完成后，务必右键点击 WordCount 选择 refresh 进行刷新（不会自动刷新，需要手动刷新），可以看到文件结构如下所示：</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps59.jpg" alt="img"> </p><p>l 点击工具栏中的 Run 图标，或者右键点击 Project Explorer 中的 WordCount.java，选择 Run As -&gt; Run on Hadoop，就可以运行 MapReduce 程序了。不过由于没有指定参数，运行时会提示 “Usage: wordcount “，需要通过Eclipse设定一下运行参数。</p><p>l 右键点击刚创建的 WordCount.java，选择 Run As -&gt; Run Configurations，在此处可以设置运行时的相关参数（如果 Java Application 下面没有 WordCount，那么需要先双击 Java Application）。切换到 “Arguments” 栏，在 Program arguments 处填写 “input output” 就可以了。</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps60.jpg" alt="img"> </p><p>l 设定参数后，再次运行程序，可以看到运行成功的提示。</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps61.jpg" alt="img"> </p><p>l 可以在Shell中查看结果：</p><p>./bin/hdfs dfs –cat output/*</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps62.jpg" alt="img"> </p><p>l 提示：如果提示错误“-Syntax error, parameterized types are only availble if source level is 1.5 or greater”。单击错误提示图标，在弹出的对话框中，在Change project compliance and JRE to 1.5 这行文字上双击，就可以让错误信息消失。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>基于RNN、LSTM神经网络的基金净值预测</title>
      <link href="2021/05/30/LSTMkeras/"/>
      <url>2021/05/30/LSTMkeras/</url>
      
        <content type="html"><![CDATA[<blockquote><p>都是神经网络惹的祸</p></blockquote><p>&nbsp; &nbsp; &nbsp; &nbsp; 这个月花了将近100G的流量，大半都拿来下学习视频了。上次写了个爬虫把基金数据爬下来了，说是要数据分析一波，头脑热了一个礼拜，每天晚上都在搞神经网络的代码，光是装TensorFlow环境就搞了我3个晚上，到处在网上找代码学习，本来就差最后一步就把要程序跑出来了，结果卡在了反归一化上面，输入输出维度不匹配，又搞了好几天，终于神经网络把我劝退了。我发现这样是行不通的，整得太浮躁了，不懂计算原理直接啃代码，连输入输出是什么都不懂，一些基本的激活函数、归一函数、评价模型都不懂想直接调包也没那么容易，出结果<br></p><p>&nbsp; &nbsp; &nbsp; &nbsp;后来大概过了大半个月，机缘巧合正好需要用到机器学习，我拾起了之前留下的烂摊子，慢慢（假的）基础知识学习，又搞起了机器学习。<br></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 今天终于能把神经网络跑出来了😁好久没更新博客了，主要是最近没啥时间搞自己的东西，作业都写不完</p><h2 id="大家好，我是调包侠"><a href="#大家好，我是调包侠" class="headerlink" title="大家好，我是调包侠"></a>大家好，我是调包侠</h2><p>虽然把神经网络跑出来了，中间还有些小问题，预测效果也不是很好，但是能跑出来</p><p>我就非常开心了，后面会再把基础打扎实一些。<br></p><p>先看效果图：</p><p><img src="/2021/05/30/LSTMkeras/%E9%A2%84%E6%B5%8B.png" alt="预测"></p><p>两条线基本拟合度不是很好，甚至可以说两条线没什么关系，细节波动预测不到，但是大致走势还比较正确（已经调整过很多种方案了，这是还比较像人样的）<br></p><p>看看他的过去：可以说是毫不相干😡<br></p><p>最开始这是纯RNN模型</p><p><img src="/2021/05/30/LSTMkeras/RNN.png" alt="RNN"></p><p>后来我改成了LSTM模型，发现更离谱：（后来我把模型的第一层改成LSTM就得到了图一）</p><p><img src="/2021/05/30/LSTMkeras/LSTM.png"></p><p>大概可以看出加入LSTM模型，预测值将会变得更趋于平缓，我猜可能是因为LSTM模型对长期记忆性导致的<br></p><p>其中存在的问题是每次Epoch的val_loss值都是不变，而且loss值为什么都是nan，我去看了网上说是每次训练出来的权重不变（或者说没有更新），或者是模型错误造成的，俺不懂怎么办了，百思不得其解，有没有懂得大佬指点一下，感激涕零😭<img src="/2021/05/30/LSTMkeras/%E6%8D%9F%E5%A4%B1%E5%80%BC.png" alt="损失值"></p><h2 id="下面康康学习过程"><a href="#下面康康学习过程" class="headerlink" title="下面康康学习过程"></a>下面康康学习过程</h2><p>好多包，我好爱</p><pre><code class="line-numbers language-python">import numpy as npimport tensorflow as tffrom tensorflow.keras.layers import Dropout, Dense, SimpleRNN, LSTMimport matplotlib.pyplot as pltimport osimport pandas as pdfrom sklearn.preprocessing import MinMaxScalerfrom sklearn.metrics import mean_squared_error, mean_absolute_errorimport math</code></pre><p>导入数据和数据预处理：</p><pre><code class="line-numbers language-python">yiliao = pd.read_csv('./SH600519.csv')#print(yiliao)training_set = yiliao.iloc[0:2426 - 300, 2:3].values  #前（1975-300）天的净值作为训练集，表格从0开始计数，2:3是提取[1:2）列，前闭后开，故提取出第二列净值test_set = yiliao.iloc[2426 - 300:, 2:3].values  #后300天的开盘价作为测试集#归一化sc = MinMaxScaler(feature_range=(0, 1))  #定义归一化；缩放到（0,1）之间training_set_scaled = sc.fit_transform(training_set)  #求得训练集的最大最小值这些训练集固有的属性，并在训练集上进行归一化test_set = sc.fit_transform(test_set)  #利用训练集的属性对测试集进行归一化</code></pre><p>还是数据预处理，将数据训练集和测试集划分</p><pre><code class="line-numbers language-python">测试集：csv表格中的前1975-300=1675天的数据#利用for循环，遍历整个训练集，提取训练集中连续60天的开盘价作为输入特征x_train,第61天的数据作为标签，for循环共构建1975-300-60=1615for i in range(60, len(training_set_scaled)):    x_train.append(training_set_scaled[i - 60:i, 0])    y_train.append(training_set_scaled[i: 0])#打乱训练集顺序np.random.seed(7)np.random.shuffle(x_train)np.random.seed(7)np.random.shuffle(y_train)tf.random.set_seed(7)#将训练集由list格式变为array格式x_train, y_train = np.array(x_train), np.array(y_train)#此处整个数据集送入，送入样本数为x_train.shape[0]及1615组数据x_train = np.reshape(x_train, (x_train.shape[0], 60, 1))#测试集：csv表格中后300天数据#...省略for i in range(60, len(test_set)):    x_test.append(test_set[i - 60:i, 0])    y_test.append(test_set[i, 0])#测试集变arry并reshape为符合RNN输入要求：[送入样本数， 循环核时间展开步数， 每个时间步输入的特征个数]x_test, y_test = np.array(x_test), np.array(y_test)x_test = np.reshape(x_test, (x_test.shape[0], 60, 1))</code></pre><p>设定模型：</p><pre><code class="line-numbers language-python">model = tf.keras.Sequential([    SimpleRNN(80, return_sequences=True),    Dropout(0.2),    SimpleRNN(100),    Dropout(0.2),    Dense(1)])model.compile(optimizer=tf.keras.optimizers.Adam(0.001),loss='mean_squared_error')  #损失函数用均方误差</code></pre><p>保存训练好的模型：</p><pre><code class="line-numbers language-python">checkpoint_sava_path = "./checkpoint/jijin.ckpt"if os.path.exists(checkpoint_sava_path + '.index'):    print('--------load the model--------')    model.load_weights(checkpoint_sava_path)cp_callback = tf.keras.callbacks.ModelCheckpoint(filepath=checkpoint_sava_path,                                                 save_weights_only=True,                                                 save_best_only=True,                                                 monitor='val_loss')history = model.fit(x_train, y_train, batch_size=128, epochs=5, validation_data=(x_test, y_test), validation_freq=1,                    callbacks=[cp_callback])model.summary()file = open('./weight.txt', 'w')  #参数提取for v in model.trainable_variables:    file.write(str(v.name) + '\n')    file.write(str(v.shape) + '\n')    file.write(str(v.numpy()) + '\n')file.close()loss = history.history['loss']val_loss = history.history['val_loss']</code></pre><p>画出损失函数图：</p><pre><code>plt.plot(loss, label='Training Loss')plt.plot(val_loss, label='Validation Loss')plt.title('Training and Validation Loss')plt.legend()plt.show()</code></pre><p>测试集输入模型开始预测：</p><pre><code class="line-numbers language-python">predicted_stock_price = model.predict(x_test)# 对预测数据还原--从（0-1）反归一化到原始范围predicted_stock_price = sc.inverse_transform(predicted_stock_price)# 对真实数据还原--从0-1）反归一化到原始范围real_stock_price = sc.inverse_transform(test_set[60:])# 画出真实数据和预测数据对比曲线plt.plot(real_stock_price, color='red', label='Jijin Price')plt.plot(predicted_stock_price, color='blue', label='Predicted Jijin Price')plt.title('Jijin Price Prediction')plt.xlabel('Time')plt.ylabel('Jijin Price')plt.legend()plt.show()</code></pre><p>评价模型：</p><pre><code class="line-numbers language-python">mse = mean_squared_error(predicted_stock_price, real_stock_price)# 均方根误差rmse = math.sqrt(mean_squared_error(predicted_stock_price, real_stock_price))# 平均绝对误差mae = mean_absolute_error(predicted_stock_price, real_stock_price)</code></pre><p>以上<br></p><p><strong>完整代码会上传到我的<a href="https://github.com/yuukyou-chan">Github</a>，欢迎fock，顺便求助一下俺的问题555</strong></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 神经网络 </tag>
            
            <tag> LSTM </tag>
            
            <tag> RNN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习入门笔记</title>
      <link href="2021/05/21/ML/"/>
      <url>2021/05/21/ML/</url>
      
        <content type="html"><![CDATA[<h1 id="一、数据处理"><a href="#一、数据处理" class="headerlink" title="一、数据处理"></a>一、数据处理</h1><h2 id="缺失值判断："><a href="#缺失值判断：" class="headerlink" title="缺失值判断："></a>缺失值判断：</h2><ol><li><p><code>pd.isnull(movie)</code> 如果是缺失值返回true；</p><p>返回结果是一张表，表里填满 true和false；</p></li><li><p>判断整张表是否有缺失值：</p><p><code>np.any(pd.isnull(movie))</code></p><p>反三：any-all      isnull-notnull</p><p>返回结果为一个值：true/false</p></li></ol><h2 id="缺失值删除和替换"><a href="#缺失值删除和替换" class="headerlink" title="缺失值删除和替换"></a>缺失值删除和替换</h2><ol><li><p><code>movie(“列变量名”).fillna(value=movie["列变量名"].mean(), inplace=True)</code>  </p><p>替换变量函数：fillna( )</p><p>.mean()：用该列平均值替换NaN值</p><p>inplace=Ture:   不创建新的对象，直接对原始对象进行修改；</p><p>inplace=False：对数据进行修改，创建并返回新的对象承载其修改结果。</p></li><li><p>替换所有缺失值：</p><pre><code class="line-numbers language-python">for i in movie.columns：    #遍历列  if np.any(pd.isnull(movie[i])) == True:  #如果此列有NaN值        movie[i].fillna(value=movie[i].mean(), inplace=True)np.any(pd.isnull(movie))  #检测是否替换完成</code></pre></li><li><p>删除缺失值（整张表中）</p><p><code>data = movie.dropna()</code></p></li><li><p>缺失值不是NaN的处理情况</p><p>如将 “？”替换成np.nan</p><p><code>wis = wis.replace(to_replace='?',value=np.NaN)</code></p></li></ol><h2 id="数据离散化"><a href="#数据离散化" class="headerlink" title="数据离散化"></a>数据离散化</h2><p><code>pd.qcut(data,q)</code></p><h2 id="数据合并"><a href="#数据合并" class="headerlink" title="数据合并"></a>数据合并</h2><p><code>pd.concat({data, data_dummies}, axis=1)</code> axis参数表作用方向：此句中的axis=1表示两张表按行(水平方向)拼接</p><p><code>pd.merge(left, right, how="inner", left_on=None,right_on=None)</code></p><h2 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h2><p>seaborn库介绍</p><ul><li>seaborn.implot() 可以再绘制二维散点图时自动完成回归拟合</li><li>data=  ：关联数据集</li><li>hue=“</li></ul><p>matplotlin库介绍</p><p>绘制柱状图：</p><p><img src="/2021/05/21/ML/%E6%9F%B1%E7%8A%B6%E5%9B%BE.png" alt="柱状图"></p><h2 id="数据归一化"><a href="#数据归一化" class="headerlink" title="数据归一化"></a>数据归一化</h2><pre><code class="line-numbers language-python">from sklearn.preprocessing import MinMaxScaler</code></pre><p><img src="/2021/05/21/ML/%E6%95%B0%E6%8D%AE%E5%BD%92%E4%B8%80%E5%8C%96.png" alt="数据归一化"></p><p><img src="/2021/05/21/ML/%E5%BD%92%E4%B8%80%E5%8C%96%E5%AE%9E%E4%BE%8B.png" alt="归一化实力"></p><h2 id="数据标准化"><a href="#数据标准化" class="headerlink" title="数据标准化"></a>数据标准化</h2><p><img src="/2021/05/21/ML/%E6%95%B0%E6%8D%AE%E6%A0%87%E5%87%86%E5%8C%96API.png" alt="数据标准化AIP"></p><p>实例：修改归一化实例图中的<code>transfer = StandardScaler</code> 即可</p><h2 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h2><p>API：<code>sklearn.linear_model.LinearRegression()</code></p><p>属性：LinearRegression.coef_：回归系数</p><p><img src="/2021/05/21/ML/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92.png" alt="线性回归"></p><p>优化算法:</p><ul><li>正规方程(直接矩阵运算求w权重,如果特征多求解速度慢,只能在线性回归总运用),</li><li>梯度下降(沿着切线向下的方向，递归迭代计算权重,广泛使用)：找到当误差最小时，最优自变量|权重|参数</li><li>性能评估：使用均方误差；<br>适用场景：</li><li>小规模数据建议LinearRegression(不能解决过拟合问题)和岭回归；</li><li>大规模用SGDRegressor：随机梯度下降</li></ul><h3 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h3><p>目的：求出当误差最小时，最优自变量|权重|参数</p><p><code>sklearn.linear_model.SGDRegression()</code></p><ul><li>包：from sklearn.linear_model import SGDRegressor</li><li>支持loss函数(损失类型),和正则化惩罚项来拟合线性回归模型</li><li>loss=‘squared_loss’:默认普通最小二乘法</li><li>可以用网络搜索算法来优化学习率和梯度迭代次数</li><li>fit_intercept=True :是否计算偏置</li><li>learning_rate=‘invscaling’:学习率</li><li>‘invscaling’：学习率算法 包含 “comstant”,“optimal”,‘invscaling’,</li></ul><p>对于常数值的学习率可以使用<strong>“comstant”</strong>==0</p><p>max_iter=None,梯度迭代次数<br>SGDRegressor.coef_:查看回归系数函数</p><p><img src="/2021/05/21/ML/image-20210528133121562.png" alt="数据处理"></p><p><img src="/2021/05/21/ML/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E5%B8%B8%E7%94%A8%E5%B8%B8%E6%95%B0.png" alt="梯度下降常用常数"></p><p><code>learning_rate = "constant" </code>指学习率为常数，但是一般常数学习率效果不好，需要使用动态变化的学习率（invscaling）</p><p>eta0：<strong>一般取值 0.01 ~ 0.001 为宜</strong></p><h2 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h2><p>思想：输入最原始、最基本的数据，通过模型来进行特征工程，进行更高级的特征学习（多个特征值聚合成一个特征值），然后通过传入的数据来确定合适的参数，让模型更好的拟合数据。</p><p>激活函数：</p><ul><li>作用：增加模型的非线性分割能力，提供鲁棒性（健壮性），缓解梯度消失，加速模型收敛</li><li>常用sigmoid：（0-1）、tanh</li></ul><p>损失函数：</p><p>学习率（leaning rate）：</p><ul><li><p>当学习率设置过小时，收敛过程变得十分缓慢。</p></li><li><p>当学习率设置过大时，梯度可能会在最小值来回震荡，跳过最小值，甚至无法收敛。</p></li></ul><p>参数axis：</p><ul><li>表示操作抽</li><li>axis = 0 ：表纵向</li><li>axis = 1 ：表横向</li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 数据挖掘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库学习笔记（持续更新4.18）</title>
      <link href="2021/04/17/DataBase/"/>
      <url>2021/04/17/DataBase/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章：绪论"><a href="#第一章：绪论" class="headerlink" title="第一章：绪论"></a>第一章：绪论</h1><h1 id="第二章：关系型数据库"><a href="#第二章：关系型数据库" class="headerlink" title="第二章：关系型数据库"></a>第二章：关系型数据库</h1><blockquote><h3 id="1、一些概念"><a href="#1、一些概念" class="headerlink" title="1、一些概念"></a>1、一些概念</h3></blockquote><p>关系：实体与实体之间的联系（可以看做一张二维表）、</p><p>候选码：若关系中的一个属性或属性组的值能够唯一地标识一个元组，且他的真子集不能唯一的标识一个元组，则称这个属性或属性组做候选码。</p><p>主码：若一个关系有多个候选码，则选定其中一个为主码</p><p>主属性：候选码的各个属性成为主属性</p><p>全码：表中的所有属性都是这个表的候选码，则称为全码</p><p><strong>外键（外码）</strong>：<mark>如果公共关键字在一个关系中是主键，那么这个公共关键字被称为另一个关系的外键。</mark></p><p>关系三种类型：①基本表（基本关系）②查询表③视图表</p><p>关系模式：关系的描述称为关系模式（即为表头）</p><blockquote><h3 id="2、关系完整性"><a href="#2、关系完整性" class="headerlink" title="2、关系完整性"></a>2、关系完整性</h3></blockquote><ol><li>实体完整性：实体完整性要求每个数据表都必须有主键，而作为主键的所有字段，其属性必须是独一及<strong>非空值</strong>。</li><li>参照完整性：参照的关系中的属性值必须能够在被参照关系找到或者取空值</li><li>用户定义完整性</li></ol><blockquote><h3 id="3、列级完整性约束和表级完整性约束"><a href="#3、列级完整性约束和表级完整性约束" class="headerlink" title="3、列级完整性约束和表级完整性约束"></a>3、列级完整性约束和表级完整性约束</h3></blockquote><p>列级约束有六种：Primary key（主键）、foreign key（外键） 、 unique（唯一）、 check （检查）、default （默认）、not null/ null（非空/空值 ）<br>表级约束有四种：Primary key（主键）、foreign key（外键） 、 unique（唯一）、 check （检查）</p><p><strong>只能是列级完整性约束</strong>：default （默认）、not null/ null（非空/空值 ）</p><h1 id="第三章：SQL语句"><a href="#第三章：SQL语句" class="headerlink" title="第三章：SQL语句"></a>第三章：SQL语句</h1><blockquote><h3 id="1、数据类型"><a href="#1、数据类型" class="headerlink" title="1、数据类型"></a>1、数据类型</h3></blockquote><p><img src="/2021/04/17/DataBase/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B1.png" alt="数据类型1"></p><p><img src="/2021/04/17/DataBase/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B2.png" alt="数据类型2"></p><blockquote><h3 id="2、基本表的定义、修改与删除"><a href="#2、基本表的定义、修改与删除" class="headerlink" title="2、基本表的定义、修改与删除"></a>2、基本表的定义、修改与删除</h3></blockquote><h5 id="基本操作语句"><a href="#基本操作语句" class="headerlink" title="基本操作语句"></a>基本操作语句</h5><h5 id="表的定义"><a href="#表的定义" class="headerlink" title="表的定义"></a>表的定义</h5><pre><code class="line-numbers language-sql">create table student (    列名 数据类型 列级完整性约束    sno char(9) unique,    ssex char(2),    primary KEY(sno),    foreing key(sno) refferences student(sno));</code></pre><h5 id="表的修改"><a href="#表的修改" class="headerlink" title="表的修改"></a>表的修改</h5><p><img src="/2021/04/17/DataBase/%E4%BF%AE%E6%94%B9%E8%A1%A8.png" alt="修改表"></p><p>[]:可以出现，可以不出现</p><p>&lt;&gt;:一定会出现<code> drop</code>是删除</p><p>注：上述</p><h5 id="表的删除"><a href="#表的删除" class="headerlink" title="表的删除"></a>表的删除</h5><blockquote><h3 id="3、数据查询"><a href="#3、数据查询" class="headerlink" title="3、数据查询"></a>3、数据查询</h3></blockquote><p><strong>数据查询是数据库的<mark>核心操作</mark></strong></p><p>查询的一般格式（块）为：</p><pre><code class="line-numbers language-sql">select  目标列表达式from 表明或视图名where 条件表达式group by 列名 having 选择组的条件order by 列名 asc/desc（升降序）</code></pre><p><mark><strong>执行顺序为</strong></mark>：from→where→select</p><h4 id="一、单表查询："><a href="#一、单表查询：" class="headerlink" title="一、单表查询："></a>一、单表查询：</h4><ol><li><p><strong>选择表中的若干列</strong></p><p>（1）查询指定列</p><pre><code class="line-numbers language-sql">select Sname，Sno，Sdeptfrom Student；</code></pre><p>（2）查询所有列</p><pre><code class="line-numbers language-sql">select *from Student；</code></pre><p>（3）查询经过计算的值</p><p>select语句中的目标表达式可以是表中的<strong>属性列</strong>，也可以是<strong>表达式</strong>，还可以是<strong>字符串常量</strong>、<strong>函数</strong>等</p><p>例：查询全体学生的姓名及其出生年份</p><pre><code class="line-numbers language-sql">select Sname，'Year of Birth' birth，2021-Sage   /*当前年份-年龄*/from Student；</code></pre><p>输出结果为：</p><table><thead><tr><th align="center">Sname</th><th align="center">birth</th><th align="center">2021-Sage</th></tr></thead><tbody><tr><td align="center">李勇</td><td align="center">Year of Birth</td><td align="center">1994</td></tr><tr><td align="center">李晨</td><td align="center">Year of Birth</td><td align="center">1995</td></tr></tbody></table><p>注意：上方代码块中的<code> 'Year of Birth' birth</code>表示将’Year of Birth’列命名为birth，中间用空格号分隔开</p><br></li><li><p><strong>选择表中的若干元组</strong></p></li></ol><p>（1）消除取值重复的行</p><p><strong>distinct</strong>：消除取值重复的行<code> select distinct Sno</code><br></p><p>若没有指定<code>distinct</code>关键字则默认为all</p><p>（2）查询满足条件的元组</p><p><strong>where</strong>：查询满足条件的元组</p><p><img src="/2021/04/17/DataBase/%E5%B8%B8%E7%94%A8%E6%9F%A5%E8%AF%A2%E6%9D%A1%E4%BB%B6.png" alt="常用查询条件"></p><pre><code class="line-numbers language-sql">①比较大小where Sdept='cs'where Sage&lt;20②确定范围where Sage between 20 and 23③确定集合where Sedpt in('CS','MA','IS')④字符分配  %：代表任意长度（可以为0）的字符串。  _：代表任意单个字符where Sname like'_阳%'（查询第二个字为阳的学生）⑤涉及空值的查询where Grade is null⑥多充条件查询使用 and 或者 or，通常 and的优先级高于 or，可以使用括号改变优先级where Sdept='CS'and Sage&lt;20注：实际上 in是多个 or运算符的缩写</code></pre><br><p>   3.<strong>order by语句</strong></p><p>升序：ASC</p><p>降序：DESC</p><p><strong>默认为升序</strong></p><p>例：查询结果按所在的系的系号升序排列，同一系中的学生按年龄降序排列：</p><p><code>order by Sdept，Sage desc</code></p><br><ol start="4"><li><strong>聚集函数</strong></li></ol><p><img src="/2021/04/17/DataBase/DataBase%5C%E8%81%9A%E9%9B%86%E5%87%BD%E6%95%B0.png" alt="聚集函数"></p><p><code>查询学生总人数：select count(distinct Sno)</code></p><p><code>计算平均成绩：select avg(Grade)</code></p><br><ol start="5"><li><strong>group by 语句</strong></li></ol><p>group by子句将查询结果按某一列或多列的值分组，值相等的为一组。</p><pre><code class="line-numbers language-sql">求各个课程号及相应选课人数select Con,count(Sno)from scgroup by Con***查询选修了三门以上课程的学生学号select Snofrom scgroup by Snohaving count()***求选课在三门以上（包括三门）且各门课程均及格的学生的学号及其总成绩，查询结果按总成绩降序列出select sno,sum(score)from scwhere score&gt;=60group by snohaving count(*)&gt;=3order by sum(score)desc执行过程：1.from   取出整个sc2.where  筛选score&gt;=60的元组3.group by  将选出的元组按sno分组4.having  筛选选课三门以上的分组5.select  将选中的组中提取学号和总成绩6.order by  将选取结果排序先用where语句查询效率更高，如果直接用group则将会在sc表中的所有元组进行分组，若先用where则group将在筛选出来的元组中进行分组，提高了查询效率。</code></pre><p>执行顺序为：where→group by→having</p><p>辨析：where作用于<strong>基本表</strong>或者<strong>视图</strong>，having作用于<strong>组</strong></p><br><h4 id="二、连接查询"><a href="#二、连接查询" class="headerlink" title="二、连接查询"></a>二、连接查询</h4><p><strong>1.等值于非等值连接查询</strong></p><p><code>where student.sno = sc.sno</code></p><p>以上比较运算符‘ = ’可以有：=、&gt;、&lt;、&gt;=、&lt;=</p><p><em>此时连接查询的where句子用来连接两个表的条件称为<strong>连接条件</strong>或者*<em>连接谓词</em></em></p><p>*连接谓词中的列名称为<strong>连接字段</strong>（student.sno）</p><br><p><strong>2.自身连接</strong></p><br><p><strong>3.外连接</strong></p><p>定义：有时想以学生标student为主体，列出每个学生的基本情况及选课情况，如果某个学生没有选课，仍把该学生的记录留在结果关系中，而在sc表中的属性值加上NULL，这时就需要外连接。</p><pre><code class="line-numbers language-sql">  </code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库，学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于爬虫爬取基金信息</title>
      <link href="2021/04/11/FundSpyder/"/>
      <url>2021/04/11/FundSpyder/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>  经常看到和听到神经网络这个名词，觉得逼格很高。昨天看了一下机器学习的神经网络算法，是挺高级的，还蛮感兴趣，就是看不懂哈哈哈哈。在B站上看了一个《一小时大话BP神经网络》教我如何从入门到放弃（打脸）。里面涉及的数学统计知识太多了，可惜我是个数学白痴，但是对机器学习确实蛮感兴趣的，神经网络学不明白可以换个简单的机器学习模型试试。后来想着能不能用机器学习预测一下基金走势，随便玩玩不做投资建议，体验一下机器学习的高大上，等我撸出机器学习模型的demo也算是半个涉足过人工智能领域的大学生了哈哈哈哈哈哈哈哈。</p><p>  这篇文章便是为了提供机器学习数据基础——收集基金信息。</p><h2 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h2><ol><li>选择一个好爬的基金网页，这里以天天基金为例（网上关于天天基金爬取教程还蛮多的哈，可能是好抓包）</li><li>打开浏览器的开发工具，切换到network下，点击下一页基金，查看发送的ajax请求。很容易发现有个请求里的jason数据就是我们想要的数据，抓到包就可以开始撸代码了！</li><li>具体代码思路不细说了，看代码注释也比较详细了</li></ol><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><pre><code class="line-numbers language-python">import requestsimport jsonimport reimport pandas as pddf_list = []  #用于存放每页表格for index in range(1,100):  #index是url中的页码，在url中用占位符表示    url = 'http://api.fund.eastmoney.com/f10/lsjz?callback=jQuery1830730414064313736_1618137747657&amp;fundCode=110023&amp;pageIndex={}&amp;pageSize=20&amp;startDate=&amp;endDate=&amp;_=1618137795389'.format(index)    #请求头    headers = {        #防盗链     确定来路        'Referer': 'http://fundf10.eastmoney.com/',        #身份证        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.114 Safari/537.36'    }    # 模拟浏览器发送请求  接收数据    resp = requests.get(url,headers=headers)    html = resp.text    res = re.findall('\((.*?)\)',html) #正则表达式把jquery....去掉    datas = json.loads(res[0])["Data"]["LSJZList"] # res是数组，要用res[0]表示                                                   # json.loads 用于提取字符串中的json格式    # 整理成表的形式    df = pd.DataFrame(datas)    df_list.append(df)  #apend方法：在表末尾添加元素df_data = pd.concat(df_list)df_data.to_csv('易方达医疗保健行业混合 (110023).csv',index=False) #index=false 表示不输出索引值</code></pre><h2 id="爬取结果"><a href="#爬取结果" class="headerlink" title="爬取结果"></a>爬取结果</h2><p>在工程文件路径下生成了一个.csv文件（.csv常用于数据分析）</p><p><img src="/2021/04/11/FundSpyder/1.png" alt="1"></p><p>把这支基金从出生到现在的数据都爬完啦，也就不到2000组（为了便于观看，列名已经修改）</p><p><img src="/2021/04/11/FundSpyder/2.png" alt="2"></p><hr><p>  以上就是数据收集的过程，不知道下篇能不能找到合适的机器学习模型建立，希望能找一个既简单拟合度又不是太离谱的模型吧😚😚😚</p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于java实现自动核查作业程序check</title>
      <link href="2021/03/30/JavaCheck/"/>
      <url>2021/03/30/JavaCheck/</url>
      
        <content type="html"><![CDATA[<h2 id="编写背景"><a href="#编写背景" class="headerlink" title="编写背景"></a>编写背景</h2><p>  大二上学期期末的时候堆了一堆实验报告要交，数据结构2个实验，java4个实验，还有线代截图要收，每次收作业即使通知同学们按规定命名文件但还有很多同学不按规定命名五花八门啥都有，每次收作业都要收个1 个多小时才能收齐，期末都没得时间复习了<span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p>  然后刚好那个学期学了java，对java还比较感兴趣和熟悉，刚一考完试我就开始动手了，边学边写花了我5个小时。整个代码的实现逻辑都是自己想的，然后剩下一下没学过的类和方法在网上学习。之前用python写过一个差不多的十几行的代码实现“微信群接龙”查找名字，这个程序也是借鉴了上次的思想。</p><p>  这是V1.0版本的，功能只有查找没交作业名单的功能，本来第二次更新V2.0的时候加入了自动重命名功能的，但是我今天在打开NetBeans的时候之前写代码都不见了55555，Github上也找不到（我记得当时备份了yue），现在这个代码还是我翻聊天记录找的，之前复制给别的班学委留下来的记录（还好当时发给别人过）。不然真的惨死了，真的一点都想不起来之前怎么写的了。</p><p>  <strong>V2.0</strong>版本虽然新增了自动重命名功能，但是我当时并没有把学号加进去，当时是有思路的，但嫌麻烦是懒得弄了，看需要吧，如果我或者大家需要自动重命名功能的话我到时会在重新写一个完整的。</p><p>  <strong>V3.0</strong>版本我当时是想做一个GUI然后打包的，方便大家使用，本来是想在暑假做的，后来暑假。。。（懂得都懂）结果现在关于GUI的知识也都已经忘完了，随缘<span class="github-emoji"><span>🙏</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f64f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>。如果哪天心血来潮的话再上线吧。</p><p>  话不多说，开干！</p><hr><p>——2021.4.1更新：已经在github上找到V2.0版本的代码了，一下文章是V2.0的文档。代码版本管理真的太重要了，之前的git操作都忘了差不多了，看来得重新再看看git原理了<span class="github-emoji"><span>✊</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/270a.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，顺便吐槽一下github打开真的太慢了，每次打开都好久好久都毛火完了，是不是该考虑转gitee了，有没有用过gitee的伙伴分享一下体验<span class="github-emoji"><span>🙏</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f64f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>🙏</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f64f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><h2 id="使用前的准备工作"><a href="#使用前的准备工作" class="headerlink" title="使用前的准备工作"></a>使用前的准备工作</h2><ol><li>Java开发环境，我们老师推荐我们用的是NetBeans，当然其他的也可以</li><li>一个存放了班级所有名字的.txt文件，注意格式每一行放一个人名</li><li>如果使用重命名功能，千万千万记得备份一份，万一重命名出现了BUG名字就乱套了</li><li>重命名功能可能不太稳定注意备份测试后使用</li></ol><h2 id="代码原理"><a href="#代码原理" class="headerlink" title="代码原理"></a>代码原理</h2><p>  一共两个类：</p><ol><li>Check类：是主类，包含核心查找方法以及人名的读取</li><li>FileNames类：主要包含关于文件操作的属性和方法</li></ol><h4 id="核心查找方法的原理："><a href="#核心查找方法的原理：" class="headerlink" title="核心查找方法的原理："></a>核心查找方法的原理：</h4><p>  第一步：创建全体名单数组（allName[]）</p><p>  用一个.txt文件按行存放每个同学的名字（可以从班级名字表中复制），再按行读取每个名字存到一个字符串数组（allName[]）里，这样就能确保每个名字独占一个数组空间。</p><p>  第二步：创建包含所有文件名的字符串型变量（txt）</p><p>  把下载的同学们的作业文件名也分别存到一个字符串型数组（name[]）里，再把每个文件名取出来集中放到一个字符串变量（txt）中。</p><p>  第三步：在txt中查找allName中的每一个元素</p><p>  使用java String 类中的contain方法即可实现。</p><h4 id="重命名方法原理："><a href="#重命名方法原理：" class="headerlink" title="重命名方法原理："></a>重命名方法原理：</h4><p>等待更新……</p><h2 id="源代码展示"><a href="#源代码展示" class="headerlink" title="源代码展示"></a>源代码展示</h2><p>Check类：（又重新添加了很多注释，应该不难看懂）</p><pre><code class="line-numbers language-java">package check;import java.io.File;import java.io.FileReader;import java.io.IOException;import java.io.LineNumberReader;/** * * @author Yuukyou *///check类public class Check {    String[] allName= new String[50];                                     //数组allNme用于存放完整的班级名单，默认长度为50，可根据具体人数修改    String txt = "";                                                                 //初始化txt变量            /***该方法用于全体人名的读取和写入***/   public  void printByFileReader(String filePath) throws IOException{        File file = new File("E:\\全体名单.txt");                                //打开存放有全体名单的txt文本文件，每一行存放一个人名        FileReader fileReader = new FileReader(file);        LineNumberReader reader = new LineNumberReader(fileReader);  //创建reader对象用于读取每一行的人名        String txt = "";            for(int lines=1;lines&lt;=35;lines++){                              //lines：行数，即读取人名数量，根据具体人数改变        txt = reader.readLine();                                           //txt记录每一次读取到的人名        allName[lines]=txt;                                                 //将每次txt中的人名存放到allName数组       // System.out.println("第"+lines+"行的内容是"+allName[lines]);     //此行用于测试是否存放成功   }        reader.close();        fileReader.close();}      /***check方法用于检测没交作业的同学***/  public void check(String[] all,String txt){                 //txt存放所有文件名            for(int i=1;i&lt;=35;i++){          boolean status =txt.contains(all[i]);                                //每次取全体名单中的一个元素，在txt中查找          if(!status) {              System.out.println(all[i]+"未交作业");}                        //若不存在则输出未交作业名单          }            }       public static void main(String[] args) throws IOException  {        // TODO code application logic here        FileNames Newname = new FileNames();        Newname.FileName("E:\\电商1903作业\\电商1903java实验报告\\实验一");        Check Allname  = new Check();        Allname.printByFileReader("E:\\全体名单.txt");        Allname.check(Allname.allName,Newname.FileName("E:\\电商1903作业\\电商1903java实验报告\\实验一"));          }    }</code></pre><p>FileNames类：（一些被注释掉的代码块是当时写代码时候的其他版本，没注释的是慢慢调式过来能用的版本，大家也可以自己把注释的代码块删了）</p><pre><code class="line-numbers language-java">package check;import java.io.File;import java.io.IOException;/** * * @author Yuukyou */public class FileNames {        static String partaddress = "E:\\电商1903作业\\电商1903java实验报告\\实验二";    static String alladdress = "E:\\全体名单.txt";    static String partName = "";  //调用txt前先使用FileName方法    public FileNames() {    }         public static String FileName(String filePath){        File file =new File(filePath);                        //传入        String[] name = file.list();                           //String[] list() : 返回一个字符串数组，这些字符串指定file路径下的所有文件和目录  ==》列出文件名        String txt="";        for(int i=1;i&lt;name.length;i++){                 //将所有文件名从数组name中取出，放到txt变量中            txt+=name[i];        }      //   测试 System.out.println(txt);        return txt;}           public static String GetFileName(String filePath) {        File file = new File(filePath);        String[] name = file.list();        //String txt="";        for (int i = 0; i &lt; name.length; i++) {            partName += name[i];        }           //System.out.println(partName);        return partName;    }                 public static void Rename(String filePath) throws IOException {        File file = new File(filePath);        String[] filename = new String[50];       // file.renameTo(new File(filePath));        //读取文件夹下的文件，存进一个文件数组        File[] listfile = file.listFiles();              //读取每个文件名称，找下标对应                       String[] name = file.list();       // for(int l=0;l&lt;name.length;l++){       // System.out.println(name[l]);}        int k= 0;        for (k=0; k &lt; name.length; k++) {            filename[k] += name[k];         System.out.println("第"+k+"个文件名"+filename[k]);        }              //  File file = new File(partaddress);     /* FileReader fileReader = new FileReader(file);        LineNumberReader reader = new LineNumberReader(fileReader);        String txt = "";    for(int lines=0;lines&lt;=35;lines++){        txt = reader.readLine();        filename[lines]=txt;        System.out.println("第"+lines+"行的内容是"+filename[lines]);    }*/        //遍历重命名         Check check = new Check();         check.printByFileReader(alladdress);        Check Allname = new Check();        Allname.printByFileReader(alladdress);        //System.out.println();        FileNames partname = new FileNames();        partname.GetFileName(partaddress);        //System.out.println(partname.FileName(partaddress));        for (int i = 1; i &lt; listfile.length; i++) {            if (listfile[i].isFile()) {               // boolean status = false;                for (int j = 0; j &lt;= Allname.allName.length; j++) {                   boolean  status = filename[i].contains(Allname.allName[j]);    // ！BUG：第0个文件名nulldesktop.ini                    // System.out.println(Allname.allName[j]);                    if (status) {                        String newname = "电商1903-java实验二-" + Allname.allName[j] + ".doc";                        File refile = new File(filePath + File.separator + newname);                        listfile[i].renameTo(refile);                        System.out.println("重命名成功"+newname);                        break;                    }                }                /*  if(check.check(Allname.allName,partname.FileName(partaddress)))                 {                 for(int j=1;j&lt;=35;j++){                 //文件定位                 String newname="电商1903-Java实验二"+Check.allName[j]+".doc";                 File refile=new File(filePath+File.separator+newname);                 listfile[i].renameTo(refile);                 }                 }*/                System.out.println(listfile[i] + "重命名成功！");            }        }    }}</code></pre><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>如果你觉得这篇文章对你还有点用的话，欢迎打赏博主一块小饼干(o^^o)没有小饼干留下你的小脚印也行(^з^)，如果有更好的算法或者功能方面的建议也欢迎评论区或者留言区交流哦(^_^)v</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 学委三件套 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Json格式和Ajax的学习</title>
      <link href="2021/03/22/JsonAndAjax/"/>
      <url>2021/03/22/JsonAndAjax/</url>
      
        <content type="html"><![CDATA[<blockquote><p>JSON格式</p></blockquote><p>基本语法：</p><ul><li><p>对象表示为键值对，数据用逗号分隔</p></li><li><p>花括号保存数组对象</p></li><li><p>方括号保存数组</p><p><strong>JSON 键值对</strong>是用来保存 JavaScript 对象的一种方式，和 JavaScript 对象的写法也大同小异，键/值对组合中的键名写在前面并用双引号 “” 包裹，使用冒号 : 分隔，然后紧接着值：</p><pre><code class="line-numbers language-json">{"name": "QinJiang"}{"age": "3"}{"sex": "男"}</code></pre></li></ul><p><strong>JSON与JavaScript的关系：</strong></p><p>   JSON 是 JavaScript 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串。</p><p><strong>JSON 和 JavaScript 对象互转</strong></p><p>要实现从JSON字符串转换为JavaScript 对象，使用 JSON.parse() 方法：</p><pre><code>var obj = JSON.parse('{"a": "Hello", "b": "World"}');//结果是 {a: 'Hello', b: 'World'}</code></pre><p>要实现从JavaScript 对象转换为JSON字符串，使用 JSON.stringify() 方法：</p><pre><code>var json = JSON.stringify({a: 'Hello', b: 'World'});//结果是 '{"a": "Hello", "b": "World"}'</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Json </tag>
            
            <tag> Ajax </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于IAR&amp;STM32调试过程问题记录</title>
      <link href="2021/03/19/IAR/"/>
      <url>2021/03/19/IAR/</url>
      
        <content type="html"><![CDATA[<h2 id="IAR烧录时提示没有设备连接"><a href="#IAR烧录时提示没有设备连接" class="headerlink" title="IAR烧录时提示没有设备连接"></a>IAR烧录时提示没有设备连接</h2><p>当连接好电脑鼠并且检查线路没有问题并且驱动程序正常运行时，点击调试，出现“STM32 no emulator connected via USB…..”提示。</p><p>在网上查找了很多资料基本上4个问题：</p><pre><code class="line-numbers language-供电">1、板子一定要供电！2、ST-LINK是否接触不良确保ST-LINK跟板子连接完好3、按住reset点击download硬件和接线都没问题情况下，这时候可能是SWD的引脚被占用了，或者被禁用了。这时候ST-LINK自然无法通过SWD跟板子通信，所以才会提示No Target connected。所以，这时候按住reset，再点击download，再松开reset。原理就是在程序运行到SWD引脚占用之前，把新的程序烧录进去，抢个时间差。但是这招不是每次都管用，有概率性失败。但是不要紧，我们还有第四招4、boot0 接高电平download正常程序后，再接回低电平，即可烧录————————————————版权声明：本文为CSDN博主「小康师兄」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/kangweijian/article/details/107564868```</code></pre><p>但是这4个方法我都试过一遍<strong>还是没有解决。</strong></p><p>最后看到一篇文章受到启发：<a href="https://blog.csdn.net/c1063891514/article/details/81545601">https://blog.csdn.net/c1063891514/article/details/81545601</a></p><p>解决方法与链接文章没太大关系</p><p>是这篇文章最后两张图引起了我的注意，便想是不是连接设备接口没设置对，设置好接口果然设备连接成功了！！！具体步骤如下：</p><p>1、右键点击demo-Debug，选择Opotions</p><p><img src="/2021/03/19/IAR/1.jpg" alt="1"></p><p>2、选择Debugger设置Driver为图示<img src="/2021/03/19/IAR/2.jpg" alt="2"></p><p>3、点击Download设置，将图示√上即可<img src="/2021/03/19/IAR/3.jpg" alt="image-3"></p><p>点击OK后IAR即可正常识别设备，记得<em><strong>编译</strong></em>后，再烧录！！</p><p>电脑鼠连接不上电脑这个问题真的困扰了我们队伍好久！找老师又找学长又找老师又找学长,头发都快给我薅没了！体会还蛮深刻的，网络真的是个好东西，不懂的多问问别人，虽然别人不一定能帮你解决问题，但是会给你启发！<br><br>最后发个喜报！我买的域名终于过审了！！！！普天同庆！！！<br></p><p>之前因为重重问题来来回回和腾讯打了5、6个电话，修改又驳回4次信息，最后腾讯还是冒着风险帮我把备案提交给管局的，真的差点我都不想要这个域名了，心底一块石头终于落地了。<br><br></p><p>如果你觉得这篇文章解决了你的问题或者说对你还有用的话，欢迎打赏博主一块小饼干⸜₍๑•⌔•๑ ₎⸝。</p><p>如果有什么问题可以在评论区底下留言哦，欢迎交流<em>⸜( •ᴗ• )⸝</em><br><br><br><br></p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IAR </tag>
            
            <tag> STM32 </tag>
            
            <tag> 电脑鼠 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown&amp;hexo&amp;Git常用操作</title>
      <link href="2021/03/05/GitAndHexo/"/>
      <url>2021/03/05/GitAndHexo/</url>
      
        <content type="html"><![CDATA[<h1 id="常用Hexo-amp-Git操作"><a href="#常用Hexo-amp-Git操作" class="headerlink" title="常用Hexo &amp; Git操作"></a>常用Hexo &amp; Git操作</h1><h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><h3 id="使用hexo新建文章"><a href="#使用hexo新建文章" class="headerlink" title="使用hexo新建文章"></a>使用hexo新建文章</h3><br><ul><li>新建文章命令 ：<code>$ hexo new &lt;title&gt;</code></li></ul><p>输入上行命令之后在post文件夹出现两个文件，title文件夹用于存放图片资源；md文件则用于书写文章。</p><ul><li>在md文件头部信息补充分类信息：<code>categories:</code>(注意空格)</li></ul><p><strong>md常用语法：</strong></p><ol><li><p>标题：<code>#H1    一级标签...</code></p></li><li><p>无序列表：<code>+ 123  /- 123  /* 123</code></p></li><li><p>有序列表：<code>1. ABC  /2. ABC  /3.ABC</code></p></li><li><p>引用说明区块：<code>&gt; 引用内容</code></p></li><li><p>代码块：<code>1.少量代码，单行使用，直接用`包起来   2.大量代码需要多行使用，用三个`包裹起来</code></p></li><li><p>在文章中插入图片：<code>![1](./title/1.jpg)</code></p></li><li><p>链接：<code>链接的文字放在[]中，链接地址放在随后的()中，链接也可以带title属性，链接地址后面空一格，然后用引号引起来:[简书](https://www.jianshu.com "创作你的创作")</code></p></li><li><p>分割线：</p><pre><code class="line-numbers language-markdown">---- - -------**** * *******____ _ _______</code></pre></li><li><p>首行缩进</p><pre><code class="line-numbers language-markdown">&amp;emsp; or &amp;#8195;  表示一个全角的空格&amp;emsp;&amp;emsp; 两个全角的空格（用的比较多）</code></pre></li></ol><br><h3 id="hexo常用命令"><a href="#hexo常用命令" class="headerlink" title="hexo常用命令"></a>hexo常用命令</h3><p><code> $ hexo clean</code> </p><p>清除缓存和已生成静态文件<br></p><br><p><code>$ hexo g</code></p><p>生成静态文件<br></p><br><p><code> $ hexo s</code></p><p>启动服务器<br></p><br><p><code>$ hexo d</code></p><p>部署网站<br></p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><h3 id="使用git管理代码版本"><a href="#使用git管理代码版本" class="headerlink" title="使用git管理代码版本"></a>使用git管理代码版本</h3><h3 id="git常用命令"><a href="#git常用命令" class="headerlink" title="git常用命令"></a>git常用命令</h3><p><code>$ git init</code></p><p>在当前目录新建一个git代码库</p><br><p><code>$ git status</code></p><p>查看跟踪状态</p><br><p><code>$ git add flies（.）</code></p><p>把本地文件添加到暂存区（.  添加当前目录所有文件到暂存区）</p><br><p><code>$ git commit </code></p><p>添加到<strong>本地</strong>仓库</p><br><p><code> $ git reset &lt;commit ID&gt;</code></p><p>回退：将提交的文件重新 变成红色（未提交状态）可以通过git log查看ID</p><br><p><code> $ git log</code></p><p>查看版本日志</p><p><code> $ git reflog</code></p><p>查看所有的操作日志和ID，包括已经撤回的记录</p><p>一些参数：</p><p>–hard：不保存所有变更，所有变更都会回到commit ID对应的状态</p><p>–soft：保留变更且更内容处于Staged</p><p>–mixed：保留变更且变更内容处于Modified）（不带参数默认是mixed）</p><p><code>$ git push</code></p><p>添加到远程仓库</p><br><p><code>$ git pull</code></p><p>从远程拉到本地仓库，并合并</p><br><p><code>$ git branch</code></p><p>查看分支</p><br><p><code>$ git branch name</code></p><p>新建name分支</p><br><p><code>$ git checkout -b &lt;name&gt;&lt;template&gt;</code></p><p>新建以template为模板，以name为名字的一个分支，并切换到该分支</p><p>如果template模板来自远程仓库则需要在前面加origin</p><br><p><code> $git checkout -d [branch name]</code> </p><p>删除分支</p><br><p><code> $git checkout -d [branch name]</code> </p><p>删除分支</p><br><p><code> $git fetch</code></p><p>查看远程仓库信息，执行该语句后可通过<code>$git checkout &lt;name&gt;</code> 切换到模板来自远程仓库的本地分支</p><p><code> $ git merge &lt;分支名&gt;</code> </p><p>合并分支</p><p><code> $ git remote add origin &lt;远程地址&gt;</code> </p><p>关联到远程仓库</p><h3 id="使用git多人协作"><a href="#使用git多人协作" class="headerlink" title="使用git多人协作"></a>使用git多人协作</h3><ol><li>从服务器将版本库克隆至本地（git clone ）</li></ol><p><code> $ git clone &lt;仓库地址&gt;</code> </p><ol start="2"><li>文件修改之后提交至暂存区</li></ol><p><code> $ git add .</code> </p><ol start="3"><li>将暂存区的文件更新至本地仓库</li></ol><p><code> $ git commit -m"说明信息"</code> </p><ol start="4"><li>将远程仓库拉至本地，确保拿到的是最新版的代码，防止覆盖别人的更新</li></ol><p><code>$ git pull</code> </p><ol start="5"><li>将本地仓库上传到远程仓库</li></ol><p><code>$ git push</code> </p><br>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git&amp;hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进来随便聊聊叭</title>
      <link href="2021/03/05/MyFristBlog/"/>
      <url>2021/03/05/MyFristBlog/</url>
      
        <content type="html"><![CDATA[<p>非常欢迎你来到我的博客，这是我的第一篇文章，我也不懂要写什么，就随便唠一下吧。</p><h4 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h4><p>​        我先介绍一下我自己吧，00后的大表哥，游手好闲无业网民，最喜欢吃大柳州的螺蛳粉，长板板混（蹲个大佬一起磕招），喜欢摄影，代码小菜鸡，秃头预备选手，只喜欢写一些实用代码（有好的点子一起交流）。</p><h4 id="建站故事"><a href="#建站故事" class="headerlink" title="建站故事"></a>建站故事</h4><p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本来说20年的寒假要搭建这个个人博客的，当时非常幸运地在南京参与电影《非常替身》制作，担任实习剪辑助理一职，由于工作太“闲”了，我就开始对未来思考，于是乎就有了搭建这个博客的想法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一开始我是想搭一个我们学校滑板论坛的，但是考虑到实用性和推广难度就放弃了。然后在寒假断断续续的看了一点vue，学了几天myslq，flag就开始立起来了，说是这个寒假完成，然后回到家就开始玩了。。。剩最后10天开学了，我才抓紧起来，建站过程挺曲折的，一个方面是因为我的拖延，另一个方面源自于自我的不肯定，东一下学js，西一下学vue，学了一下mysql，又想下学期就有数据库的课，现在会不会太着急了，想学Spring又怕跳的太快，只知道wordpress又懒得学php……就这样一直和自己的想法对抗中，好像我就是纠结体本身，终于最后被逼到什么都来不及学，直接建站！事实证明在建站过程中学习，比先学再做来得更高效直接，回顾以前自学python、html、css的时候也是等不及慢慢啃知识点，直接实战了。本在在Gitpage上面部署过一次博客（已经能用的那种），后来又想买个服务器和域名玩一下，就又重新整了一套。</p><p>就好像在博客首页的“送你一颗子弹”一样</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后选择了hexo这个框架也是蛮幸运的，他刚好是基于前端三剑客的框架，不用再学php了（投降）。但是它的缺点是没有直接管理网站文章的后台，随便吧。</p><blockquote><p>就这样这个博客就稀里糊涂的建了起来。</p></blockquote><h4 id="立一些flag"><a href="#立一些flag" class="headerlink" title="立一些flag"></a>立一些flag</h4><blockquote><p>虽然说这个博客是搬别人的框架，但是二次开发我也费了蛮多心血的，改动还是蛮多的，修饰博客的界面就像装潢自己小窝一样。</p></blockquote><p>Flag1：以后在这个博客上面主要发一些学习笔记吧，也会发一些书摘，随笔，可能会上线说说板块</p><p>Flag2：等我学会调用API了会上线识别qq账号留言评论功能，大家就能有头像啦！</p><p>Flag3：“什么时候心血来潮”上线滑板、相册、vlog板块</p><p>Flag4：每周更新两篇文章（！！！一定要做到！！！）</p><p>Flag5：给自己的网站设计一个logo并且用PS或者AI做出来（应该不难）</p><p>Flag6：把写过的代码都上传到github上</p><h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这么辛苦码字就是为了见你一面，留下你的脚印吧我的朋友,非常欢迎评论区或者留言互动！期待你的留言！</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flag </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
