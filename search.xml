<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>codePrint</title>
      <link href="2023/01/31/codePrint/"/>
      <url>2023/01/31/codePrint/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>bable工作流程</title>
      <link href="2023/01/25/bableFlow/"/>
      <url>2023/01/25/bableFlow/</url>
      
        <content type="html"><![CDATA[<h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d96c0f3c11d40339d42cd3d6e06b693~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="2B6C3E75-4B91-4E49-867B-3D3D084964B8.png"></p><h4 id="关键内容"><a href="#关键内容" class="headerlink" title="关键内容"></a>关键内容</h4><pre><code class="line-numbers language-css">@babel/parser ES6+ ==&gt; original AST@babel/traverse 使用深度优先遍历，original AST ==&gt; transformed AST@babel/generator transformed AST ==&gt; ES5/ES3@babel/parser&nbsp;&nbsp;&nbsp;&nbsp;词法分析&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将ES6+转换为一些列tokens&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于无效的文字或章节报告错误&nbsp;&nbsp;&nbsp;&nbsp;语法分析&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将一系列tokens转换为一个AST&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自动分号插入&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于位置错误的tokens报告错误&nbsp;&nbsp;&nbsp;&nbsp;语义分析&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;检查这个AST是否遵循ECMAScripts 所有静态的规则，即early error，如重复定义__proto__、在严格模式中使用with。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于重复定义的变量、块作用域符号、暴露未定义的变量等。@babel/traverse&nbsp;&nbsp;&nbsp;&nbsp;声明式遍历&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用深度优先遍历，enter()是默认入口，exit()是出口。&nbsp;&nbsp;&nbsp;&nbsp;支持动态的抽象语法树遍历&nbsp;&nbsp;&nbsp;&nbsp;scope 分析&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;收集不同的scopes，如应用程序级别、函数级别、块级作用域级别&nbsp;&nbsp;&nbsp;&nbsp;收集声明&nbsp;&nbsp;&nbsp;&nbsp;收集引用&nbsp;&nbsp;&nbsp;&nbsp;实用程序&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nodes(AST)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Srarch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Introspection&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Evaluation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Insertion&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Replacment&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bindings(SCOPE)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Validation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tracking&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Renaming@babel/generator&nbsp;&nbsp;&nbsp;&nbsp;在必要的地方插入括号或缩进、注释等@babel/core&nbsp;&nbsp;&nbsp;&nbsp;被@babel/cli babel-loader parcel等使用&nbsp;&nbsp;&nbsp;&nbsp;从babel.config.js等配置文件中合并配置&nbsp;&nbsp;&nbsp;&nbsp;收集预设和插件并将他们传递给@babel/traverse@babel/types&nbsp;&nbsp;&nbsp;&nbsp;nodes 验证，用于AST node的验证和判断&nbsp;&nbsp;&nbsp;&nbsp;nodes 构建函数，在AST转换为JSON时，使得构建函数的参数名称与待生成的json 字段的value一一对应。    ······</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> bable </tag>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue自定义指令</title>
      <link href="2022/11/28/vueCustomInstruction/"/>
      <url>2022/11/28/vueCustomInstruction/</url>
      
        <content type="html"><![CDATA[<h2 id="自定义指令注册方式"><a href="#自定义指令注册方式" class="headerlink" title="自定义指令注册方式"></a>自定义指令注册方式</h2><p>Vue 自定义指令有全局注册和局部注册两种方式。先来看看注册全局指令的方式，通过 <code>Vue.directive( id, [definition] )</code> 方式注册全局指令。然后在入口文件中进行 <code>Vue.use()</code> 调用。</p><p>批量注册指令，新建 <code>directives/index.js</code> 文件</p><pre><code class="line-numbers language-js">import copy from './copy'import longpress from './longpress'// 自定义指令const directives = {  copy,  longpress,}export default {  install(Vue) {    Object.keys(directives).forEach((key) =&gt; {      Vue.directive(key, directives[key])    })  },}</code></pre><p>在 <code>main.js</code> 引入并调用</p><pre><code class="line-numbers language-js">import Vue from 'vue'import Directives from './JS/directives'Vue.use(Directives)</code></pre><h2 id="自定义指令的钩子函数"><a href="#自定义指令的钩子函数" class="headerlink" title="自定义指令的钩子函数"></a>自定义指令的钩子函数</h2><p>一个指令定义对象可以提供如下几个钩子函数 (均为可选)：</p><ul><li><strong>bind</strong>：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置</li><li><strong>inserted</strong>：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</li><li><strong>update</strong>：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 。</li><li><strong>componentUpdated</strong>：指令所在组件的 VNode 及其子 VNode 全部更新后调用。</li><li><strong>unbind</strong>：只调用一次，指令与元素解绑时调用。</li></ul><p>​    那么这几个钩子函数怎么使用呢？先来看看钩子函数的几个参数吧。指令钩子函数会被传入以下参数:</p><ul><li><strong>el</strong>: 指令所绑定的元素，可以用来直接操作 DOM，就是放置指令的那个元素。</li><li><strong>binding</strong>: 一个对象，里面包含了几个属性，这里不多展开说明，官方文档上都有很详细的描述。</li><li><strong>vnode</strong>：Vue 编译生成的虚拟节点。</li><li><strong>oldVnode</strong>：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。</li></ul><h2 id="手写一个防抖自定义指令"><a href="#手写一个防抖自定义指令" class="headerlink" title="手写一个防抖自定义指令"></a>手写一个防抖自定义指令</h2><p>需求：防止按钮在短时间内被多次点击，使用防抖函数限制规定时间内只能点击一次。</p><p>思路：</p><ol><li>定义一个延迟执行的方法，如果在延迟时间内再调用该方法，则重新计算执行时间。</li><li>将事件绑定在 click 方法上。</li></ol><pre><code class="line-numbers language-js">const debounce = {  inserted: function (el, binding) {    let timer    el.addEventListener('click', () =&gt; {      if (timer) {        clearTimeout(timer)      }      timer = setTimeout(() =&gt; {        binding.value()      }, 1000)    })  },}export default debounce</code></pre><p>使用：给 Dom 加上 <code>v-debounce</code> 及回调函数即可</p><pre><code class="line-numbers language-js">&lt;template&gt;  &lt;button v-debounce="debounceClick"&gt;防抖&lt;/button&gt;&lt;/template&gt;&lt;script&gt;export default {  methods: {    debounceClick () {      console.log('只触发一次')    }  }}&lt;/script&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>virtualScrollThrottle</title>
      <link href="2022/11/19/virtualScrollThrottle/"/>
      <url>2022/11/19/virtualScrollThrottle/</url>
      
        <content type="html"><![CDATA[<h2 id="背景知识之事件循环"><a href="#背景知识之事件循环" class="headerlink" title="背景知识之事件循环"></a>背景知识之事件循环</h2><p>详见<a href="https://link.juejin.cn/?target=https://html.spec.whatwg.org/multipage/webappapis.html%23event-loops">HTML规范</a></p><p>这里只挑与本文相关的讲</p><p>在事件循环中定义了很多任务源，比如鼠标键盘等输入操作的用户交互任务源</p><p>一次点击操作，其实包含多个输入操作（mousedown,mouseup,click），都添加到相同的任务源队列中，进而产生多轮的事件循环，其表现就是执行相关元素的事件回调（宏任务）</p><p>宏任务执行后，后面就是微任务队列和更新渲染阶段</p><p>每轮事件循环可能是非常快的，每秒执行事件循环的次数可能大于60次</p><p>受硬件刷新率影响，我们只要保证 fps 达到最大硬件刷新率(比如60)即可，因此不需要每轮事件循环都更新渲染</p><p>视图渲染的时机又是什么时候呢？update rendering 发生在本轮事件循环的 microtask 队列被执行完之后，也就是说<strong>执行任务的耗时会影响视图渲染的时机</strong>。通常浏览器以每秒 60 帧（60fps）的速率刷新页面，据说这个帧率最适合人眼交互，大概16.7ms 渲染一帧，所以如果要让用户觉得顺畅，单个 macrotask 及它相关的所有 microtask 最好能在16.7ms 内完成。但也不是每轮事件循环都会执行视图更新，浏览器有自己的优化策略，例如<strong>把几次的视图更新累积到一起重绘，重绘之前会通知 requestAnimationFrame 执行回调函数</strong>，也就是说 <strong>requestAnimationFrame 回调的执行时机是在一次或多次事件循环的UI render阶段</strong>。</p><p>最后的总结：</p><p>1、每轮事件循环分为3个步骤： a) 执行 macrotask 队列的一个任务</p><p>b) 执行完当前 microtask 队列的所有任务</p><p>c) UI render</p><p>2、浏览器只保证 requestAnimationFrame 的回调在重绘之前执行，没有确定的时间，何时重绘由浏览器决定</p><h2 id="输入事件与滚动事件的执行时机"><a href="#输入事件与滚动事件的执行时机" class="headerlink" title="输入事件与滚动事件的执行时机"></a>输入事件与滚动事件的执行时机</h2><p>对于输入事件，其执行时机为每轮事件循环的任务执行阶段，这个事件是不受刷新率影响的，<strong>每秒的执行次数可能多于60次</strong></p><p>为什么谈这个呢，因为这个与滚动事件(scroll)回调的执行时机不一致</p><p>按照 HTML 规范，滚动事件回调在 UI Render 阶段的某个步骤中进行，而不是单独的一个任务源</p><p>也就是说，滚动事件回调受渲染时机影响，仅执行更新渲染时才执行该回调。</p><p>换句话说，该事件自带节流。</p><p>举个例子验证下输入事件和更新渲染的执行时机</p><pre><code class="line-numbers language-js">document.addEventListener("mousemove",function(){  let start = performance.now()  console.log("mousemove:",start)  requestAnimationFrame(function(t){console.log("ui render:",start,t)})})// 结果就是可能输出几轮 mousemove 然后执行一次 ui render -- 清空 rAF 回调队列(输出多次 ui render)/*mousemove: 4091.025000088848ui render: 4091.025000088848 4077.594mousemove: 4098.845000029542ui render: 4098.845000029542 4094.278mousemove: 4110.160000040196mousemove: 4115.5349999899045ui render: 4110.160000040196 4110.962ui render: 4115.5349999899045 4110.962mousemove: 4123.810000019148mousemove: 4130.160000058822ui render: 4123.810000019148 4127.719ui render: 4130.160000058822 4127.719*/</code></pre><p>说明更新渲染有一定的间隔，至少是 1/60 的间隔，而输入任务没有此限制</p><p>所以，以下代码是没有效果的，因为该回调已经自带节流了.</p><pre><code class="line-numbers language-js">document.addEventListener("scroll",function(e){  requestAnimationFrame(function(t){    //执行scroll具体逻辑  })})</code></pre><h2 id="什么时候滚动需要做节流"><a href="#什么时候滚动需要做节流" class="headerlink" title="什么时候滚动需要做节流"></a>什么时候滚动需要做节流</h2><p>利用节流可以减少回调的执行次数，使得固定时间周期内只执行一次</p><p>刚才提到，滚动事件自带节流，节流的时间周期是与渲染时机相关</p><p>判断是否需要额外的节流的关键是：当前的节流规则，是否大部分回调的执行都能让用户受益</p><p>如果是动画效果，实时绘制的界面等，则不需要额外的节流了。</p><p>以长列表为例，每次执行滚动回调，会计算新的渲染列表项及滚动偏移位置。如果应用更大时间周期的节流，会出现某一帧出现滚动但界面没有更新的情况，让用户感觉产生卡顿。</p><p>而其他比较复杂的业务逻辑，不能在短时间内得到反馈的，则需要额外进行节流</p><p>以滚动懒加载图片为例</p><p>由于每秒的滚动回调的执行次数可能达到60次，而每次执行都需要去获取当前处于视区的占位图并发起图片请求</p><p>而这大部分回调的执行，用户是不能受益的，所以我们可以提高节流的时间周期，比如 500ms 这样</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>滚动事件已自带节流，只有一些特定的业务逻辑才需要额外进行更高时间周期的节流</p>]]></content>
      
      
      
        <tags>
            
            <tag> 节流 </tag>
            
            <tag> RequestAnimationFrame </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试准备</title>
      <link href="2022/10/13/projectPrepare/"/>
      <url>2022/10/13/projectPrepare/</url>
      
        <content type="html"><![CDATA[<p><strong>面试前重点看：</strong></p><ol><li><a href="#HN869"><strong>浏览器渲染原理</strong></a><strong>（栅格化、分块）++</strong></li><li><a href="#5035abb3"><strong>V8引擎原理</strong></a><strong>++</strong></li><li><a href="#scrKU"><strong>前端渲染历程</strong></a><strong>（ssr、csr、预渲染、异构SSR、esr原理）</strong></li><li><strong>如何封装一个组件</strong></li><li><a href="#FpvhS"><strong>虚拟滚动列表原理</strong></a></li><li><strong>还知道哪些</strong><a href="#mID5d"><strong>性能优化方案</strong></a></li><li><a href="#UDBuz"><strong>移动端适配</strong></a></li><li><strong>diff算法原理</strong></li></ol><p><strong>手写reduce、all、节流不太熟</strong></p><p>计划放前面</p><p>12/19</p><p>考虑增加自定义指令：实现防抖节流，按钮级别权限校验，输入框自动聚焦</p><p>11.18 看柯里化和浏览器渲染过程 包括位图栅格化..</p><p>叨叨姐字节面经常规深度面经：<a href="https://www.nowcoder.com/discuss/954312">https://www.nowcoder.com/discuss/954312</a></p><p>ssr、ssg、Faas</p><p>11.8</p><p>考虑是否增加<strong>手写虚拟滚动列表</strong></p><ol><li>margin 穿透和重叠</li><li>BFC、IFC、FFC、GFC</li><li>重构<strong>ssr</strong>、异构ssr、流式渲染、孤岛渲染</li><li>intersectionAPI 没有占用js线程？</li><li>瀑布流式组件开发</li><li><em>cros</em></li><li><em>postman存在跨域？</em></li><li><em>netlink</em></li><li><em>离屏渲染（***</em>双缓存区***<em>？） 浏览器刷新频率怎么刷新？双缓存原理</em></li><li><em>canvas——cluster</em></li><li><a href="https://www.cnblogs.com/powertoolsteam/p/15213573.html">https://www.cnblogs.com/powertoolsteam/p/15213573.html</a></li><li><em>VUE源码设计顶层视角</em></li><li><em>双缓存区</em></li></ol><p>11.4看到 treeShaking和…..compone区别</p><p>11.2 写到实习经历的encodeuri  //  <a href="https://www.baidu.com/link?url=XrNqgqNRE7v6-_Z9XLeha7nxkUNaquICA6mrObCiDTAayWWHlzGp55elDz-sW3ranhyEzldJGkszHcoaAfKBcq&amp;wd=&amp;eqid=deb3d76f0000a16d0000000363621669">关键渲染路径</a></p><p>11.1</p><p>1、先把简历上的八股重新整理一遍，保证简历上的八股都能答好——然后可以慢慢投小公司简历。</p><p>2、过一遍之后然后再上牛客上看一下新的八股查缺补漏。</p><p>3、切记东看看细看看，导致焦虑内耗啥也没复习好。</p><p>10.21</p><p>1、以面试为中心背题</p><p>10.20/10.21</p><ul><li><strong>1、LRU算法</strong></li><li><strong>2、各种排序时间空间复杂度 手写</strong></li><li>3、UDP原理</li><li>4、CDN原理</li><li>5、OSI 7层模型</li></ul><ol><li><p>缓存策略的头部看一下</p></li><li><p>http3.0补充一下</p></li><li><p>http 告一段落（后面可以看一下http状态码）</p></li></ol><ul><li>简历补充：虚拟滚动列表的实现原理、还有vue预渲染的插件（prerender-sap）原理准备一下</li></ul><ol><li><p>简历上的知识点更改一下，一定要自己非常有把握的</p></li><li><p>b站山月老师视频常看一下</p></li><li><p><strong>开启新第一轮计划</strong>——基础八股查缺补漏（中小厂offer保底）</p></li><li><p>把牛客上所有的面试题过一遍。</p></li><li><p><strong>开启第二轮计划</strong>——复习数据结构！（大厂必考）</p></li></ol><h1 id="面经收集"><a href="#面经收集" class="headerlink" title="面经收集"></a>面经收集</h1><p>大厂汇总：<a href="https://www.nowcoder.com/discuss/1062791">https://www.nowcoder.com/discuss/1062791</a></p><p>汇总：<a href="https://www.nowcoder.com/discuss/713375">https://www.nowcoder.com/discuss/713375</a></p><p>超全汇总：<a href="https://www.yuque.com/boyyang/buosw0/idgxnb">https://www.yuque.com/boyyang/buosw0/idgxnb</a></p><p>机械大猛子：<a href="https://www.nowcoder.com/discuss/828616">https://www.nowcoder.com/discuss/828616</a></p><p>用友：<a href="https://www.nowcoder.com/discuss/738797">https://www.nowcoder.com/discuss/738797</a> （用友面经，建议全部看过一遍nowcode上的）</p><h1 id="内推收集"><a href="#内推收集" class="headerlink" title="内推收集"></a>内推收集</h1><p>吉比特&amp;雷霆：<a href="https://www.nowcoder.com/discuss/1025341">https://www.nowcoder.com/discuss/1025341</a></p><p>秋招&amp;实习汇总： <a href="https://mp.weixin.qq.com/s/HMI62gGxC2ReTPfpvV8ixA">https://mp.weixin.qq.com/s/HMI62gGxC2ReTPfpvV8ixA</a></p><p>汇总：<a href="https://docs.qq.com/sheet/DQ3lCc0ZEV25pV0V1?tab=BB08J2">https://docs.qq.com/sheet/DQ3lCc0ZEV25pV0V1?tab=BB08J2</a></p><p>汇总表格 <a href="https://c.r.sn.cn/sSCBjH">https://c.r.sn.cn/sSCBjH</a></p><h1 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h1><p>​    面试官您好，我叫陈勇强，来自天津商业大学信息工程学院电子商务专业，我面试的岗位是前端开发岗位。</p><p>​    我将从校园经历、实习经历、项目经历3个方面进行自我介绍。</p><p>​    校园经历方面：我从大一下学期开始加入了维护学校官网的技术社团，从那时候开始慢慢接触前端了。在校园里各方面也算是个积极分子，当过班干，参加过许多比赛，也有一点收获，拿过一个国奖，三个省奖，还发过一篇SCI，是关于机器学习混合优化算法改进与应用的。</p><p>​    实习经历方面：有过两段实习经历，一个是大二暑假，当时主要负责的是北京林业大学园林学院官网的首页制作，根据设计稿精准还原页面视图；第二个就是在大三的暑假在联想云参与了两个项目需求周期。目前主要的技术栈是vue2、vue3学过一些。</p><p>​    项目经历方面：做过三个项目，一个是帮我们学院党建办公开发的智慧党建系统，一个文章后台管理项目，还有一个仿喜马拉雅的微信小程序。</p><p>​    首先一个前端项目最基本的要素就是<em><strong>业务</strong></em>，基础功能得实现了：</p><p>​    在项目里我实现了</p><ol><li><p>三个项目都实现了登录功能——&gt;我是用的技术的Token认证技术相比cookies、session，防范了csrf (跨站请求伪造) 攻击。（提问点：<a href="#VUE"><strong>cookies、session、token、jwt</strong></a><strong>认证机制区别和好处？CSRF攻击？</strong>）</p></li><li><p>基础功能包括，数据表格展示，表单提交，文件上传与导出，<strong>搜索框历史</strong>功能。</p></li><li><p>移动端适配（提问点：<strong>多种适配方案优缺点，避免使用100VH</strong>）</p></li><li><p>角色权限管理</p></li></ol><p>​    其次，前端作为直接与用户接触的一端，也承载了<strong>交互体验</strong>的功能，我们需要以用户的角度去考虑功能<strong>交互体验</strong>，同时可以在一定程度上弥补性能方面的不足。</p><p>​    在交互方面：</p><ol><li><p>通过骨架屏让使得去提升交互</p></li><li><p>使用组件的动画，提升交互细节</p></li><li><p>通过nprogress这个小进度条提升交互感</p></li><li><p>通过betterScroll使得页面滑动变得更加的丝滑</p></li></ol><p>最后一个是<strong>性能优化</strong>方面：</p><p>​    我通过：</p><ul><li><p>我用<strong>prerender-spa-plugin做了预渲染，</strong>提高网站的SEO，以及将首屏加载速度提升了500ms</p></li><li><p>通过 vue-virtual-scroller 插件进行<a href="#JwsG5"><strong>长列表渲染优化</strong></a>，有效提高网页加载速度。</p></li><li><p>通过<a href="#6083b68d"><strong>路由懒加载</strong></a>实现首屏优化、按需加载</p></li><li><p>通过封装<a href="#47aef26e"><strong>防抖</strong>、<strong>节流</strong></a>函数进行搜索框关联以及<a href="#vaF2L"><strong>图片懒加载</strong></a>性能优化。</p></li><li><p>通过<a href="#lCTyS"> CDN</a> 引入外部资源来减少首屏渲染时间</p></li><li><p>通过约束自身代码规范，减少对dom操作，减少重绘和重排；及时对闭包中的对象进行清除。</p></li></ul><p>​    前端作为服务端和用户沟通的桥梁，我认为在完成基本业务的基础上，不仅要从用户的角度思考交互，还要在一定程度上辅助服务端分担性能压力。</p><p>综合以上业务、交互、性能优化三个方面，就是我在项目中职责，也是我认为前端的职责所在。</p><h1 id="自我介绍中面试官可能的切入点"><a href="#自我介绍中面试官可能的切入点" class="headerlink" title="自我介绍中面试官可能的切入点"></a>自我介绍中面试官可能的切入点</h1><ol><li><a href="#a43e34a0">实习期间</a>做过什么稍微复杂的需求</li><li><a href="#owWZg">token认证技术</a>，<a href="#f351b28d">csrf</a></li><li><a href="#Cz5iw">单点登录</a>你是如何实现的，还有什么方案—cookies、认证中心</li><li>搜索框历史怎么实现？—数组序列化（JSON.stringfy）后存入localStorage，在页面destroyed是存入localStorage</li><li><a href="#UDBuz">移动端适配</a> -&gt;视口-&gt;mata标签-&gt;常规方案</li><li>骨架屏如何配，原理</li><li><a href="#rsKoj">预渲染原理</a>，其他解决方案</li><li><a href="#mID5d">性能指标数据</a>怎么查看？还知道哪些性能指标</li><li><a href="#FpvhS">虚拟滚动长列表</a>渲染的原理</li><li><a href="#6083b68d">路由懒加载原理</a></li><li>手写防抖、节流</li></ol><h1 id="实习经历"><a href="#实习经历" class="headerlink" title="实习经历"></a>实习经历</h1><h2 id="场景题-实习期间有没有做过什么复杂的需求-实践"><a href="#场景题-实习期间有没有做过什么复杂的需求-实践" class="headerlink" title="场景题(实习期间有没有做过什么复杂的需求) + 实践"></a>场景题(实习期间有没有做过什么复杂的需求) + 实践</h2><h3 id="1、父子组件生命周期问题"><a href="#1、父子组件生命周期问题" class="headerlink" title="1、父子组件生命周期问题"></a>1、父子组件生命周期问题</h3><p>​    场景：父组件在 mounted 发送异步请求获取数据，子组件在mounted获取父组件请求的数据，无法获取。</p><p>​    自我探索与思考：然后我就猜是不是请求的时间比钩子函数间触发的时间长了，我就给mounted 这个函数加上了 async await，发现还是获取不到。我就猜想是不是会不会跟父子组件生命有关，就自己写了个小demo测试了一下，结果发现还真是这个原因。</p><p>​    原因：父子组件生命周期顺序问题。</p><p>​    父beforeCreate -&gt; 父created -&gt; 父beforeMount -&gt; 子beforeCreate -&gt; 子created -&gt; 子beforeMount -&gt; 子mounted -&gt; 父mounted-&gt;</p><p>​    父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated-&gt;父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed</p><p>​    <strong>子组件的 mounted 先触发，再到父组件的mounted所以获取不到。</strong></p><p><strong>（引申）1、那么获取请求一般写在哪里？</strong></p><p><strong>created</strong>： 如果将 API 请求放到 created 里的话，实际上是这样一个过程：</p><p><img src="https://img2022.cnblogs.com/blog/2718076/202202/2718076-20220223231908634-1883404271.png" alt="img"></p><p>也就是说，再发送 API 请求以后，就会产生 2 个分支，代码逻辑比较混乱。</p><p><strong>mounted</strong>：再来分析 mounted 里的情况</p><p>可以看到整个逻辑是这样的：<br>created =&gt; mounted =&gt;  mounte组件首次渲染 =&gt; API请求 =&gt; 获取到数据 =&gt; update组件重新渲染</p><p>可以看到，没有分支，只有一个流程。</p><p>再来分析 mounted 里的情况</p><p>如果在mounted<a href="https://so.csdn.net/so/search?q=%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0&amp;spm=1001.2101.3001.7020">钩子函数</a>中请求数据可能导致页面<strong>闪屏问题</strong></p><p><strong>（引申）2、组件生命周期</strong></p><h3 id="2、右键复制分享路径"><a href="#2、右键复制分享路径" class="headerlink" title="2、右键复制分享路径"></a>2、右键复制分享路径</h3><p>场景：右键点击分享，复制分享链接，连接粘贴到粘贴板，在地址栏粘贴跳转</p><p>​    右键菜单（mixin混入，增加配置项）——&gt;点击复制连接（发送请求获取分享链接）复制到剪切板——&gt;链接粘贴至 url 跳转 ——&gt;重定向到功能页，发送请求根据短链解析目的链接地址</p><h3 id="3、首页进入"><a href="#3、首页进入" class="headerlink" title="3、首页进入"></a>3、首页进入</h3><p>场景：</p><p>林乐文 10-8 16:47:29<br>我记得之前就是排查 正常接口报401都回登录页 看接口报错一堆401但是没触发回登录,后来查那个接口查promise.all发现接口报错没反应</p><p>林乐文 10-8 16:48:12<br>中间好像也走了些弯路 以为是隐私协议弹窗写太早了 发现注了也没用</p><h3 id="4、实习联调的时候有没遇到过跨域，怎么解决的？"><a href="#4、实习联调的时候有没遇到过跨域，怎么解决的？" class="headerlink" title="4、实习联调的时候有没遇到过跨域，怎么解决的？"></a>4、实习联调的时候有没遇到过跨域，怎么解决的？</h3><p><strong>vue框架的跨域</strong></p><p>​    通过 vue-cli脚手架搭建项目，可以通过 webpack设立一个本地服务器作为请求的代理对象，通过该服务器转发请求至目标服务器，得到结果后再转发给前端。但是在最终项目发布上线时，如果 web应用和接口服务器不在一起仍会产生跨域问题。解决方法是，可以在vue.config.js文件中新增以下代码： <strong>devServer</strong></p><pre><code class="line-numbers language-javascript">module.exprots = {    devServer: {        host: '127.0.0.1', // 本地地址        port: 8084, // 端口号        open: true, // 配置项目在启动时自动在浏览器打开        proxy: {            '/api' : { // '/api'是代理标识，一般是每个接口前的相同部分                target: "http://xxx.xxx.xx.xx:8080", // 请求地址，一般是服务器地址                changeOrigin: true, // 是否进行跨域                pathRewrite: { // pathRewrite的作用是把请求接口中的 '/api'替换掉，一般是替换为空""                    '^/api':""                }            }        }    }}</code></pre><p>公司正真开发写法，在.env文件里配置proxyTarget，在vue.config.js中配置 判断是否使用当前代理。</p><p><img src="https://gitee.com/Yuukyou/pic/raw/master/image-20221010220342438.png" alt="img"></p><h3 id="5、解决文件路径包含特殊字符无法访问"><a href="#5、解决文件路径包含特殊字符无法访问" class="headerlink" title="5、解决文件路径包含特殊字符无法访问"></a>5、解决文件路径包含特殊字符无法访问</h3><p>场景：1、新建文件夹名称包含特殊字符  —&gt; 2、点进新建文件夹报错 —&gt; 3、控制台参数错误</p><h5 id="1、路由路径中-、-等特殊字符。"><a href="#1、路由路径中-、-等特殊字符。" class="headerlink" title="1、路由路径中 %、# 等特殊字符。"></a>1、路由路径中 %、# 等特殊字符。</h5><ul><li>当URL路径参数中存在%时会报错URI malformed；当 # 作为路由参数时会被识别为用于分隔 URI 组件的标点符号</li><li>原因：vue-router内部使用decodeURIcomponent转码，通过%进行解析，如果字符串中存在%，则会出现问题</li><li>决方式：将路径的 % 使用转义字符 %25表示，将 # 用转义字符 %23 表示</li></ul><h5 id="2、JavaScript的四个URL编码-解码方法"><a href="#2、JavaScript的四个URL编码-解码方法" class="headerlink" title="2、JavaScript的四个URL编码/解码方法"></a>2、JavaScript的四个URL编码/解码方法</h5><ul><li><p>encodeURI</p><p>encodeURI 是对整个 URI 进行转义，将 URI 中的非法字符转换为合法字符，所以对于一些在 URI 中有特殊意义的字符不会进行转义。 </p></li></ul><p>​    将元字符和语义字符之外的字符都进行转义，一般用于知道该URL只用于完整的URL时使用、</p><ul><li>encodeURIComponent</li></ul><p>​    将除了语义字符之外的字符进行转义，包括元字符，因此，它的参数通常是URL的路径或参数值，而不是整个URL。</p><p>  encodeURIComponent 是对 URI 的组成部分进行转义，所以一些特殊字符也会得到转义。</p><ul><li>decodeURI</li></ul><p>​    还原转义后的URL，是encodeURI方法的逆运算。</p><ul><li>decodeURIComponent（此方法可以还原被转义的 url）</li></ul><p>​    还原转义后的URL片段。是encodeURIComponent方法的逆运算。</p><ul><li><p>以下字符不会被encodeURIComponent进行编码</p></li><li><ul><li>不会编码 ASCII 字母和数字</li><li>不会编码 ASCII 标点符号进行编码： - _ . ! ~ * ‘ ( ) </li><li>不会编码用于分隔 URI 组件的标点符号 ：;/?:@&amp;=+$,#</li><li>ps：特殊符号需要用 转义序列进行替换</li></ul></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/27759506/1667443774995-0d019449-024c-4559-ad18-935a6164c4c7.png" alt="img"><br>encodeURI 是对整个 URI 进行转义，将 URI 中的非法字符转换为合法字符，所以对于一些在 URI 中有特殊意义的字符不会进行转义。 encodeURIComponent 是对 URI 的组成部分进行转义，所以一些特殊字符也会得到转义。 escape 和 encodeURI 的作用相同，不过它们对于 unicode 编码为 0xff 之外字符的时候会有区别，escape 是直接在字符的 unicode 编码前加上 %u，而 encodeURI 首先会将字符转换为 UTF-8 的格式，再在每个字节前加上 %。</p><p><strong>公司解决方案：</strong></p><pre><code class="line-numbers language-javascript">export function getMyEncodeURI (path) {  path = encodeURI(path).replace(/&amp;/g, '%26').replace(/#/g, '%23').replace(/\+/g, '%2B')  return path}</code></pre><h4 id="URL-和-URI-的区别？"><a href="#URL-和-URI-的区别？" class="headerlink" title="URL 和 URI 的区别？"></a>URL 和 URI 的区别？</h4><p>URI: Uniform Resource Identifier      指的是统一资源标识符 </p><p>URL: Uniform Resource Location        指的是统一资源定位符 </p><p>URN: Universal Resource Name          指的是统一资源名称 </p><p>URI 指的是统一资源标识符，用唯一的标识来确定一个资源，它是一种抽象的定义，也就是说，不管使用什么方法来定义，只要能唯一的标识一个资源，就可以称为 URI。 URL 指的是统一资源定位符，URN 指的是统一资源名称。</p><p><strong>URL 和 URN 是 URI 的子集，URL 可以理解为使用地址来标识资源，URN 可以理解为使用名称来标识资源。</strong> </p><p>详细资料可以参考： <a href="https://www.zhihu.com/question/21950864">《HTTP 协议中 URI 和 URL 有什么区别？》</a> <a href="http://web.jobbole.com/83452/">《你知道 URL、URI 和 URN 三者之间的区别吗？》</a> <a href="https://segmentfault.com/a/1190000006081973">《URI、URL 和 URN 的区别》</a></p><h2 id="开放性思考题"><a href="#开放性思考题" class="headerlink" title="开放性思考题"></a>开放性思考题</h2><h3 id="你认为阅读源码对工作有帮助吗"><a href="#你认为阅读源码对工作有帮助吗" class="headerlink" title="你认为阅读源码对工作有帮助吗"></a>你认为阅读源码对工作有帮助吗</h3><p>（千万不要说自己没读过源码或者没有用！结合具体场景说）</p><p>​    答：</p><p>​    首先，第一个是能<strong>提升</strong>对框架使用的<strong>熟练度</strong>；阅读源码能让我们对框架有深刻的理解，让我们更好的运用它。举个栗子，在初学 vue2 的时候，我很容易犯的一个错误，就是直接通过this.属性 定义一个新的数据，然后就会出现数据无法动态更新的问题，排查半天到网上搜索才知道如果要这样写的话必须要用vue.set()方法才能是数据变成响应式。那么为什么要这样写呢？如果你知道它的响应式原理底层用的是defineproperty(),这个方法是无法动态监听到对象属性的新增和删除，那么你在写代码的时候就会避开这个问题，避免了不必要的排查bug时间，提高工作效率。</p><p>​    第二个，学习到源码书写代码的风格和技巧；如何让代码看起来更简洁干练。比如说它这里用到闭包，变量持久化怎么做的，什么时候释放。还有巧用 &amp;&amp;（与）运算符，三目运算符，一行就能解决的代码，如果自己写的话可能就是笨拙的三行if else。还要在以前在用 vuex-persistedstate 插件给VUEX做持久化的时候，读过它的源码，发现它用的也是 localStorage，不过它还用了一个vuex的API surbcribe() ,如果我自己写的的话可能就是在每个mutation手动存 localStorage看起来不太友好。 surbcribe() API就是学到的好用的写法。</p><p>​    (第三个)为了更好的改造轮子，比如我们公司有一次遇到一个客户，他们那有一个长列表功能反馈用起来很卡，本来计划那个场景下应该渲染的数据最多不会超过100条的，结果他们那超过1000条，我们公司组件库是基于ant design封装的，vue2.0版本的ant中没有对长列表做虚拟滚动，vue3.0版本的底层自动做了虚拟滚动优化，我们就需要把虚拟滚动这个技术封装到vue2.0中。</p><p>​    第三个，学习架构设计模式，设计思想；学习开源大牛们是如何运用设计模式的，然后运用到我们开发的项目中，使我们的项目的模块更易于扩展。</p><h1 id="项目性能优化"><a href="#项目性能优化" class="headerlink" title="项目性能优化"></a>项目性能优化</h1><h3 id="1、vue-virtual-scroller-长列表渲染优化解决的什么问题？实现原理是什么？"><a href="#1、vue-virtual-scroller-长列表渲染优化解决的什么问题？实现原理是什么？" class="headerlink" title="1、vue-virtual-scroller 长列表渲染优化解决的什么问题？实现原理是什么？"></a>1、vue-virtual-scroller 长列表渲染优化解决的什么问题？实现原理是什么？</h3><h4 id="传统的解决方案和问题"><a href="#传统的解决方案和问题" class="headerlink" title="传统的解决方案和问题"></a>传统的解决方案和问题</h4><p>传统的解决方案是是用数据懒加载 + 节流</p><p>存在问题：一开始挺顺畅，但是到后面随着数据的加载越来越多，dom结构变得越来越多，加载新数据的时候就会变得卡顿，因为插入dom元素会造成重排和重绘。</p><p>最佳解决方案：虚拟滚动列表</p><h4 id="实现原理："><a href="#实现原理：" class="headerlink" title="实现原理："></a>实现原理：</h4><p>设置一个固定高度的可视窗口，在页面上只渲染可视窗口内的数据。每个item有一个固定的高度，可是窗口内渲染的数据条数是固定的。通过监听滚动事件，获取滚动上卷的高度，scrolltop / 每个item 的高度  = 滚过去的条数  = startIndex    ——&gt;     使用slice方法根据index切分数据进行渲染</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/23076793/1646878621979-f895e89b-2ee0-4c05-b453-bdc22aff22ed.png" alt="img"></p><p>此处为语雀内容卡片，点击链接查看：<a href="https://www.yuque.com/leyulv-uvbgk/yf80ad/vrpi9t#cHNKM">https://www.yuque.com/leyulv-uvbgk/yf80ad/vrpi9t#cHNKM</a></p><h3 id="2、-预渲染是什么？如何使用-prerender-spa-plugin"><a href="#2、-预渲染是什么？如何使用-prerender-spa-plugin" class="headerlink" title="2、 预渲染是什么？如何使用?prerender-spa-plugin"></a>2、 预渲染是什么？如何使用?prerender-spa-plugin</h3><h4 id="单页面和多页面区别以及各自痛点？"><a href="#单页面和多页面区别以及各自痛点？" class="headerlink" title="单页面和多页面区别以及各自痛点？"></a>单页面和多页面区别以及各自痛点？</h4><p>多页面应用：</p><ol><li>由前端绘制好页面套死数据，后端根据页面套模板。</li><li>客户端请求页面，每次返回对应的html、js等，<strong>导致页面切换加载缓慢，用户体验不好</strong></li><li>无法实现转场动画</li><li>开发成本较低，但重复代码较多</li><li><strong>维护成本高</strong></li><li>seo好</li><li>不用暴露接口，安全性较好、</li></ol><p>两个痛点：1、<strong>页面加载缓慢  2、后期维护成本高</strong></p><p>单页面应用</p><ol><li>第一次请求返回所有html、css、js文件</li><li>返回的html里一开始只有一个app标签，<strong>不利于SEO</strong></li><li>页面通过js框架渲染<strong>，压力在客户端，</strong>在 js 渲染页面的时候会存在一定时间<strong>白屏</strong></li><li>使用前端路由的方式进行页面切换，数据向后端请求，页面无刷新用户体验好</li></ol><p>两个痛点：1、<strong>不利于SEO</strong> 2、<strong>首屏加载慢</strong>/白屏时间</p><h4 id="单页面痛点及解决方案对比"><a href="#单页面痛点及解决方案对比" class="headerlink" title="单页面痛点及解决方案对比"></a>单页面痛点及解决方案对比</h4><p>解决方案：预渲染、SSR</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/27759506/1667706469910-91eef854-750b-4268-ac3b-3f44adec005e.png" alt="img"></p><h4 id="为什么要做预渲染"><a href="#为什么要做预渲染" class="headerlink" title="为什么要做预渲染?"></a>为什么要做预渲染?</h4><p>做SEO是需要获取到页面真实内容的，比如h1是什么h2标签的内容是什么。但是客户端渲染时做不到的，我们使用的是vue，react、js进行渲染，因为一开始的时候只有一个脚本app标签，然后我们通过写一大堆的vue组件，把这些组件挂载到这个app标签上，本质上这个页面是什么内容都没有的，只有app标签。seo拿到这个空页面没有内容解析。</p><h4 id="预渲染原理？"><a href="#预渲染原理？" class="headerlink" title="预渲染原理？"></a>预渲染原理？</h4><p>先在自己的服务器装一个无头浏览器，去请求单页面应用，让无头浏览器渲染单页面应用，然后再把渲染好的，有内容的页面返回给浏览器进行SEO。</p><p>启动启动一个本地的服务器</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/27759506/1666792276621-22162e73-bfa5-430a-8e56-eb5c68f7e09f.png" alt="img"></p><p><a href="https://juejin.cn/post/6844903924265123853">https://juejin.cn/post/6844903924265123853</a></p><h4 id="SSR-Nuxt原理"><a href="#SSR-Nuxt原理" class="headerlink" title="SSR Nuxt原理"></a>SSR Nuxt原理</h4><p>不过，对于我来说VUE服务端渲染最大优势是它既能拥有直输型web应用的能力<br>还能享受MVVM前后端分离框架开发的效率与便利<br>最妙的是<strong>SSR首屏渲染输出后，前端就被VUE接管，优雅地变成了单页应用</strong></p><p><a href="https://juejin.cn/post/6844903920590913544#heading-0">https://juejin.cn/post/6844903920590913544#heading-0</a></p><p><strong>webpack打包构建</strong></p><p>我们的服务端代码和客户端代码通过webpack分别打包，生成Server Bundle和Client Bundle，<strong>前者会运行在服务器上通过node生成预渲染的HTML字符串，发送到我们的客户端以便完成初始化渲染</strong>；而客户端bundle就自由了，初始化渲染完全不依赖它了。<strong>客户端拿到服务端返回的HTML字符串后，会去“激活”这些静态HTML，是其变成由Vue动态管理的DOM，以便响应后续数据的变化。</strong></p><p><strong>剖析运行流程</strong></p><p>到这里我们该谈谈ssr的程序是怎么跑起来的了。首先我们得去构建一个vue的实例，也就是我们前面构建流程中说到的app.js做的事情，但是这里不同于传统的客户端渲染的程序，我们<strong>需要用一个工厂函数去封装它，以便每一个用户的请求都能够返回一个新的实例，也就是官网说到的避免交叉污染了</strong>。</p><p>然    后我们可以暂时移步到服务端的entry中了，这里要做的就是拿到当前路由匹配的组件，调用组件里定义的一个方法（官网取名叫asyncData）拿到初始化渲染的数据，而这个方法要做的也很简单，就是<strong>去调用我们vuex store中的方法去异步获取数据</strong>。</p><p>接下来node服务器如期启动了，跑的是我们刚写好的服务端entry里的函数。在这里还要做的就是将我们刚刚构建好的Vue实例渲染成HTML字符串，然后将拿到的数据混入我们的HTML字符串中，最后发送到我们客户端。</p><p>打开浏览器的network，我们看到了初始化渲染的HTML，并且是我们想要初始化的结构，且完全不依赖于客户端的js文件了。再仔细研究研究，里面有初始化的dom结构，有css，还有一个script标签。script标签里把我们在服务端entry拿到的数据挂载了window上。原来只是一个纯静态的HTML页面啊，没有任何的交互逻辑，所以啊，现在知道为啥子需要<strong>服务端跑一个vue客户端再跑一个vue了，服务端的vue只是混入了个数据渲染了个静态页面，客户端的vue才是去实现交互的</strong>！</p><p><a href="https://juejin.cn/post/6844903609667158030">https://juejin.cn/post/6844903609667158030</a></p><h4 id="前端渲染的发展历程"><a href="#前端渲染的发展历程" class="headerlink" title="前端渲染的发展历程"></a>前端渲染的发展历程</h4><p><a href="https://juejin.cn/post/7002151207762395172">https://juejin.cn/post/7002151207762395172</a></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/27759506/1667804840390-25bec219-a525-4493-8d06-df6d40ecd673.png" alt="img"></p><p>边缘渲染：<a href="https://juejin.cn/post/7002151207762395172%EF%BC%88%E5%AD%97%E8%8A%82%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84%EF%BC%89">https://juejin.cn/post/7002151207762395172（字节前端架构）</a></p><p>后面随着边缘计算的发展，由于CDN节点距离用户更近，有更短网络延时的优势，我们可以将页面进行动静拆分，将静态内容缓存在CDN先快速返回给用户，然后在CDN节点上发起动态内容的请求，之后将动态内容与静态部分以流的形式进行拼接，从而进一步提高了用户的首屏加载时间，尤其在边缘地区或者弱网环境也有能拥有很好的用户体验，此外还减少原先SSR服务器压力。</p><p>流式渲染：<a href="https://juejin.cn/post/6953819275941380109">https://juejin.cn/post/6953819275941380109</a></p><p><strong>CSR与SSR的共同点是，先返回了 HTML</strong>，因为 HTML 是一切的基础。</p><p>之后 CSR 先返回了 js，后返回了 data，在首次渲染之前页面就已经可交互了。</p><p>而 SSR 先返回了 data，后返回 js，页面在可交互前就完成了首次渲染，使用户可以更快的看到数据。</p><p>但是，先返回 js 还是先返回 data，这两者并不冲突，不应该是阻塞串行的，而应该是并行的。</p><p>它们的阻塞导致了在 FP 与 TTI 之间总有一段时间效果不如人意。为了使它们并行，来进一步提高渲染速度，我们需要引入<strong>流式服务端渲染（Steaming Server Side Render）渲染</strong> 的概念。</p><p>为什么要叫“流式服务端渲染”？是因为返回html的那个请求的相应体是<strong>流（stream）</strong>，流中会先返回如骨架屏/fallback的同步HTML代码，再等待数据请求成功，返回对应的异步HTML代码，都返回后，才会关闭此HTTP连接。</p><p>本地渲染：NSR</p><p><a href="https://www.cnblogs.com/qianduanpiaoge/p/14887276.html">https://www.cnblogs.com/qianduanpiaoge/p/14887276.html</a></p><p>孤岛渲染</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="3、单点登录"><a href="#3、单点登录" class="headerlink" title="3、单点登录"></a>3、单点登录</h3><p>单点登录本质是要实现登陆一次可以在不同网站点上保存登录状态，那么我们在正常情况下是通过cookie + session来保持会话状态的，如果有办法将存有登录信息的cookie在其他站点访问的话，那么我们理论上就能实现单点登录。</p><p>而<strong>cookie是不能跨域访问</strong>的 ——解决办法：将cookie的domain域设置为二级域名。</p><p><strong>SSO解决方案</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/webp/27759506/1667527175783-9f6682fa-8ce8-46bc-8fe3-b04b461846bc.webp" alt="img"></p><ol><li>用户访问系统1的受保护资源，系统1发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数</li><li>sso认证中心发现用户未登录，将用户引导至登录页面（带系统1地址）</li><li>用户输入用户名密码提交登录申请</li><li>sso认证中心校验用户信息，创建用户与sso认证中心之间的会话，称为全局会话（这时该会话信息保存到cookie中），同时创建授权令牌</li><li>sso认证中心带着令牌跳转到最初的请求地址（系统1）</li><li>系统1拿到令牌，去sso认证中心校验令牌是否有效</li><li>sso认证中心校验令牌，返回有效，注册系统1</li><li>系统1使用该令牌创建与用户的会话，称为局部会话(seesion)，返回受保护资源</li><li>用户访问系统2的受保护资源</li><li>系统2发现用户未登录，跳转至sso认证中心，并将自己的地址和之前和sso认证中心的会话cookie信息作为参数</li><li>sso认证中心发现用户已登录，跳转回系统2的地址，并附上令牌</li><li>系统2拿到令牌，去sso认证中心校验令牌是否有效</li><li>sso认证中心校验令牌，返回有效，注册系统2</li><li>系统2使用该令牌创建与用户的局部会话，返回受保护资源</li></ol><p>作者：小伙子vae<br>链接：<a href="https://juejin.cn/post/7044328327762411534">https://juejin.cn/post/7044328327762411534</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h3 id="3、防抖和节流具体场景如何使用"><a href="#3、防抖和节流具体场景如何使用" class="headerlink" title="3、防抖和节流具体场景如何使用"></a>3、防抖和节流具体场景如何使用</h3><h3 id="4、文件上传下载流程？图片如何压缩？"><a href="#4、文件上传下载流程？图片如何压缩？" class="headerlink" title="4、文件上传下载流程？图片如何压缩？"></a>4、文件上传下载流程？图片如何压缩？</h3><ul><li><strong>要用canvas实现前端的图片压缩，有几个步骤。</strong><br>1.拿到图片元素。<br>2.绘制一个空白的canvas。<br>3.将图片绘制在canvas上。<br>4.将canvas转成base64。（这里调用的方法可以实现压缩，base64就可以直接放入src或者传入后端、转成别的格式传输等。）<br><strong>上代码</strong></li></ul><pre><code class="line-numbers language-html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;  &lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;    &lt;title&gt;Document&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;img src="test.png" style="width: 200px; height: 400px;" id="imgBefore"&gt;    &lt;img src="" id="imgafter"&gt; //待会压缩完的图片放入这里。  &lt;/body&gt;&lt;/html&gt;&lt;script&gt;  var img = document.getElementById('imgBefore') //拿到图片元素  img.setAttribute("crossOrigin",'Anonymous') //这句话并不是必要的，如果你的图片是一个网络链接，  //那么canvas绘制时可能会报错，是因为跨域的安全性问题。报错时加上就对了。  img.onload = ()=&gt;{ //要确保图片已经加载完才进行绘制，不然拿不到图片元素会绘制出全黑的区域，就是失败。    var width = img.width    var height = img.height    var canvas = document.createElement('canvas');    var ctx = canvas.getContext('2d');    canvas.width = width;    canvas.height = height; //以上几步都在绘制一个canvas    ctx.drawImage(img,0,0,width,height);//将图片绘制进去，这里第一个参数可以接受很多格式，    //以元素为例子，详情https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/drawImage    var base64 = canvas.toDataURL('image/jpeg',0.2); //第二个参数为压缩的比例，越小越模糊。0-1    document.getElementById('imgafter').src = base64  }&lt;/script&gt;</code></pre><p><a href="https://blog.csdn.net/weixin_44765930/article/details/109367274?ops_request_misc=%7B%22request_id%22:%22166686952916782248528287%22,%22scm%22:%2220140713.130102334..%22%7D&amp;request_id=166686952916782248528287&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-109367274-null-null.142%5Ev62%5Epc_search_tree,201%5Ev3%5Eadd_ask,213%5Ev1%5Econtrol&amp;utm_term=canvas">https://blog.csdn.net/weixin_44765930/article/details/109367274?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166686952916782248528287%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=166686952916782248528287&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2<del>all</del>sobaiduend~default-1-109367274-null-null.142^v62^pc_search_tree,201^v3^add_ask,213^v1^control&amp;utm_term=canvas</a></p><p>图片压缩&amp;spm=1018.2226.3001.4187</p><h3 id="5、图片懒加载如何实现"><a href="#5、图片懒加载如何实现" class="headerlink" title="5、图片懒加载如何实现"></a>5、图片懒加载如何实现</h3><h4 id="为什么要使用图片懒加载"><a href="#为什么要使用图片懒加载" class="headerlink" title="为什么要使用图片懒加载"></a>为什么要使用图片懒加载</h4><p>在一些图片比较多的网站（比如说大型电商网站）图片是非常多的，如果我们在打开网页的一瞬间就把网站的所有图片加载出来，很有可能造成卡顿和白屏的现象，用户体验变得极其的差.<br>因为图片真的很多，一瞬间就把网站的所有图片加载出来浏览器短时间内根本处理不完，但是我们打开网站的那一瞬间仅仅只能看到视口内的图片，这时候去加载网页最底部的图片是非常浪费资源和没有必要的，所以遇到这种情况使用懒加载技术就显得尤为必要了。</p><h4 id="如何实现图片懒加载"><a href="#如何实现图片懒加载" class="headerlink" title="如何实现图片懒加载"></a>如何实现图片懒加载</h4><p><strong>1、计算图片是否进入可视区域</strong></p><pre><code>**获取窗口显示区的高度：window.innerHeight****获取图片到视窗顶部的距离：使用元素的 getBoundingClientRact().top**</code></pre><p>图片可以看见时条件：<strong>图片到视窗顶部的距离 &lt;</strong> <strong>窗口显示区的高度</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/27759506/1666168597358-2d01310f-8dca-472c-9156-ac9d99560d6e.png" alt="img"></p><p><strong>2、将图片的 src 真正的值用 data-src(自定义属性)进行替换</strong></p><pre><code class="line-numbers language-javascript">// 获取所有图片节点const images = document.querySelectAll('img')// 给window添加滚动监听事件windows.addEventListener('scroll', (e) =&gt; {  // 遍历每个图片，获取他们到视窗顶部的距离  images.forEach(image =&gt; {    const imageTop = image.getBoundingClientRect().top    // 如果图片在可视区则将src替换    if(imgageTop &lt; window.innerHeight) {      // 获取 data-src 属性值      const data_src = imge.getAttribute('data-src')      // 将 data-src 值赋给src      image.setAttribute('src', data_src)    }  })})</code></pre><p><strong>然鹅,这种方法并不是最佳解决方案</strong></p><p>他存在弊端,他的性能不是很好,sroll 会被触发很多次,<strong>即使图片已经加载了还是会不断触发事件,非常消耗资源.</strong></p><p><strong>补充新增API:IntersectionObserver</strong></p><p>它是浏览器提供的API,字面意思交叉观察—m目标元素和可是窗口会产生交叉区域。</p><p>需要考虑兼容性。</p><pre><code class="line-numbers language-javascript">// 接收两个参数 callback：可见性变化时的回调函数；option: 配置对象const observer = new InterSectionObserver()// 给元素添加监听事件---observe()方法observer.observe(DOM节点)// 取消监听---unobserve()方法（当图片加载完成时，便不必观察）observer.unobserve(DOM节点)// callback函数接受的参数entry.isIntersecting属性可以判断元素是否在可视区域const images = document. querySelectorAll("img");// callback 函数接收一个entries数组——添加了observe事件的元素const callback = entries =&gt; {    entries. forEach( entry =&gt;{        if( entry.isIntersecting ){            const image =entry.target;            const data_src= image.getAttribute(• 'data-src')             image.setAttribute('src', data-src);            observer.unobserve( image );            console.log("触发"）；        }    }}const observer = new IntersectionObserver( callback)images. forEach( image =&gt; {    observer.observe( image );}):</code></pre><h3 id="6、首屏优化方案"><a href="#6、首屏优化方案" class="headerlink" title="6、首屏优化方案"></a>6、<strong>首屏优化方案</strong></h3><p><strong>1、路由懒加载</strong></p><p><strong>2、vue.config.js 修改 productionSourceMap 为 false</strong></p><pre><code>productionSourceMap: false</code></pre><p><strong>3、首屏请求优化</strong></p><p>vue 脚手架默认开启了 <strong>preload 与 prefetch</strong>，当我们项目很大时，这个就成了首屏加载的最大元凶了</p><ul><li>preload 与 prefetch 都是一种资源预加载机制；</li><li>preload 是预先加载资源，但并不执行，只有需要时才执行它；</li><li>prefetch 是意图预获取一些资源，以备下一个导航/页面使用；</li><li>preload 的优先级高于 prefetch。</li></ul><pre><code class="line-numbers language-javascript">//vue.config.jschainWebpack(config) {  config.plugins.delete('preload') // 删除默认的preload  config.plugins.delete('prefetch') // 删除默认的prefetch}作者：呛再首链接：https://juejin.cn/post/7117515006714839047来源：稀土掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre><p><strong>4、图片压缩；</strong></p><p><strong>webp为什么小？比png、jpg小30%  –<strong>有损WebP压缩使用</strong>预测编码</strong>来编码图像，VP8视频编解码器使用相同的方法来压缩视频中的关键帧。预测编码使用相邻像素块中的值来预测块中的值，然后仅对差异进行编码。 </p><p><strong>5、配置使用 CDN 方式引入资源库</strong></p><p><strong>6、开启gzip压缩</strong></p><p><strong>7、Treeshaking</strong></p><p>具体来说，在 webpack 项目中，有一个入口文件，相当于一棵树的主干，入口文件有很多依赖的模块，相当于树枝。实际情况中，虽然依赖了某个模块，但其实只使用其中的某些功能。通过 tree-shaking，将没有使用的模块摇掉，这样来达到删除无用代码的目的。</p><p>本质通过减少js文件体积达到优化，因为js 文件通常需要通过请求获取。<br>    原理：ES6模块依赖关系是确定的，和运行时的状态无关，可以进行可靠的静态分析，这就是tree-shaking的基础。简单来说这就是所谓的Tree Shaking: 基于 ES Module 规范的 Dead Code Elimination 技术，它会在运行过程中静态分析模块之间的导入导出，确定 ESM 模块中哪些导出值未曾其它模块使用，并将其删除，以此实现打包产物的优化。<br>链接：<a href="https://juejin.cn/post/6844903544756109319">https://juejin.cn/post/6844903544756109319</a></p><p><strong>为什么有了treeshaking 和</strong> <strong>babel-plugin-component</strong> </p><p>首先，<strong>在老版本的<strong><strong>webpack</strong></strong>中是不支持将代码编译成为<strong><strong>Es module</strong></strong>模块的</strong>，所有就会导致一些组件库编译后的代码无法使用Tree Shaking进行处理。(因为它编译出来的代码压根就不是ES Module呀！)</p><p>所以老版本组件库中，比如element-ui中借用babel-plugin-component，老版本ant-design使用babel-plugin-import进行分析代码从而实现Tree Shaking的效果。</p><p> [<a href="https://blog.csdn.net/lunahaijiao/article/details/121368958?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166761258316782429762790%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=166761258316782429762790&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-121368958-null-null.142%5Ev63%5Econtrol,201%5Ev3%5Eadd_ask,213%5Ev1%5Econtrol&amp;utm_term=treeshaking%20%E5%92%8Ccomponent&amp;spm=1018.2226.3001.4187%5D">https://blog.csdn.net/lunahaijiao/article/details/121368958?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166761258316782429762790%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=166761258316782429762790&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-121368958-null-null.142^v63^control,201^v3^add_ask,213^v1^control&amp;utm_term=treeshaking%20%E5%92%8Ccomponent&amp;spm=1018.2226.3001.4187]</a>(<a href="https://blog.csdn.net/lunahaijiao/article/details/121368958?ops_request_misc=%7B%22request_id%22:%22166761258316782429762790%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&amp;request_id=166761258316782429762790&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-121368958-null-null.142%5Ev63%5Econtrol,201%5Ev3%5Eadd_ask,213%5Ev1%5Econtrol&amp;utm_term=treeshaking">https://blog.csdn.net/lunahaijiao/article/details/121368958?ops_request_misc=%7B%22request%5Fid%22%3A%22166761258316782429762790%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=166761258316782429762790&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-121368958-null-null.142^v63^control,201^v3^add_ask,213^v1^control&amp;utm_term=treeshaking</a> 和component&amp;spm=1018.2226.3001.4187)</p><p><strong>7、****小图标把图片替换成 svg；</strong></p><p><strong>8、骨架屏</strong></p><p><strong>9、路由跳转加动画</strong></p><ul><li>从减少代码体积角度的：webpack优化、打包优化、tree-shaking等</li><li>从减少HTTP请求角度的：接口合并、按需加载、延时加载等各种方法减少请求</li><li>从缓存角度出发：离线包、http&amp;浏览器各种缓存使用、dns预解析、dll方案、接口缓存方案等</li><li>从数据获取时机角度出发：webWorker预取数据、路由进入过程读取数据等</li><li>从减少图片体积和数量出发：使用webp图片、请求域名并行优化、CSS Sprite等</li></ul><h3 id="3、前端性能优化有哪些指标？怎么查看，还知道什么解决方案"><a href="#3、前端性能优化有哪些指标？怎么查看，还知道什么解决方案" class="headerlink" title="3、前端性能优化有哪些指标？怎么查看，还知道什么解决方案"></a>3、前端性能优化有哪些指标？怎么查看，还知道什么解决方案</h3><p>有一篇文章写到，亚马逊减少了100ms的白屏时间，销量增加1% ! 由此可见性能优化的重要性了吧</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22343781/1658136678668-637b42f2-206b-4a3a-b777-a287e7a8c45f.png?x-oss-process=image/resize,w_605,limit_0#clientId=u5a3f71f3-0346-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=259&amp;id=ue3e61ba3&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=324&amp;originWidth=605&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=47744&amp;status=done&amp;style=none&amp;taskId=ub2b848d2-7b1a-405e-9a51-522b4953c28&amp;title=&amp;width=484" alt="img"></p><p><strong>一、确定指标</strong></p><p>首先我们得确定具体的指标，没有具体的指标就是空谈。</p><p><strong>二、性能优化有迹可循</strong></p><p><strong>从url按下回车键…..</strong></p><p>1.输入网址url<br>    2.缓存解析(浏览器缓存-系统缓存-路由器缓存)等<br>    3.域名解析(DNS解析,域名到ip地址的解析) </p><p> <strong>— 拿到 ip 地址可以使用 cdn 加速</strong><br>4.TCP连接,三次握手 </p><p> <strong>—减少请求数量，合并接口，使用精灵图</strong></p><p>5.服务器接收到浏览器发送的请求信息，返回响应头与响应体  </p><p><strong>— 对响应报文进行压缩，gzip压缩，</strong></p><p><strong>webpack压缩：treeshaking、关闭productionSourceMap（</strong> vue.config.js 修改 productionSourceMap 为 false<br><strong>）</strong></p><p>6.页面渲染-浏览器接收到响应信息后，进行客户端渲染，生成DOM树、解析CSS样式对JS进行交互。</p><p>—从框架的角度：关闭 <strong>preload 与 prefetch、路由懒加载、</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/27759506/1668161876196-6788f4d8-7597-4f16-ad5a-f7b3e79f27fa.png" alt="img"></p><h4 id="Performance-API"><a href="#Performance-API" class="headerlink" title="Performance API"></a>Performance API</h4><p><a href="https://www.yuque.com/leyulv-uvbgk/ew73lz/thklgm">https://www.yuque.com/leyulv-uvbgk/ew73lz/thklgm</a></p><p>这个是HTML5新增的API，可供查询早期看见有些人在页面加载时，的head里面添加上一段获取时间戳的代码，然后在开始获取数据的时候在获取一次时间戳，相减来计算白屏时间这其实是一种非常麻烦的做法，并不友好。因此W3C后面推出了Performance这个API来帮助开发者查看这些性能时间点。<br>直接F12.控制台输入window.perforamce.timing<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22343781/1658138288290-11b99579-5c45-466a-b143-d0f6323ee2df.png#clientId=u5a3f71f3-0346-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=348&amp;id=u2915ae49&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=435&amp;originWidth=361&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=36315&amp;status=done&amp;style=none&amp;taskId=uf9d7c7d6-23c5-4426-a081-e110a7a45ba&amp;title=&amp;width=288.8" alt="img"><br>你可以看到一大堆这些属性，细心的你一定会发现这是成对出现的没错。下面把具体的都写在底下了。</p><pre><code class="line-numbers language-javascript">const timingInfo = window.performance.timing;// DNS解析，DNS查询耗时timingInfo.domainLookupEnd - timingInfo.domainLookupStart;// TCP连接耗时timingInfo.connectEnd - timingInfo.connectStart;// 获得首字节耗费时间，也叫TTFBtimingInfo.responseStart - timingInfo.navigationStart;// domReady时间(与DomContentLoad事件对应)timingInfo.domContentLoadedEventStart - timingInfo.navigationStart;// DOM资源下载timingInfo.responseEnd - timingInfo.responseStart;// 准备新页面时间耗时timingInfo.fetchStar - timingInfo.navigationStart;// 重定向耗时timingInfo.redirectEnd - timingInfo.redirectStart;// Appcache 耗时timingInfo.domainLookupStart - timingInfo.fetchStart;// unload 前文档耗时timingInfo.unloadEventEnd - timingInfo.unloadEventStart;// request请求耗时timingInfo.responseEnd - timingInfo.requestStart;// 请求完毕至DOM加载timingInfo.domInteractive - timingInfo.responseEnd;// 解释dom树耗时timingInfo.domComplete - timingInfo.domInteractive;// 从开始至load总耗时timingInfo.loadEventEnd - timingInfo.navigationStart;// 白屏时间timingInfo.responseStart - timingInfo.fetchStart;// 首屏时间timingInfo.domComplete - timingInfo.fetchStart;</code></pre><h4 id="1-FP"><a href="#1-FP" class="headerlink" title="1.FP"></a>1.FP</h4><p>FP(First Paint)翻译为首次绘制，表示浏览器<strong>第一次向屏幕传输像素的时间点</strong>，可以理解为浏览器首次开始绘制像素，页面首次在屏幕上发生了视觉变化 。听起来是不是很烦人？不过问题不大 你只要知道有这么个东西就行了，因为这个指标有虽然有但没啥子意义可言。</p><h4 id="2-FCP"><a href="#2-FCP" class="headerlink" title="2.FCP"></a>2.FCP</h4><p>指浏览器从响应用户输入网络地址到页面内容的任何部分在屏幕上完成渲染的时间。这个就是实际有意义的首屏时间。这个指标就是我们常说的白屏时间</p><h4 id="3-FMP"><a href="#3-FMP" class="headerlink" title="3.FMP"></a>3.FMP</h4><p>FMP(First Meaningful Paint)首次进行有意义的绘制，这个指标反应就是主要内容出现在页面上要的时间，FMP的本质是一个主观认知的指标，是用一个算法来计算那个时间点是FMP，计我们网易这边目前看的指标是FMP。</p><p><em><strong>首次有效绘制 = 具有最大布局变化的绘制</strong></em></p><p>[<a href="https://www.zhihu.com/search?type=content&amp;q=First%20Meaningful%20Paint%5D">https://www.zhihu.com/search?type=content&amp;q=First%20Meaningful%20Paint]</a>(<a href="https://www.zhihu.com/search?type=content&amp;q=First">https://www.zhihu.com/search?type=content&amp;q=First</a> Meaningful Paint)</p><h4 id="4-LCP"><a href="#4-LCP" class="headerlink" title="4.LCP"></a>4.LCP</h4><p>LCP(Largest Contentful Paint)翻译为最大内容绘制，用于记录首屏中最大元素渲染的时间，和 FCP 不同的是，FCP 更关注浏览器什么时候开始绘制内容，比如一个 loading 页面或者骨架屏，并没有实际价值，所以 LCP 相较于 FCP 更适合作为首屏指标。我有个好朋友在阿里那边，他们组的指标主要是看LCP，但我们组这边觉得LCP在设备兼容性上还不够完善，目前只在安卓8以上，以及pc上chrome支持。</p><h4 id="5-TTI"><a href="#5-TTI" class="headerlink" title="5.TTI"></a>5.TTI</h4><p>TTI(Time to Interactive)翻译为交互时间，等到服务器通过HTTP协议将响应全部返回之后，便开始DOM Tree 的构建，完成之后，网页变成可交互状态，到此为止便是网页的可交互时间。用户可以进行正常的事件输入交互操作。</p><h1 id="项目业务亮点"><a href="#项目业务亮点" class="headerlink" title="项目业务亮点"></a>项目业务亮点</h1><h3 id="1、单点登录技术有几种？如何实现？"><a href="#1、单点登录技术有几种？如何实现？" class="headerlink" title="1、单点登录技术有几种？如何实现？"></a>1、单点登录技术有几种？如何实现？</h3><p>2.实现方法</p><ul><li>前端实现单点登录的<strong>关键就在于共享SessionID或者Token在cookie中</strong></li><li>cookie的domain属性的有效值为当前域或者其父级作用域的域名/ip地址</li></ul><p>​    2.1 父域Cookie实现      同一域名的情况下（不支持跨域）</p><p><strong>可以将当前cookie的domain设置为父域</strong>，<strong>父域cookie的domain会自动共享给子域domain属性</strong>；  </p><p>将cookie的path设置为根路径”/“，换言之就是将sessionId和token设置给父域，其下面的子系统就可以访问到这个cookie。</p><ol><li>token + 单点登录（<strong>localStorage跨域存储</strong>）</li></ol><p>可以选择将 Session ID （或 Token ）保存到浏览器的 LocalStorage 中，让前端在每次向后端发送请求时，主动将LocalStorage的数据传递给服务端</p><p>这些都是由前端来控制的，后端需要做的仅仅是在用户登录成功后，将 Session ID（或 Token）放在响应体中传递给前端</p><p>单点登录完全可以在前端实现。前端拿到 Session ID（或 Token ）后，除了将它写入自己的 LocalStorage 中之外，还可以通过特殊手段将它写入多个其他域下的 LocalStorage 中</p><pre><code class="line-numbers language-javascript">// 获取 tokenvar token = result.data.token; // 动态创建一个不可见的iframe，在iframe中加载一个跨域HTMLvar iframe = document.createElement("iframe");iframe.src = "http://app1.com/localstorage.html";document.body.append(iframe);// 使用postMessage()方法将token传递给iframesetTimeout(function () {    iframe.contentWindow.postMessage(token, "http://app1.com");}, 4000);setTimeout(function () {    iframe.remove();}, 6000); // 在这个iframe所加载的HTML中绑定一个事件监听器，当事件被触发时，把接收到的token数据写入localStoragewindow.addEventListener('message', function (event) {    localStorage.setItem('token', event.data)}, false);</code></pre><p> 2.2 统一认证中心实现       不同域名（支持跨域）</p><ol><li>认证中心（SSO）就是一个专门负责处理登录请求的独立web服务；</li><li>用户统一在认证中心进行登录，认证中心登录后将token写入cookie（此cookie是认证中心独有的），子应用系统访问不到</li><li>目标应用系统登录检查当前用户有没有token，如果没有则说明用户没有登录当前系统，将跳转到认证中心（跳转时会自动带上认证中心的cookie，因此认证中心会知道当前用户是否已经登录过了）；</li><li>如果没有则返回登录页面进行登录；</li><li>如果已经登录过则会跳转到目标URL并在跳转前生成一个token拼接在URL后回传给目标应用系统，</li><li>目标系统拿到token向认证中心确认token合法性；</li><li>目标系统记录用户token登录状态，并将token写入cookie后放行进入（此cookie也是当前应用系统独有），其他子系统无法访问；</li><li>用户再次访问目标应用系统时会自动带上token，系统验证token进行登录，脱离认证中心。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/27759506/1666794914182-53a89a0c-cc23-4122-b835-54317a9ca972.png" alt="img"></p><p>————————————————</p><p>版权声明：本文为CSDN博主「ZhenYu学前端」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</p><p>原文链接：<a href="https://blog.csdn.net/weixin_46077258/article/details/125997620">https://blog.csdn.net/weixin_46077258/article/details/125997620</a></p><h3 id="2、JS-大数据问题？小数字问题？有什么-解决办法？"><a href="#2、JS-大数据问题？小数字问题？有什么-解决办法？" class="headerlink" title="2、JS 大数据问题？小数字问题？有什么    解决办法？"></a>2、JS 大数据问题？小数字问题？有什么    解决办法？</h3><h3 id="3、VUEX-和-localStorage？"><a href="#3、VUEX-和-localStorage？" class="headerlink" title="3、VUEX 和 localStorage？"></a>3、VUEX 和 localStorage？</h3><h3 id="4、全局事件总线原理？设计模式？"><a href="#4、全局事件总线原理？设计模式？" class="headerlink" title="4、全局事件总线原理？设计模式？"></a>4、全局事件总线原理？设计模式？</h3><p>ipad面试准备P4</p><h3 id="移动端适配方案"><a href="#移动端适配方案" class="headerlink" title="移动端适配方案"></a>移动端适配方案</h3><h3 id="Vue-cli"><a href="#Vue-cli" class="headerlink" title="Vue-cli"></a>Vue-cli</h3><h3 id="如何封装一个组件"><a href="#如何封装一个组件" class="headerlink" title="如何封装一个组件"></a>如何封装一个组件</h3><p>就拿modal弹窗具体。</p><p>1、首先封装一个组件我们需要考虑，我们应该需要向外暴露哪些接口，需要外部传入哪些数据进来，合理的抽离公共部分和定制部分。</p><p>2、一个弹窗包括哪些内容？Title、content、ok回调、cencel回调，那我们就在props里面接收这几个参数。</p><p>3、Tile、content放在哪？Title我们可以以值得方式传入，样式写死。但是content比较灵活，可以用插槽的方式实现，组件标签中传入模板灵活定制</p><p>过程中出现的问题？</p><p>遮罩层不能完全盖住所有的东西，就算设置z-index也不管用。什么原因？因为z-index值只决定同一父元素中的同级子元素的堆叠顺序。解决方案：使用Teleport瞬移组件，将组件添加到 body 下。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/27759506/1668928023745-ac1a031b-491b-4495-9d4c-f519ff819dd9.png" alt="img"></p><h1 id="项目遇到的问题"><a href="#项目遇到的问题" class="headerlink" title="项目遇到的问题"></a>项目遇到的问题</h1><h2 id="JS大数字和小数字问题"><a href="#JS大数字和小数字问题" class="headerlink" title="JS大数字和小数字问题"></a>JS大数字和小数字问题</h2><p>场景：当<a href="https://so.csdn.net/so/search?q=axios&amp;spm=1001.2101.3001.7020">axios</a>内部进行JSON.parse()将服务器返回的字符串转换为对象之后, 文章的ID值会不准确</p><p>JavaScript 能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围，无法精确表示这个值，这使得 JavaScript 不适合进行科学和金融方面的精确计算。</p><p>关于一些json方法：</p><p><strong>JSON 的常规用途是同 web 服务器进行数据传输。</strong></p><p><strong>在从 web 服务器接收数据时，数据永远是字符串。</strong></p><p><strong>通过 JSON.parse() 解析数据，这些数据会成为 JavaScript 对象。</strong></p><pre><code class="line-numbers language-plain">/*将服务器端接受的数据转换为js对象*/ JSON.parse()</code></pre><p><strong>在向 web 服务器发送数据时，数据必须是字符串。</strong></p><p><strong>通过 JSON.stringify() 把 JavaScript 对象转换为字符串。</strong></p><pre><code class="line-numbers language-plain">/*将js对象转换为字符串发送给服务器*/ JSON.stringify()</code></pre><p>json-bigint 会把超出 JS 安全整数范围的数字转为一个 BigNumber 类型的对象，对象数据是它内部的一个算法处理之后的，我们要做的就是在使用的时候转为字符串来使用。 </p><p>axios 为了方便我们使用数据，它会在内部使用 JSON.parse() 把后端返回的数据转为 JavaScript 对象，</p><pre><code class="line-numbers language-plain">解决思路： Axios 会在内部使用 JSON.parse 把后端返回的数据转为 JavaScript 数据对象。 所以解决思路就是：不要让 axios 使用 JSON.parse 来转换这个数据，而是使用 json-biginit 来做转换处理。 axios 提供了一个 API：transformResponse，在这里对返回的原数据进行操作</code></pre><p>滚动列表卡顿</p><p>首屏加载卡顿</p><p>-图片懒加载</p><p>vue.set() 数据响应式</p><h1 id="简历涉及技能知识点"><a href="#简历涉及技能知识点" class="headerlink" title="简历涉及技能知识点"></a>简历涉及技能知识点</h1><h2 id="HTML、CSS方面"><a href="#HTML、CSS方面" class="headerlink" title="HTML、CSS方面"></a>HTML、CSS方面</h2><h3 id="H5-CS3新特性"><a href="#H5-CS3新特性" class="headerlink" title="H5+CS3新特性"></a>H5+CS3新特性</h3><p>P16</p><h3 id="HTML-CSS页面布局（可能考垂直居中）"><a href="#HTML-CSS页面布局（可能考垂直居中）" class="headerlink" title="HTML+CSS页面布局（可能考垂直居中）"></a>HTML+CSS页面布局（可能考垂直居中）</h3><p>水平垂直居中的几种方法：P17</p><h3 id="felx布局"><a href="#felx布局" class="headerlink" title="felx布局"></a>felx布局</h3><p>flex布局：P31</p><h3 id="rem、布局移动端适配"><a href="#rem、布局移动端适配" class="headerlink" title="rem、布局移动端适配"></a>rem、布局移动端适配</h3><p>P26</p><h4 id="视口"><a href="#视口" class="headerlink" title="视口"></a>视口</h4><ul><li><strong>layout viewport(布局视口)：</strong>在PC端上，布局视口等于浏览器窗口的宽度。而在移动端上，由于要使为PC端浏览器设计的网站能够完全显示在移动端的小屏幕里，此时的布局视口会远大于移动设备的屏幕，就会出现滚动条。js获取布局视口：<code>**document.documentElement.clientWidth**</code> | document.body.clientWidth；</li><li><strong>visual viewport(视觉视口)：</strong>用户正在看到的网页的区域。用户可以通过缩放来查看网站的内容。如果用户缩小网站，我们看到的网站区域将变大，此时视觉视口也变大了，同理，用户放大网站，我们能看到的网站区域将缩小，此时视觉视口也变小了。不管用户如何缩放，都不会影响到布局视口的宽度。js获取视觉视口：<code>**window.innerWidth**</code>；</li><li><strong>ideal viewport(理想视口)：</strong>布局视口的一个理想尺寸，只有当布局视口的尺寸等于设备屏幕的尺寸时，才是理想视口。js获取理想视口：<code>window.screen.width</code>；</li></ul><p><strong>1、</strong>在桌面浏览器上，浏览器窗口与视口的宽度一致，而视口（CSS标准文档中称为“初始包含块”）是CSS百分比宽度推算的根源，因此，浏览器窗口是约束CSS布局的视口；<br><strong>2、</strong>在手机上，有两个视口，布局视口会限制CSS布局；视觉视口决定用户看到的网站内容；<br><strong>3、</strong>移动端浏览器还有个理想视口，它是对特定设备上的特定浏览器的布局视口的一个理想尺寸；<br><strong>4、</strong>可以把布局视口尺寸定义为理想视口。这也是响应式设计的基础。</p><p>作者：Sun____<br>链接：<a href="https://www.jianshu.com/p/7c5fdf90c0ef">https://www.jianshu.com/p/7c5fdf90c0ef</a><br>来源：简书</p><p><a href="https://www.jianshu.com/p/7c5fdf90c0ef">https://www.jianshu.com/p/7c5fdf90c0ef</a></p><h4 id="一些移动端适配可能用到的API"><a href="#一些移动端适配可能用到的API" class="headerlink" title="一些移动端适配可能用到的API"></a>一些移动端适配可能用到的API</h4><p>获取设备像素比：<code>**window.devicePixelRatio**</code></p><p>获取可视区域宽高：window.innerWidth和视觉视口高度 window.innerHeight </p><p>一些 meta 视口标签：</p><h4 id="meta视口标签"><a href="#meta视口标签" class="headerlink" title="meta视口标签"></a>meta视口标签</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/png/27759506/1667356648411-cdce5803-6b0a-44e5-a817-1b783806e50a.png" alt="img"></p><p>标准的viewport设置：</p><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0,minimum-scale=1.0,user-scalable=no"><h4 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h4><p><a href="https://blog.csdn.net/dream_lifes/article/details/122013152">https://blog.csdn.net/dream_lifes/article/details/122013152</a></p><p>可以使用媒体查询结合rem布局进行适配</p><h4 id="移动端布局主流方案"><a href="#移动端布局主流方案" class="headerlink" title="移动端布局主流方案"></a>移动端布局主流方案</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/png/23076793/1647161994531-4326a8ae-1083-4652-90aa-06be73c5c64d.png" alt="img"><br>链接：<a href="https://juejin.cn/post/6844903631993454600">https://juejin.cn/post/6844903631993454600</a></p><p>rem是viewport过度：<a href="https://juejin.cn/post/7084926646033055752">https://juejin.cn/post/7084926646033055752</a></p><p><strong>viewport相对于rem的优势</strong></p><ul><li>语义化更好, rem从本义上来说，是一种字体单位，不是用来做布局和各种屏幕尺寸大小适配的，如上面的示例，用rem做适配单位，计算根字体的时候，计算公式中的100这个参数让人感觉很费解，viewport词更达意。</li><li>可以直接在代码中书写px,借助postcss-px-to-viewport插件转换成vw单位，完美适配移动端各种屏幕尺寸。不用像之前那样，一是要在蓝湖上设置根字体基准尺寸，将设计稿标注的px单位转换成rem单位，然后摘抄到代码中。二是需要用js计算设置根字体大小。前端开发天然喜欢px单位，像rem,em,vw，vh这些单位，一般都不是UI设计稿标注的尺寸，开发时需要转换成本。不如直接在代码中写px直观高效。</li></ul><p>作者：去伪存真<br>链接：<a href="https://juejin.cn/post/7084926646033055752">https://juejin.cn/post/7084926646033055752</a></p><h4 id="你的项目中用的是什么方法进行适配"><a href="#你的项目中用的是什么方法进行适配" class="headerlink" title="你的项目中用的是什么方法进行适配"></a>你的项目中用的是什么方法进行适配</h4><p>我的项目适配方案：viewport + px + flex</p><p>实习公司的适配方案：媒体查询 + flex布局 + px + 适当时候的vh/vw</p><h3 id="less预编译相关（预编译原理）"><a href="#less预编译相关（预编译原理）" class="headerlink" title="less预编译相关（预编译原理）"></a>less预编译相关（预编译原理）</h3><p>原理主要分析：<br>less 是预编译处理器，所以会在编译前进行处理成css</p><ul><li>首先less 会转换为ast(抽象语法树）<a href="https://blog.csdn.net/Dear_Mr/article/details/72587908">语法</a></li><li>然后遍历转换后所有的节点</li><li>最后再形成css树</li></ul><h3 id="W3C标准是什么？"><a href="#W3C标准是什么？" class="headerlink" title="W3C标准是什么？"></a>W3C标准是什么？</h3><p>web标准简单来说可以分为<strong>结构</strong>、<strong>表现</strong>和<strong>行为（三层结构）</strong><br>结构 主要是有HTML标签组成<br>表现 即指css样式表<br>行为 主要是有js、dom组成<br>web标准一般是将该三部分独立分开，使其更具有模块化。但一般产生行为时，就会有结构或者表现的变化，也使这三者的界限并不那么清晰。<br>2、W3C对于WEB标准提出了规范化的要求<br>1）<strong>标签和属性名字母要小写</strong><br>2）<strong>标签要闭合</strong><br>3）<strong>标签不允许随意嵌套</strong><br>4）<strong>尽量使用外链css样式表和js脚本</strong>。让结构、表现和行为分为三块，符合规范。同时提高页面渲染速度，提高用户的体验。<br>5）样式<strong>尽量少用行间样式表</strong>，使结构与表现分离<br>6）标签的id和class等属性<strong>命名要做到见文知义</strong>，更利于seo，代码便于维护</p><h2 id="javaScrip方面"><a href="#javaScrip方面" class="headerlink" title="javaScrip方面"></a>javaScrip方面</h2><h3 id="ES6新特性"><a href="#ES6新特性" class="headerlink" title="ES6新特性"></a>ES6新特性</h3><p>P1 06</p><h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><p>P74</p><h3 id="防抖节流"><a href="#防抖节流" class="headerlink" title="防抖节流"></a>防抖节流</h3><p>P75</p><h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><p><a href="https://www.yuque.com/cuggz/interview/vgbphi#edbc6ae5d0930d1b2047b644faf33356">https://www.yuque.com/cuggz/interview/vgbphi#edbc6ae5d0930d1b2047b644faf33356</a></p><p>P83</p><h3 id="原型-原型链"><a href="#原型-原型链" class="headerlink" title="原型/原型链"></a>原型/原型链</h3><p><a href="https://www.yuque.com/cuggz/interview/vgbphi#4fa5088a8bb423b2739ff1166ce1ac36">https://www.yuque.com/cuggz/interview/vgbphi#4fa5088a8bb423b2739ff1166ce1ac36</a></p><p>原型：只有函数对象上才有prototype属性，这个prototype属性上默认有一个属性constructor（构造函数）指向自己。</p><p>P71</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>P71</p><p>1、原型链继承</p><p> 2、构造函数继承(call)</p><p>3、组合式继承</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>P68</p><h3 id="V8引擎原理"><a href="#V8引擎原理" class="headerlink" title="V8引擎原理"></a>V8引擎原理</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/27759506/1666833885873-cfd9c016-6e05-4bce-9ef3-c505ea0a790a.png" alt="img"></p><ul><li><p>V8引擎本身的源码<strong>非常复杂</strong>，大概有超过<strong>100w行C++代码</strong>，通过了解它的架构，我们可以知道它是如何对JavaScript执行的：</p></li><li><p>Parse模块会将JavaScript代码转换成<strong>AST（抽象语法树）</strong>，这是因为解释器并不直接认识JavaScript代码</p></li><li><ul><li>如果函数没有被调用，那么是不会被转换成AST的；</li><li>Parse的V8官方文档：<a href="https://v8.dev/blog/scanner">https://v8.dev/blog/scanner</a></li></ul></li><li><p>Ignition是一个解释器，会将AST转换成ByteCode（字节码）时会收集TurboFan优化所需要的信息（比如函数参数的类型信息，有了类型才能进行真实的运算）；</p></li><li><ul><li>如果函数只调用一次，Ignition会执行解释执行ByteCode； </li><li>Ignition的V8官方文档：<a href="https://v8.dev/blog/ignition-interpreter">https://v8.dev/blog/ignition-interpreter</a></li></ul></li><li><p>TurboFan是一个编译器，可以将字节码编译为CPU可以直接执行的机器码；</p></li><li><ul><li>如果一个函数被多次调用，那么就会被标记为热点函数，那么就会经过TurboFan转换成优化的机器码，提高代码的执行性能； </li><li>但是，机器码实际上也会被还原为ByteCode，这是因为如果后续执行函数的过程中，类型发生了变化（比如sum函数原来执行的是number类型，后来执行变成了string类型），之前优化的机器码并不能正确的处理运算，就会逆向的转换成字节码；</li><li>TurboFan的V8官方文档：<a href="https://v8.dev/blog/turbofan-jit">https://v8.dev/blog/turbofan-jit</a></li></ul></li></ul><p>作者：砺能<br>链接：<a href="https://juejin.cn/post/7107106791778942983">https://juejin.cn/post/7107106791778942983</a></p><h3 id="浏览器渲染原理"><a href="#浏览器渲染原理" class="headerlink" title="浏览器渲染原理"></a>浏览器渲染原理</h3><p><strong>1、构建DOM：二进制流 -&gt;字符 -&gt;token -&gt; 节点对象 -&gt; DOM树</strong></p><p><strong>2、构建CSSOM</strong>：<strong>二进制流 -&gt;字符 -&gt;token -&gt; 节点对象 -&gt; CSSOM</strong></p><p><strong>3、构建渲染树（布局）：DOM和CSSOM结合</strong></p><p><strong>4、布局计算</strong></p><p><strong>1、分层(图层树) ：</strong></p><p><strong>2、绘制列表 ：</strong>把复杂图层拆分为一个个小的绘制指令，然后再按照这些指令的顺序合成一个绘制列表</p><p><strong>3、分块 ：</strong>绘制列表准备好后，渲染进程的主线程会给合成线程发送commit消息，把绘制列表提交给合成线程。合成线程再将图层划分为图块进行渲染</p><p><strong>4、 光栅化：</strong>合成线程会按照视口附近的图块来优先生成位图，将图块转化为位图。</p><p><strong>5、 合成显示：</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/webp/27759506/1668908753694-c87a90a2-1027-4b65-946c-ba09ce4443ee.webp" alt="img"><img src="https://cdn.nlark.com/yuque/0/2022/webp/27759506/1668756697123-9dfbce34-f479-4ec1-988d-5d9a734a78be.webp" alt="img"></p><p>作者：TianTianUp<br>链接：<a href="https://juejin.cn/post/6847902222349500430">https://juejin.cn/post/6847902222349500430</a></p><h3 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h3><p><strong>核心</strong>在于：<strong>函数里面返回函数</strong>，从而做到参数复用的目的。</p><p>手撕代码文件记录</p><pre><code class="line-numbers language-javascript">// 函数currying化实现function Currying(fn) {    function curried(...args){      // 判断当前已经接受的参数个数，可以参数本身需要接受的参数是否已经一致了      // 1.当已经传入的参数 大于等于 需要的参数是，就执行函数      if(args.length &gt;= fn.length) {        return fn.apply(this,args)      } else {        // 当没有达到个数时，就返回一个新的函数，继续来接受参数        function curried2(...args2) {          // 接收到参数后，需要递归调用curried来检查函数的个数是否达到          return curried.apply(this, args.concat(args2))        }        return curried2      }    }    return curried}function add (a,b,c) {  return a+b+c}let cAdd = Currying(add)console.log(cAdd(1)(2)(3))</code></pre><h2 id="HTTP方面"><a href="#HTTP方面" class="headerlink" title="HTTP方面"></a>HTTP方面</h2><h3 id="CSRF（跨站脚本攻击）"><a href="#CSRF（跨站脚本攻击）" class="headerlink" title="CSRF（跨站脚本攻击）"></a>CSRF（跨站脚本攻击）</h3><p>场景：</p><p>小明登录了某网上银行，他来到了网上银行的帖子区，看到一个帖子下面有一个链接写着“科学理财，年盈利率过万”，小壮好奇的点开了这个链接，结果发现自己的账户少了 10000 元。这是这么回事呢？原来黑客在链接中藏了一个请求，这个请求直接利用小明的身份给银行发送了一个转账请求,也就是通过你的 Cookie 向银行发出请求。</p><p>CSRF有两个特点：</p><ul><li><p>CSRF（通常）发生在第三方域名。</p></li><li><p>CSRF攻击者不能获取到Cookie等信息，只是使用。</p></li></ul><p>原文链接：<a href="https://blog.csdn.net/JinYJ2014/article/details/122931481">https://blog.csdn.net/JinYJ2014/article/details/122931481</a></p><p><strong>为什么说Token可以防止CSRF攻击呢？</strong><br>CSRF是用户登录安全A网站后，点击危险B网站，危险B利用A中的cookie（不是获取，只是利用登录的状态）替代用户进行危险操作。</p><p>​    token验证是需要将token放到请求头或者请求体里，发送给服务器进行验证。</p><p>​    而token虽然是存储于cookie中的，但是危险B无法获取和解析cookie也就拿不到token（不能将token放到请求头中），就无法冒用用户身份。</p><p>cookie是同源的，而打开简书的两个页面是同源的，所以这两个页面的源相同、cookie同。<br>原文链接：<a href="https://blog.csdn.net/qq_36582776/article/details/123598559">https://blog.csdn.net/qq_36582776/article/details/123598559</a></p><h3 id="认证技术cookie、session、Token、jwt"><a href="#认证技术cookie、session、Token、jwt" class="headerlink" title="认证技术cookie、session、Token、jwt"></a>认证技术cookie、session、Token、jwt</h3><p>P101</p><h3 id="cookie有哪些属性？"><a href="#cookie有哪些属性？" class="headerlink" title="cookie有哪些属性？"></a>cookie有哪些属性？</h3><p><a href="https://juejin.cn/post/7092014317192626206#heading-0">https://juejin.cn/post/7092014317192626206#heading-0</a></p><h3 id="cookie在http和https下表现"><a href="#cookie在http和https下表现" class="headerlink" title="cookie在http和https下表现"></a>cookie在http和https下表现</h3><p>http/https属于跨域，请求接口会报错，除非解决了跨域。</p><p>如果设置了secure属性，那么cookie只能在https下传输，传输时会被加密</p><p>如果设置了sameSite</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/27759506/1668323600656-43cc39d5-0ce5-4b5c-a881-4c7ac92c30f5.png" alt="img"></p><h4 id="SameSite"><a href="#SameSite" class="headerlink" title="SameSite"></a>SameSite</h4><p>SameSite 是最近非常值得一提的内容，因为 2 月份发布的 Chrome80 版本中默认屏蔽了第三方的 Cookie，这会导致阿里系的很多应用都产生问题，为此还专门成立了问题小组，推动各 BU 进行改造。</p><p><a href="https://juejin.cn/post/6844904095711494151">https://juejin.cn/post/6844904095711494151</a></p><p>Strict 跨站请求严禁携带本站 cookie，即当前网页 URL 与请求目标 URL 完全一致。（注意区分跨域和跨站）</p><p>Lax 允许部分第三方请求携带 Cookie（可通过顶级导航的方式并使用 GET 请求发时可以携带）</p><p>None 无论是否跨站都会发送 Cookie</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/27759506/1668327579562-8356904c-895f-4689-89e4-fd479c321530.png" alt="img"></p><p>除了这些还有 script 的方式，这种方式也不会发送 Cookie，像淘宝的大部分请求都是 jsonp，如果涉及到跨站也有可能会被影响。</p><p>一些场景：</p><p>我们再看看会出现什么的问题？举几个例子：</p><p>天猫和飞猪的页面靠请求淘宝域名下的接口获取登录信息，由于 Cookie 丢失，用户无法登录，页面还会误判断成是由于用户开启了浏览器的“禁止第三方 Cookie”功能导致而给与错误的提示</p><p>淘宝部分页面内嵌支付宝确认付款和确认收货页面、天猫内嵌淘宝的登录页面等，由于 Cookie 失效，付款、登录等操作都会失败</p><p>阿里妈妈在各大网站比如今日头条，网易，微博等投放的广告，也是用 iframe 嵌入的，没有了 Cookie，就不能准确的进行推荐</p><p>一些埋点系统会把用户 id 信息埋到 Cookie 中，用于日志上报，这种系统一般走的都是单独的域名，与业务域名分开，所以也会受到影响。</p><p>一些用于防止恶意请求的系统，对判断为恶意请求的访问会弹出验证码让用户进行安全验证，通过安全验证后会在请求所在域种一个Cookie，请求中带上这个Cookie之后，短时间内不再弹安全验证码。在Chrome80以上如果因为Samesite的原因请求没办法带上这个Cookie，则会出现一直弹出验证码进行安全验证。</p><p>天猫商家后台请求了跨域的接口，因为没有 Cookie，接口不会返回数据</p><p>链接：<a href="https://juejin.cn/post/6844904095711494151">https://juejin.cn/post/6844904095711494151</a></p><h3 id="CDN原理"><a href="#CDN原理" class="headerlink" title="CDN原理"></a>CDN原理</h3><p><a href="https://www.yuque.com/cuggz/interview/lph6i8#7ff031e1c6a1cc8ea733492b907c3493">https://www.yuque.com/cuggz/interview/lph6i8#7ff031e1c6a1cc8ea733492b907c3493</a></p><p><strong>CDN的工作原理：</strong></p><p>（1）用户未使用CDN缓存资源的过程：</p><ol><li>浏览器通过DNS对域名进行解析（就是上面的DNS解析过程），依次得到此域名对应的IP地址</li><li>浏览器根据得到的IP地址，向域名的服务主机发送数据请求</li><li>服务器向浏览器返回响应数据</li></ol><p>（2）用户使用CDN缓存资源的过程：</p><ol><li>对于点击的数据的URL，经过本地DNS系统的解析，发现该URL对应的是一个CDN专用的DNS服务器，DNS系统就会将域名解析权交给CNAME指向的CDN专用的DNS服务器。</li><li>CND专用DNS服务器将CND的全局负载均衡设备IP地址返回给用户</li><li>用户向CDN的全局负载均衡设备发起数据请求</li><li>CDN的全局负载均衡设备根据用户的IP地址，以及用户请求的内容URL，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求</li><li>区域负载均衡设备选择一台合适的缓存服务器来提供服务，将该缓存服务器的IP地址返回给全局负载均衡设备</li><li>全局负载均衡设备把服务器的IP地址返回给用户</li><li>用户向该缓存服务器发起请求，缓存服务器响应用户的请求，将用户所需内容发送至用户终端。</li></ol><p>如果缓存服务器没有用户想要的内容，那么缓存服务器就会向它的上一级缓存服务器请求内容，以此类推，直到获取到需要的资源。最后如果还是没有，就会回到自己的服务器去获取资源。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1603966294889-153271b5-4b9f-4470-b05f-c7a9f030d043.png" alt="img"></p><p>CNAME（意为：别名）：在域名解析中，实际上解析出来的指定域名对应的IP地址，或者该域名的一个CNAME，然后再根据这个CNAME来查找对应的IP地址。</p><h3 id="TCP的重传机制"><a href="#TCP的重传机制" class="headerlink" title="TCP的重传机制"></a>TCP的重传机制</h3><p>由于TCP的下层网络（网络层）可能出现<strong>丢失、重复或失序</strong>的情况，TCP协议提供可靠数据传输服务。为保证数据传输的正确性，TCP会重传其认为已丢失（包括报文中的比特错误）的包。TCP使用两套独立的机制来完成重传，一是<strong>基于时间</strong>，二是<strong>基于确认信息</strong>。</p><p>TCP在发送一个数据之后，就<strong>开启一个定时器</strong>，<strong>若是在这个时间内没有收到发送数据的ACK确认报文，则对该报文进行重传</strong>，在达到一定次数还没有成功时放弃并发送一个复位信号。</p><h3 id="TCP的流量控制机制"><a href="#TCP的流量控制机制" class="headerlink" title="TCP的流量控制机制"></a>TCP的流量控制机制</h3><p>——<strong>解决发送和接受速率不一致问题</strong>。</p><p>一般来说，流量控制就是为了让发送方发送数据的速度不要太快，要让接收方来得及接收。TCP采用大小可变的<strong>滑动窗口</strong>进行流量控制，窗口大小的单位是字节。这里说的窗口大小其实就是每次传输的数据大小。</p><ul><li>当一个连接建立时，连接的每一端分配一个缓冲区来保存输入的数据，并将缓冲区的大小发送给另一端。</li><li>当数据到达时，接收方发送确认，其中包含了自己剩余的缓冲区大小。（<strong>剩余的缓冲区空间的大小被称为窗口</strong>，指出窗口大小的通知称为窗口通告 。接收方在发送的每一确认中都含有一个窗口通告。）</li><li>如果接收方应用程序读数据的速度能够与数据到达的速度一样快，接收方将在每一确认中发送一个正的窗口通告。</li><li>如果发送方操作的速度快于接收方，接收到的数据最终将充满接收方的缓冲区，导致接收方通告一个零窗口 。发送方收到一个零窗口通告时，必须停止发送，直到接收方重新通告一个正的窗口。</li></ul><h3 id="TCP的拥塞控制机制"><a href="#TCP的拥塞控制机制" class="headerlink" title="TCP的拥塞控制机制"></a>TCP的拥塞控制机制</h3><p>——<strong>解决网络自身拥堵问题（如物理设备支持最大传输带宽）</strong></p><p>TCP的拥塞控制机制主要是以下四种机制：</p><ul><li>慢启动（慢开始）</li><li>拥塞避免</li><li>快速重传</li><li>快速恢复</li></ul><p><strong>（1）慢启动（慢开始）（指数增长）</strong></p><ul><li><p>在开始发送的时候设置cwnd = 1（<strong>cwnd指的是拥塞窗口</strong>）</p></li><li><p>思路：开始的时候不要发送大量数据，而是先测试一下网络的拥塞程度，由小到大增加拥塞窗口的大小。</p></li><li><p>为了防止cwnd增长过大引起网络拥塞，设置一个慢开始门限(ssthresh 状态变量)</p></li><li><ul><li>当cnwd &lt; ssthresh，使用慢开始算法</li><li>当cnwd = ssthresh，既可使用慢开始算法，也可以使用拥塞避免算法</li><li>当cnwd &gt; ssthresh，使用拥塞避免算法</li></ul></li></ul><p><strong>（2）拥塞避免（线性增长）</strong></p><ul><li>拥塞避免未必能够完全避免拥塞，是说在拥塞避免阶段将拥塞窗口控制为按线性增长，使网络不容易出现阻塞。</li><li>思路： 让拥塞窗口cwnd缓慢的增大，即每经过一个返回时间RTT就把发送方的拥塞控制窗口加一</li><li>无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞，就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢开始算法。如图所示:<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1604022952123-62276cba-d882-46c9-8a1c-70655dc501af.png" alt="img"><br>其中，判断网络出现拥塞的根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理。</li></ul><p><strong>（3）快速重传</strong></p><ul><li>快重传要求接收方在收到一个失序的报文段后就立即发出重复确认(为的是使发送方及早知道有报文段没有到达对方)。<strong>发送方只要连续收到三个重复确认就立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期</strong>。</li><li>由于不需要等待设置的重传计时器到期，能尽早重传未被确认的报文段，能提高整个网络的吞吐量</li></ul><p><strong>（4）快速恢复</strong></p><ul><li>当发送方连续收到三个重复确认时，就执行“乘法减小”（指数减小）算法，把<strong>ssthresh门限减半</strong>。但是接下去并不执行慢开始算法。</li><li>考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1604022952153-a7106d22-225d-4081-9b0a-56b0d1876bc2.png" alt="img"></li></ul><h3 id="OSI各层具体应用"><a href="#OSI各层具体应用" class="headerlink" title="OSI各层具体应用"></a>OSI各层具体应用</h3><h3 id="状态码3XX-Redirection-重定向状态码"><a href="#状态码3XX-Redirection-重定向状态码" class="headerlink" title="状态码3XX (Redirection 重定向状态码)"></a>状态码3XX (Redirection 重定向状态码)</h3><p>3XX 响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。</p><h4 id="（1）301-Moved-Permanently"><a href="#（1）301-Moved-Permanently" class="headerlink" title="（1）301 Moved Permanently"></a>（1）301 Moved Permanently</h4><p><strong>永久重定向。</strong></p><p>该状态码表示请求的资源已经被分配了新的 URI，以后应使用资源指定的 URI。新的 URI 会在 HTTP 响应头中的 Location 首部字段指定。若用户已经把原来的URI保存为书签，此时会按照 Location 中新的URI重新保存该书签。同时，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址。</p><p><strong>使用场景：</strong></p><ul><li>当我们想换个域名，旧的域名不再使用时，用户访问旧域名时用301就重定向到新的域名。其实也是告诉搜索引擎收录的域名需要对新的域名进行收录。</li><li>在搜索引擎的搜索结果中出现了不带www的域名，而带www的域名却没有收录，这个时候可以用301重定向来告诉搜索引擎我们目标的域名是哪一个。</li></ul><h4 id="（2）302-Found"><a href="#（2）302-Found" class="headerlink" title="（2）302 Found"></a>（2）302 Found</h4><p><strong>临时重定向。</strong></p><p>该状态码表示请求的资源被分配到了新的 URI，希望用户（本次）能使用新的 URI 访问资源。和 301 Moved Permanently 状态码相似，但是 302 代表的资源不是被永久重定向，只是临时性质的。也就是说已移动的资源对应的 URI 将来还有可能发生改变。若用户把 URI 保存成书签，但不会像 301 状态码出现时那样去更新书签，而是仍旧保留返回 302 状态码的页面对应的 URI。同时，搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回302代码，搜索引擎认为新的网址只是暂时的。</p><p><strong>使用场景：</strong></p><ul><li>当我们在做活动时，登录到首页自动重定向，进入活动页面。</li><li>未登陆的用户访问用户中心重定向到登录页面。</li><li>访问404页面重新定向到首页。</li></ul><h4 id="（3）303-See-Other"><a href="#（3）303-See-Other" class="headerlink" title="（3）303 See Other"></a>（3）303 See Other</h4><p>该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。</p><p>303 状态码和 302 Found 状态码有着相似的功能，但是 <strong>303 状态码明确表示客户端应当采用 GET 方法获取资源。</strong></p><p>303 状态码通常作为 PUT 或 POST 操作的返回结果，它表示重定向链接指向的不是新上传的资源，而是另外一个页面，比如消息确认页面或上传进度页面。而请求重定向页面的方法要总是使用 GET。</p><p>注意：</p><ul><li>当 301、302、303 响应状态码返回时，几乎所有的浏览器都会把 POST 改成GET，并删除请求报文内的主体，之后请求会再次自动发送。</li><li>301、302 标准是禁止将 POST 方法变成 GET方法的，但实际大家都会这么做。</li></ul><h4 id="（4）304-Not-Modified"><a href="#（4）304-Not-Modified" class="headerlink" title="（4）304 Not Modified"></a>（4）304 Not Modified</h4><p><strong>浏览器缓存相关。</strong></p><p>该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。304 状态码返回时，不包含任何响应的主体部分。304 虽然被划分在 3XX 类别中，但是和重定向没有关系。</p><p>带条件的请求（Http 条件请求）：使用 Get方法 请求，请求报文中包含（<code>if-match</code>、<code>if-none-match</code>、<code>if-modified-since</code>、<code>if-unmodified-since</code>、<code>if-range</code>）中任意首部。</p><p>状态码304并不是一种错误，而是告诉客户端有缓存，直接使用缓存中的数据。返回页面的只有头部信息，是没有内容部分的，这样在一定程度上提高了网页的性能。</p><h4 id="（5）307-Temporary-Redirect"><a href="#（5）307-Temporary-Redirect" class="headerlink" title="（5）307 Temporary Redirect"></a>（5）307 Temporary Redirect</h4><p><strong>307表示临时重定向。</strong>该状态码与 302 Found 有着相同含义，尽管 302 标准禁止 POST 变成 GET，但是实际使用时还是这样做了。</p><p>307 会遵守浏览器标准，<strong>不会从 POST 变成 GET</strong>。但是对于处理请求的行为时，不同浏览器还是会出现不同的情况。规范要求浏览器继续向 Location 的地址 POST 内容。规范要求浏览器继续向 Location 的地址 POST 内容。</p><h2 id="VUE"><a href="#VUE" class="headerlink" title="VUE"></a>VUE</h2><p><a href="https://www.yuque.com/ayong-cbshf/bnd60u/zaibr2?inner=VUE">https://www.yuque.com/ayong-cbshf/bnd60u/zaibr2?inner=VUE</a></p><h3 id="路由两种模式及区别"><a href="#路由两种模式及区别" class="headerlink" title="路由两种模式及区别"></a>路由两种模式及区别</h3><p>P153</p><p><a href="https://blog.csdn.net/qq_18599727/article/details/124462666">https://blog.csdn.net/qq_18599727/article/details/124462666</a></p><p><a href="https://mp.weixin.qq.com/s/BDS9ule4OGUHiH2RaWtVVQ">https://mp.weixin.qq.com/s/BDS9ule4OGUHiH2RaWtVVQ</a></p><h3 id="VUE2-0和VUE3-0的区别"><a href="#VUE2-0和VUE3-0的区别" class="headerlink" title="VUE2.0和VUE3.0的区别"></a>VUE2.0和VUE3.0的区别</h3><p>P143</p><h3 id="路由懒加载的原理是什么"><a href="#路由懒加载的原理是什么" class="headerlink" title="路由懒加载的原理是什么?"></a>路由懒加载的原理是什么?</h3><p>​    通过Webpack编译打包后，会把每个路由组件的代码分割成一一个js文件，初始化时不会加载这些js文件，只当激活路由组件才会去加载对应的js文件。</p><p>​    作用就是webpack在打包的时候，对异步引入的库代码进行代码分割时（需要配置webpack的SplitChunkPlugin插件），为分割后的代码块取得名字</p><p>​    Vue中运用import的懒加载语句以及webpack的魔法注释，在项目进行webpack打包的时候，对不同模块进行代码分割，在首屏加载时，用到哪个模块再加载哪个模块，实现懒加载进行页面的优化。</p><h3 id="VUEX"><a href="#VUEX" class="headerlink" title="VUEX"></a>VUEX</h3><h3 id="VUEX中的subscribe-API"><a href="#VUEX中的subscribe-API" class="headerlink" title="VUEX中的subscribe API"></a>VUEX中的subscribe API</h3><p>App.vue</p><pre><code class="line-numbers language-javascript">this.$store.commit('add') 1</code></pre><p>store.js</p><p>3</p><pre><code class="line-numbers language-javascript">const store = new Vuex.Store({    state:{        name:'xxx',        age:20    },    mutations:{        add(state){            console.log(state.age);        }    }})store.subscribe((mutation,state) =&gt; {    console.log(mutation.type)      console.log(state) })/*20add{ name : 'xxx', age : 20}*/</code></pre><h3 id="路由参数丢失"><a href="#路由参数丢失" class="headerlink" title="路由参数丢失"></a>路由参数丢失</h3><p>场景：有三个页面(a-列表页面,b-内页1,c-内页2),页面a-&gt;页面b-&gt;页面c有参数传递.从a进入b后,刷新b页面拿不到a页面传进来的参数.或者b页面再进入c页面,并由c页面返回b页面,b页面丢失a页面传入的参数.</p><p>参数的传递使用的是vue-router, query传参</p><pre><code class="line-numbers language-javascript">let para = {id: info.subjId,subjInit: info.subjInit,subjectGuid: info.subjectGuid,visitNo: info.visitNo}this.$router.push({path:'/sign_in_already_detail',query:{para: para }})</code></pre><p>首先说明一下,使用路由的query传参是可以在刷新的时候保留参数的</p><p>之所以出现上面的问题是因为:在query传参数的时候没有对对象参数序列化–就是没有转成字符串.</p><p>所以b页面(接收参数的页面)的路由展示是下图这样. 只有在第一次进入b页面的时候能够拿到参数,之后就获取不到了。</p><pre><code>this.$router.push({path:'/sign_in_already_detail',query:{para: JSON.stringify( para) }})</code></pre><p>这样进入b页面的路由就是如下图这样的,即使在刷新页面后地址也是不会变的.</p><p>原文链接：<a href="https://blog.csdn.net/weixin_33595317/article/details/112899433">https://blog.csdn.net/weixin_33595317/article/details/112899433</a></p><h1 id="附录笔记"><a href="#附录笔记" class="headerlink" title="附录笔记"></a>附录笔记</h1><ul><li><p> 核心：有自己<strong>思考</strong> </p></li><li><p> 准备一两个技术场景，详细展开 </p></li><li><ul><li>面试官大多数问你实现了什么，怎实现？从这里开始发挥</li></ul></li><li><ul><li>模板——有几种实现方式，我选了哪一种，为什么选这一种？</li></ul></li><li><ul><li>问的最多就是业务</li></ul></li><li><p> 实习期间的框架和资源的 loader 看一下 </p></li></ul><p>表单提交，路由信息丢失</p><p>url 特殊字符编码</p><p>首屏闪进</p><p>父子组件生命周期问题</p><p>源码阅读：vuex刷新页面丢失问题：使用 vuex subscribe方法——源码实现也使用localstorage</p><p>1.为什么有localstorage 还要搞个vuex? 2.数据放在localstorage，用户通过控制台就可以看到数据了，怎么解决？3.localstorage里面的数据，人为修改后，刷新页面，修改后的值就赋给vuex了，这个怎么解决？</p><p>发布订阅模式</p><p>   <img src="https://gitee.com/Yuukyou/pic/raw/master/image-20221006001744179.png" alt="img"></p><h1 id="附件简历："><a href="#附件简历：" class="headerlink" title="附件简历："></a>附件简历：</h1><h2 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h2><ul><li>性别：男 年龄：21</li><li>求职意向：Web前端开发工程师</li><li>掌握技能：</li></ul><ol><li><ol><li>掌握 HTML5+CSS3页面布局，熟练使用<a href="#LUCFp">flex布局</a>、rem布局、less预编译与媒体查询实现<a href="#UDBuz">移动端布局</a>，并结合<a href="#oW5aW">W3C标准</a>，精准还原设计稿。</li><li>掌握原生 JavaScript 以及<a href="#YxGtB">ES6新特性</a>，熟悉使用axios与promise进行前后端交互，对于JS<a href="#2b40a774">事件循环</a>，<a href="#fbf314e8">垃圾回收机制</a>，<a href="#zf4rM">函数柯里化</a>，<a href="#0edb4c85">闭包</a>，以及<a href="#5035abb3">V8引擎原理</a>有一定了解。</li><li>掌握 vue2.0 （vuex，vue-router，vue-cli）了解<a href="#zWzhd"> vue3.0</a> 、原生微信小程序等前端框架。</li><li>掌握 <a href="#ddb1c772"><strong>HTTP</strong></a>及计算机网络相关协议；了解 node.js、webpack、<strong>Git</strong> 等前端架构技术。</li><li>掌握 Element-UI、Ant Design、Vant 等常用UI 组件库，以及常用的Photoshop<a href="https://www.baidu.com/other.php?url=0f0000aMxXzukTdtpfH0eUbPyI1LQrsKwq56ZQrxM3GtzO2iZ5M8iW6-p7mWIKpPqVgL58Z3Q12Q4DBqgm1TsogQF2N6SHsJVcQbXaGXWQTXIR678C_-lTXGJnn6U2P4cwXQ9Baf0hIeOn9fBRlysTkUGfIhc46DfPrSwOEDPkFa6fGXxQwlnHtoGfk8uqXmjK2uYVL1waA10heuvj__J-uaTCsL.7D_NR2Ar5Od66Y_kYD1pMc6e32AM-WI6h9ikX1BsIT7jHzlRL5spyQ4hmo87YiX8a9G4myIrP-SJFW9JsRnZgKfYtVKnv-BS6GyAp7BExYes.TLFWgv-b5Hczn1D0TLFWpyfqnWc1nfKk5fKYUHdVmgPYugFMUsKdTvNzgLw4TARqn0K9u7qYXgK-5Hm0IvqzujdVmgPYugFMUsKzmLmqn0KdThkxpyfqnHRYnWm1nHTdPfKVINqGujYkPHDznj61n0KVgv-b5HDkrHTvnWm30AdYTAkxpyfqnHc4rj60TZuxpyfqn0KGuAnqiDFK0ZKGujY10APGujYYnWT0mLFW5Hn3nWc1&amp;dt=1667870647&amp;wd=mastergo&amp;tpl=tpl_12988_30392_0&amp;l=1542631755&amp;us=linkVersion=1&amp;compPath=10048.0-10063.1-10065.0-10052.0&amp;label=%E9%80%9A%E6%A0%8F%E5%86%85%E5%AE%B9%E4%B8%BB%E6%A0%87%E9%A2%98&amp;linkType=&amp;linkText=MasterGo">MasterGo</a>切图工具。</li><li>了解Python、Java、PHP等后端开发语言，Python在机器学习，数据建模方面有所实践。</li></ol></li></ol><h2 id="教育经历"><a href="#教育经历" class="headerlink" title="教育经历"></a>教育经历</h2><ul><li>全日制本科——天津商业大学——信息工程学院——专业：电子商务——2019.9~2023.7</li><li>主修课程：数据结构、数据库、计算机网络、操作系统基础、软件工程</li><li>综合绩点：4.26，年级前 7%</li><li>通过 CET4 英语等级考试</li></ul><h2 id="校园经历"><a href="#校园经历" class="headerlink" title="校园经历"></a>校园经历</h2><ul><li>2022年 <strong>发表一篇SCI二区文章*</strong>C4 Olefin production conditions Optimizing based on a hybrid GXGB-SSA Model*</li><li>2022年 <strong>全国市场调研大赛”正大杯”国家级二等奖</strong> ——负责数据建模与代码实现</li><li>2021年 <strong>全国大学生数学建模竞赛天津市一等奖</strong> ——负责数据建模与代码实现</li><li>2021年 <strong>天津市“启程杯”人工智能鼠竞赛二等奖</strong> ——组长，负责智能鼠软硬件调试</li><li>2021年 <strong>大学生创新创业训练计划项目天津市市级立项</strong></li><li>2021年 <strong>获得天津商业大学信息工程学院“卓越青年”称号</strong></li><li>曾获得天津商业大学<strong>校级三好学生</strong>、<strong>优秀干部</strong></li><li>曾获<strong>国家励志奖学金</strong>、<strong>天津商业大学二等奖学金</strong>两次</li><li>曾任班级<strong>学习委员</strong>、现任<strong>团支书</strong></li></ul><h2 id="实习经历-1"><a href="#实习经历-1" class="headerlink" title="实习经历"></a>实习经历</h2><ul><li><p><strong>联想云，Filez-zbox产研部，web前端开发实习生，2022.06~2022.10</strong></p></li><li><ul><li>使用多种项目管理工具进行多端协作开发（gtilab、jira、fork），参与TDD模式开发。</li><li>日常修复多端BUG，与产品、交互、后端协调确定最佳解决方案。参与日常技术分享会。</li><li>参与新需求“930”和“精卫计划”需求评审、概要设计、详细设计、代码编写、测试联调。</li><li>通过使用 vue 路由守卫处理鉴权，修复首页闪进闪退bug。</li><li>通过<a href="#sXRMW"> encodeURIComponent</a> 方法对URL编码，修复文件夹路径包含特殊字符无法访问的bug。</li><li>通过 localStorage 与<a href="#jNews">subscribeAPI</a>对VUX做<strong>数据持久化</strong>，修复页面刷新参数丢失bug。</li><li>通过运用<a href="#b0074b1b">父子组件生命周</a>期钩子交替顺序，解决异步请求结果获取不到的问题。</li></ul></li><li><p><strong>北京凌波创元科技有限公司，研发部门，前端开发实习生，2021.07~2021.09</strong></p></li><li><ul><li>参与北京林业大学园林学院官网制作，根据设计稿使用原生HTML、CSS、JS精准还原页面布局。</li><li>使用 Swiper 插件制作首页轮播图。</li><li>参与友邦保险报表技术迁移，使用ActiveReportJS制作，使用Git进行多人协作开发。</li></ul></li></ul><h2 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h2><ul><li><p><a href="https://github.com/yuukyou-chan/Party-Member-training-system/tree/main/vue_teacher">天津商业大学信息工程学院智慧党建系统</a>                                                2022.01 ~ 至今<em>使用技术vue、vue-cli、vue-router、Element-ui、axios、VUEX、JS以及其他第三方插件</em>与学院党建办公室合作开发预上线党建系统，包括库表查询、文件审核、分配谈话人、上传导出文件等功能。</p></li><li><ul><li>前端技术组长，组织项目需求分析、系统概要设计、详细设计、确定技术选型以及组织人员分工</li><li>使用 <a href="#owWZg"><strong>Token</strong> </a>技术实现<a href="#S6NfC"><strong>单点登录</strong></a>认证，防范<a href="#f351b28d"><strong>CSRF</strong></a>(跨站请求伪造)攻击。</li><li>使用<strong>localStorage</strong>、<strong>VUEX</strong>对用户登录信息Token进行管理。</li><li>使用 vue-router 管理页面路由，并通过<a href="#6083b68d"><strong>路由懒加载</strong></a>进行<a href="#MGt8w"><strong>首屏优化</strong></a>，提升交互体验。</li><li>通过 <strong>vue-virtual-scroller</strong> 插件进行<a href="#FpvhS"><strong>长列表渲染优化</strong></a>，有效提高网页加载速度。</li><li>通过封装<strong>防抖</strong>、<strong>节流</strong>函数进行搜索框关联以及<a href="#LzfKE"><strong>图片懒加载</strong></a>性能优化。</li><li>使用 JSONbig 插件解决JS中<a href="#C3QYC"><strong>大数字的问题</strong></a>。</li><li>通过 <strong>prerender-spa-plugin</strong> 插件进行<a href="#rsKoj"><strong>预渲染</strong></a>，有效提高网站SEO。</li></ul></li><li><p><a href="https://github.com/yuukyou-chan/toutiao-publish-admin">仿头条后台管理项目</a>                                                                2021.12 ~ 2022.03<em>使用技术vue、vue-cli、vue-router、Element-ui、axios、VUEX、JS、jszip、FileSaver、以及其他第三方插件</em>本项目基本功能模块分为内容管理、素材管理、评论管理、文章发布、个人中心。涉及技术包括：</p></li><li><ul><li>封装 axios 向后端发送请求，使用<strong>请求拦截器</strong>、<strong>响应拦截器</strong>对请求和数据进行处理。</li><li>使用<strong>ElementUI</strong>对页面进行快速搭建，实现页面<strong>组件的封装与重用</strong>。</li><li>使用<strong>全局事件总线</strong>处理公共数据，进行组件间通信。</li><li>使用文件上传技术处理文件并进行<strong>压缩</strong>，提高文件上传效率。</li><li>使用 tiptap 插件实现富文本编辑器，使用 vue-cropper 插件实现头像裁切功能。</li><li>使用docxtemplater、jszip、FileSaver等技术实现excel、word的下载与导出。</li></ul></li><li><p><a href="https://github.com/yuukyou-chan/Himalayan-miniapp">仿喜马拉雅微信小程序</a>                                                        2021.12 ~ 2022.01<em>使用技术原生微信小程序、promise、wxs、commonjs、组件封装与复用</em>    本项目主要是用原生微信小程序进行开发包括首页、节目详情页、收藏页。</p></li><li><ul><li>使用<strong>promise</strong>封装<strong>wx.request</strong>请求，数据来源于后端api。</li><li>使用<strong>commonjs</strong>进行项目模块化，封装公共方法。</li><li>使用<strong>wxs</strong>写外部方法导入到wxml文件中进行精度处理。</li><li>使用<strong>组件封装</strong>，将公用组件抽象成独立模块，便于组件复用。</li><li>使用<strong>globalData</strong>全局变量进行公共状态管理，实现收藏添加与取消功能。</li><li>使用navigate进行url传参，实现组件实现页面与页面数据之间传递</li></ul></li></ul><p><img src="https://gitee.com/Yuukyou/pic/raw/master/image-20221006001744179.png" alt="image-20221006001744179"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 面经 </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用友面试题汇总</title>
      <link href="2022/10/13/yongyou/"/>
      <url>2022/10/13/yongyou/</url>
      
        <content type="html"><![CDATA[<h1 id="JS基础部分"><a href="#JS基础部分" class="headerlink" title="JS基础部分"></a>JS基础部分</h1><p>1、<strong>异步与多线程有没有关系，是不是并发执行的过程</strong>？ </p><p>​    单线程，多线程区别</p><p>21.多线程之间的通信方式</p><p>3、懒加载怎么知道它出现在视口页面 （4）（<strong>图片懒加载原理、实现方式有哪些</strong>）</p><p>4、js基础<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E6%95%B0%E6%8D%AE">数据</a>类型。引用<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E6%95%B0%E6%8D%AE">数据</a>类型（3）</p><p>5、类型判定方法</p><p>7、事件循环题</p><p>8、怎么不使用额外内存，交换两个变量</p><p>9、<strong>函数科里化</strong></p><p>11、说一下settimeout,说一下浏览器的时间循环？</p><p>12、说一下类的继承？</p><p>13、说一下原型与原型链？如何继承？（3）</p><p>14、<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E6%95%B0%E6%8D%AE">数据</a>泄露，<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E6%95%B0%E6%8D%AE">数据</a>溢出</p><p>15、闭包，怎么理解(3)</p><p>16、闭包有什么缺点（2）</p><p>17、浏览器事件模型,事件机制，冒泡和捕获（2）事件冒泡与阻止冒泡</p><p>18、<strong>settimeout的缺点；说说settimeout怎么工作的，如果时间是0怎么办</strong>（3）</p><p>19、<strong>事件委托的原理</strong></p><p>20、<strong>多线程的串行和并行</strong>（2）</p><p>20、<strong>线程和进程了解不？区别是啥</strong>？</p><p>21、<strong>for…of for…in  for循环</strong></p><p>22、<strong>箭头函数和普通函数的区别（3）自函数</strong></p><p>23、<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a>写过没，写过哪些？<strong>数组了解吗？怎么存储更新呢（和内存结合起来说）堆栈区别</strong>；(2)。</p><p>24、<strong>js 异步历史</strong>聊一下。</p><p>25、let, const, var区别；</p><p>26、undefied 和 null，怎么判断是undefied；</p><p>27、谈谈 es6、forEach 与 map区别-没答上，平时遍历用哪个(2)</p><p>28、new一个对象的过程（2）</p><p>29、<strong>sort函数传参</strong></p><p>30、<strong>0.1+0.2如何准确</strong></p><p>31、<strong>js数组与字符串的api</strong></p><p>32、es6的set（）与map（）</p><p>33、<strong>异步编程的方法都有哪些</strong>（3）</p><p>34、递归  <strong>递归形成回调地狱会浏览器崩了</strong>，怎末解决回调地狱  大多数的递归大都采用for循环,for循环效率高很多   promise  async/await</p><h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h1><p>1、Promise 和 async、await 说一下</p><p>2、Promise.all 说一下</p><p>3、es6新特性——es6了解吗？说一下理解。（2)</p><p>4、介绍一下Promise</p><p>5、<strong>ES6和CommonJS</strong></p><p>6、es5 和 es6 的类的区别。</p><p>7、<strong>promise all race、Promise有哪些方法  all race方法以及应用场景</strong>（3）</p><p>8、对于es6的新语法，为了使浏览器支持，<strong>除了bable解析，其他的，比如promise解析玩可能还是语法糖，但是浏览器不识别pormise，怎么处理；babel和ployfill</strong>（3）</p><p>​    babel转换的内部了解过吗</p><h1 id="JS手写部分"><a href="#JS手写部分" class="headerlink" title="JS手写部分"></a>JS手写部分</h1><p>1、<strong>手写filter函数</strong>（2）</p><p>2、<strong>继承</strong></p><p>3、<strong>深拷贝</strong></p><p>4、<strong>模拟实现数组的 push()</strong> ，至少三种方法</p><p>5、手写防抖或节流</p><h1 id="计算机网络-浏览器部分"><a href="#计算机网络-浏览器部分" class="headerlink" title="计算机网络/浏览器部分"></a>计算机网络/浏览器部分</h1><p> 1、<strong>http请求类型，怎么判断什么情景什么请求</strong>   </p><p> 2、<strong>系统中会有消息的闪烁，这种消息的渲染变化如何实现，（前端如何收到后端通知）</strong></p><p>​    <strong>答：轮循，websocket</strong>  </p><p>3、跨域及解决</p><p>4、输入url发生了什么？（6）<strong>cdn机制</strong></p><p>5、http状态码？403 404 304（4）</p><p>6、http/https（https加密原理）；HTTPS服务器为什么把公钥发送给客户端（3）</p><p>8、前端存储方式 localStorage、sessionStorage 、cookie存储大小限制了解吗（4）</p><p>​    说一下浏览器的缓存方式 及其区别还有应用场景？ 登录信息存在哪里？    浏览器的历史记录存在哪？为什么？</p><p>9、常用的HTTP请求方法</p><p>10、GET 与 POST 的区别</p><p>11、<strong>如何发现请求超时</strong></p><p>12、<strong>常见的状态码底层</strong>（2）</p><p>13、http1.0 和 http2.0 的区别（4）</p><p>14、<strong>静态资源的请求是并行请求，还是串行请求</strong> </p><p>15、<strong>cookie在哪写的</strong></p><p>16、<strong>软件工程设计模式</strong></p><p>17、cooike怎么保存到本地的，Cooike怎么跨域</p><p>18、<strong>TCP UDP区别</strong>、 tcp如何保证<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E6%95%B0%E6%8D%AE">数据</a>的可靠传输，和udp的区别（2）</p><p>19、三次握手，四次挥手为什么不五次或者三次</p><p>20、 pc端，移动端，多个请求去请求一个api，但是对于不同的端，需要的<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E6%95%B0%E6%8D%AE">数据</a>格式不同，你怎么区分</p><p>21、<strong>nginx你使用过哪些功能</strong>，具体的实现了解过吗</p><p>22、 localStorage，如果满了，客户端如何处理？</p><p>23、缓存的实现？<strong>304服务端和前端如何是实现</strong>？</p><p>24、<strong>jsonp存在的安全问题</strong>、jsonp（2）</p><p>25、</p><h1 id="框架部分"><a href="#框架部分" class="headerlink" title="框架部分"></a>框架部分</h1><p>1、vue中如何监听到路由地址的变化，怎么实现的？底层基于什么实现的</p><p>2、vue路由模式</p><p>3、history模式的缺点</p><p>4、vue生命周期钩子（3）vue 的生命周期，要获取dom和<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E6%95%B0%E6%8D%AE">数据</a>分别在哪个生命周期</p><p>5、vue3和vue2的区别（3）</p><p>6、用过vuex没</p><p>7、eventbus没</p><p>8、<strong>场景题：说一下兄弟组件，都有一个input框，如何a输入，b组件中input框也输入</strong>？</p><p>9、vue 通信方式（2）</p><p>10、虚拟dom了解过吗？<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E6%95%B0%E6%8D%AE">数据</a>的更新，最后是怎么反映到真实 dom 树上的？</p><p>11、Vue 的路由懒加载是怎么实现的？</p><p>12、Vue 的 v-if 和 v-show 的区别</p><p>13、<strong>Vue 过滤器</strong>用过吗？</p><p>14、Keepalive 呢？</p><p>15、说一下 vue 的常用指令</p><p>16、<strong>vue的新特性</strong>有哪些?</p><p>17、vue双向<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E6%95%B0%E6%8D%AE">数据</a>绑定原理？</p><p>18、<strong>vue中如何监听到路由地址的变化（history）</strong>，怎么实现的？底层基于什么实现的</p><p>19、vue-router</p><p>20、SPA和MPA（2）</p><p>21、VUE事件绑定原理</p><p>22、vue的子组件和父组件生命周期的顺序</p><p>23、v-for key值的作用</p><p>24、<strong>vue状态提升</strong></p><p>25、<strong>设计模式</strong>（3）<br>    单例模式</p><p>​    对MVVM的理解</p><h1 id="HTML和CSS部分"><a href="#HTML和CSS部分" class="headerlink" title="HTML和CSS部分"></a>HTML和CSS部分</h1><p>1、问<strong>浏览器三层</strong>，开始没懂，问了面试官原来问html css js。答了下他们的关系（三层模型）</p><p>4、html meta标签</p><p>5、css高度塌陷（2）</p><p>6、css块级元素，内联元素（2）</p><p>​    Html块级元素和 行内元素有哪些？ 区别？ 怎么互相转变</p><p>7、说说回流与重绘（3）怎么触发</p><p>7、flex有哪些属性（3）</p><p>8、<strong>viewport</strong>？</p><p>9、垂直居中的方式</p><p>10、讲一下盒子模型（2）</p><p>11、HTML语义化的了解</p><p>12、CSS选择器优先级</p><p>13、**@import 与 link 的区别**</p><p>14、清除浮动的方式</p><p>15、隐藏元素的几种方式</p><p>16、html5新特性</p><p>17、css3新特性</p><p>18、<strong>px、em、rem</strong></p><p>19、<strong>实现一个div高宽度度由100变为110纯css实现（伪类+transition</strong></p><p>20、<strong>css3动画属性</strong></p><p>21、sass和less知道吗？ 那<strong>sass是怎样转换成css代码</strong>？</p><p>22、<strong>canvas</strong>  一些用法，在canvas上设置事件怎末</p><p>​    .canvas会导致重绘，怎末提升性能，解决（不会，说到了DOM里的重绘 🤣）</p><p>23、<strong>svg</strong>了解过吗</p><p>24、一<strong>个九宫格切换的时候，引起抖动怎么解决</strong></p><h1 id="优化部分"><a href="#优化部分" class="headerlink" title="优化部分"></a>优化部分</h1><p>1、web首评渲染，ssr</p><p>2、懒加载怎么知道它出现在视口页面 </p><h1 id="项目部分"><a href="#项目部分" class="headerlink" title="项目部分"></a>项目部分</h1><p>1、介绍实习的工作，工作难点，如何解决的。</p><p>（1）用纯JS请求几千条<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E6%95%B0%E6%8D%AE">数据</a>，这会带来很大的时间开销，应该如何去优化</p><p>（2）<strong>拍平数组</strong>，应该如何去实践，以及如何优化（优化递归）</p><p>2、说一说性能优化（项目相关</p><p>3、无限下拉优化</p><p>4、做项目的过程</p><p>5、想知道是怎么分工的？大概做了多久？</p><p>6、微信小程序中的垂直居中布局怎么实现的？（用flex布局</p><p>7、针对你做过的项目，印象最深刻的说一下</p><p>8、项目里如何实现自适应？媒体查询</p><p>9、<strong>分页请求后端<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E6%95%B0%E6%8D%AE">数据</a>，传哪些参数,分页表格如何设计？</strong>(2)</p><h1 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h1><p>1、webpack了解吗，有没有做过独立项目，webpack使用插件的话，一般怎么用</p><p>2、webpack提升打包构建速度和体积的方法</p><p>3、webpack执行流程</p><p>4、前端打包工具是什么？  那你vue项目用的是什么打包工具？  为什么要用打包工具？</p><h1 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h1><p>1、刷过力扣没，来了道<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C">两数之和</a></p><p>2、手撕代码，求字符串出现最多的字符</p><p>3、说一下常见的<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F">排序</a>？</p><p>4、<strong>解析url</strong>(手写，写出来了)，不会正则，有点冗余。</p><p>5、<strong>数组扁平化</strong>（2）</p><p>6、<a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/"><strong>删除排序链表中的重复元素</strong></a></p><p>7、介绍几个整数<strong>数组去重</strong>的方法</p><p>8、汉诺塔问题知道吗？可以手写一下吗？</p><p>9、写一个函数输出2-8之间随机数(2)</p><p>10、撕代码打印一个矩阵的双对角线(2)</p><p>11、两行代码实现数组各元素+1</p><p>12、<strong>实现回文字符串的判断</strong></p><p>13、<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F">排序</a><a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a>，时间复杂度，空间复杂度</p><p>14、<strong>青蛙<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E8%B7%B3%E5%8F%B0%E9%98%B6">跳台阶</a></strong> 时间复杂度和空间o（n），能不能改成o（1）的</p><h1 id="拓展题"><a href="#拓展题" class="headerlink" title="拓展题"></a>拓展题</h1><p>1、你最近在看什么书？</p><p>2、平时有什么兴趣爱好</p><p>3、自己学习前端的方式</p><p>4、自己有什么优势</p><p>5、遇到困难的时候怎么办</p><p>6、对目前前端有什么认识(从所见即所得到目前技术各种复杂)</p><p>7、为什么选择前端,</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DOM</title>
      <link href="2022/05/20/DOM/"/>
      <url>2022/05/20/DOM/</url>
      
        <content type="html"><![CDATA[<pre><code class="line-numbers language-js">DOM document object model文档对象模型 &lt;a href="#"&gt;文本&lt;/a&gt; 节点：node-构成HTML文档最基本的单元 常用节点分为四类：                             nodetype -文档节点：整个HTML文档 nodename：#document      9 -元素节点：HTML文档中的HTML标签                  1 -属性节点：元素的属性                            2 -文本节点：HTML标签中的文本内容 #text             3  浏览器已经为我们提供文档节点对象，这个对象是window属性 他可以在页面直接使用，文档节点代表的是整个网页</code></pre><h2 id="DOM查询"><a href="#DOM查询" class="headerlink" title="DOM查询"></a>DOM查询</h2><h3 id="1、获取元素节点"><a href="#1、获取元素节点" class="headerlink" title="1、获取元素节点"></a>1、获取元素节点</h3><pre><code class="line-numbers language-js">/** * 获取元素节点 * 通过document对象调用 * 1.getElementById() -通过id属性获取一个元素节点对象 * 2.getElementsByTagName() -通过标签名获取一组元素节点对象 * 3.getElementsByName() -通过name属性获取一组元素节点对象 **///innerHTML 通过这个属性可以获取到元素内部的HTML代码（双向绑定）//innerHTML用于获取元素内部HTML代码//对于自结束标签，这个属性没有意义//alert(inputs[i]);//如果需要读取元素节点属性，直接使用元素.属性名//例子：元素.id 元素.value 元素.name//注意：class属性不能采用以上方式，读取class属性名需要使用元素.className//getElementsByTagName可以根据标签名获取一组元素节点对象//这个方法会给我们返回一个类数组对象，所有查询到的元素都会封装到对象中//即使查询到的元素只有一个，也会封装到数组中返回</code></pre><h3 id="2、获取元素节点的子节点"><a href="#2、获取元素节点的子节点" class="headerlink" title="2、获取元素节点的子节点"></a>2、获取元素节点的子节点</h3><pre><code class="line-numbers language-js">/** * 获取元素节点的子节点 * 通过具体的元素节点调用 * 1.getElementsByTagName() -方法，返回当前节点的指定标签名后代节点 * 2.childNodes -属性，表示当前节点的所有子节点（包含空白）    *children这个属性可以获取当前元素的所有子元素（不包含空白） * 3.firstChild -属性，表示当前节点的第一个子节点（包含空白）、    *firstElementChild获取当前元素的第一个子元素 * 4.lastChild -属性，表示当前节点的最后一个子节点 * *//** * childNodes属性会获取包括文本节点在内的所有节点 * 根据dom标准标签空白也会当做文本节点 * 注意：在IE8及以下浏览器中，不会将空白当成子节点， * 所以该属性在IE8中会返回4个子元素，而其他浏览器返回9个 * */</code></pre><h3 id="3、获取父节点和兄弟节点"><a href="#3、获取父节点和兄弟节点" class="headerlink" title="3、获取父节点和兄弟节点"></a>3、获取父节点和兄弟节点</h3><pre><code class="line-numbers language-js">/** * 获取父节点和兄弟节点 * 通过具体的节点调用 * 1.parentNode -属性，表示当前节点的父节点 * 2.previousSibling -属性，表示当前节点的前一个兄弟节点（既包含元素节点、文本节点、注释节点）    *previousElementSibling获取前一个兄弟元素（不包含空白） * 3.nextSibling -属性，表示当前节点的后一个兄弟节点（既包含元素节点、文本节点、注释节点） * */</code></pre><h3 id="4、DOM查询剩余方法"><a href="#4、DOM查询剩余方法" class="headerlink" title="4、DOM查询剩余方法"></a>4、DOM查询剩余方法</h3><pre><code class="line-numbers language-js">/** * document.querySelector() * -需要一个选择器的字符串作为参数，可以根据一个css选择器来查询一个元素节点对象 * -虽然IE8中没有getElementsByClassName()但是可以使用querySelector()代替 * -使用该方法总会返回唯一的一个元素，如果满足条件的元素有多个，那他只会返回第一个 * *///var body = document.getElementsByTagName("body")[0];/** *在document中，有一个属性body，他保存的是body的引用 * *//** * 根据元素的class属性值查询一组元素节点对象 * getElementsByClassName()可以根据class属性值获取一组元素节点对象 * 但是该方法不支持IE8及以下浏览器 * */</code></pre><h2 id="文档加载"><a href="#文档加载" class="headerlink" title="文档加载"></a>文档加载</h2><pre><code class="line-numbers language-js">/** * 浏览器加载一个页面时，是按照自上向下的顺序加载的 * 读取一行就运行一行，如果将js代码写在页面的上面，代码执行时，页面还没有加载 *  ** * onload事件会在整个页面加载完成之后才触发 * 为window绑定一个onload事件 * 该事件对应的响应函数将会在页面加载完成之后执行 * 这样可以确保我们代码执行时所有的dom对象已经加载完毕 * */</code></pre><h2 id="DOM增删改"><a href="#DOM增删改" class="headerlink" title="DOM增删改"></a>DOM增删改</h2><pre><code class="line-numbers language-js">//createElement()-可以用于创建一个元素节点对象，需要一个标签名作为参数，//将会根据该标签名创建元素节点对象，并将创建好的对象作为返回值返回var li = document.createElement("li");//appendChild() -向一个父节点添加一个子节点 -用法：父节点.appendChild(子节点)li.appendChild(gzText);//insertBefore -可以在指定的子节点前插入新的子节点 -语法：父节点.insertBefore(新节点，旧节点)city.insertBefore(li,bj);//replaceChild -可以使用指定的子节点替换已有的子节点 -语法：父节点.replaceChild(新节点，旧节点)city.replaceChild(li,bj);//removeChild -可以删除子节点city.removeChild(bj);</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>日期对象与正则对象</title>
      <link href="2022/05/19/DateAndReg/"/>
      <url>2022/05/19/DateAndReg/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Date对象"><a href="#一、Date对象" class="headerlink" title="一、Date对象"></a>一、Date对象</h2><h3 id="1、Date对象"><a href="#1、Date对象" class="headerlink" title="1、Date对象"></a>1、Date对象</h3><pre><code class="line-numbers language-js">/** * Date对象 * -在js中使用Date对象来表示一个时间 * */ //创建一个Date对象 //直接使用构造函数创建一个Date对象，则会封装为当前代码执行的时间 var d = new Date(); //创建一个指定时间对象 //需要在构造函数中传递一个表示时间的字符串作为参数 //日期的格式 月份/日/年 时:分:秒 var d2 = new Date("02/04/2011 11:10:30"); console.log(d2);     </code></pre><h3 id="2、getDate"><a href="#2、getDate" class="headerlink" title="2、getDate()"></a>2、getDate()</h3><pre><code class="line-numbers language-js">/** * getDate() * -获取当前日期对象是几号（1-31） * */ var date = d.getDate(); //console.log("date ="+date);              </code></pre><h3 id="3、getDay"><a href="#3、getDay" class="headerlink" title="3、getDay()"></a>3、getDay()</h3><pre><code class="line-numbers language-js">/** * getDay() * -获取当前日期对象时是周几（0-6） *  0表示周日 *  1表示周一 *  6表示周六 * */ var day = d2.getDay(); //console.log("day ="+day);               </code></pre><h3 id="4、getMonth"><a href="#4、getMonth" class="headerlink" title="4、getMonth()"></a>4、getMonth()</h3><pre><code class="line-numbers language-js">/** * getMonth() * -可以获取当前时间对象月份，返回一个0-11的值 * -0表示1月 *  1表示的是2月 *  11表示12月 * */var month = d2.getMonth();//console.log("month ="+month);                </code></pre><h3 id="5、getFullYear"><a href="#5、getFullYear" class="headerlink" title="5、getFullYear()"></a>5、getFullYear()</h3><pre><code class="line-numbers language-js">/** * getFullYear() * -获取我们当前日期对象的年份 * */ var year = d.getFullYear(); console.log("year ="+year); /**  * getYear()  * -用getFullYear()方法代替  * */</code></pre><h3 id="6、getTime-获取时间戳"><a href="#6、getTime-获取时间戳" class="headerlink" title="6、getTime() 获取时间戳"></a>6、getTime() 获取时间戳</h3><pre><code class="line-numbers language-js">//创建Date对象var d = new Date();var d2 = new Date("02/04/2011 11:10:30");/** * getTime() * -获取当前日期对象的时间戳 * -时间戳，指的是从格林威治标准时间的1970年1月1日，0时0分0秒 *  到当前日期所花费的毫秒数（1秒=1000毫秒） * -计算机底层在保存时间的时候使用的都是时间戳 * */ var time = d2.getTime(); //console.log(time/1000/60/60/24/365); // var d3 = new Date("1/1/1970 0:0:0"); // time = d3.getTime(); // console.log(time);  //利用时间戳来测试代码的执行的性能 //获取当前的时间戳 var start = Date.now(); for(var i=0; i&lt;100; i++){     console.log(i); } var end = Date.now(); console.log("执行了，"+(end - start)+"毫秒");</code></pre><h2 id="二、RegExp对象"><a href="#二、RegExp对象" class="headerlink" title="二、RegExp对象"></a>二、RegExp对象</h2><p>正则表达式在JavaScript高级中已经写过，这里只介绍一些新的东西。<a href="https://jquery.cuishifeng.cn/regexp.html">正则对象速查表</a></p><h3 id="1、正则对象"><a href="#1、正则对象" class="headerlink" title="1、正则对象"></a>1、正则对象</h3><pre><code class="line-numbers language-js">/** * 正则表达式 * -邮件的规则：1.前面是手机号/qq号/用户名 *            2.跟着一个@符 *            3.163/126/qq *            4..com * -正则表达式用于定义一些字符串的规则 *    计算机可以根据正则表达式，来检查一个字符串是否符合规则 *    获取将字符串中符合规则的内容提取出来 * */ //创建正则表达式对象 /**  * 语法：var 变量 = new RegExp("正则表达式","匹配模式");  * 使用typeof检查正则对象，会返回Object  * 这个正则表达式可以用来检查一个字符串中是否含有a  * 在构造函数中可以传递一个匹配模式作为第二个参数  * 可以是： i 忽略大小写  *         g 全局匹配模式  * */ var reg = new RegExp("bc","i"); var str = "a";</code></pre><h3 id="2、test"><a href="#2、test" class="headerlink" title="2、test()"></a>2、test()</h3><pre><code class="line-numbers language-js">/** * 正则表达式方法： * test() * -使用这个方法，可以用来检查一个字符串是否符合正则表达式的规则 *   如果符合则返回true，反之返回false * */ var result = reg.test(str); //console.log(result); console.log(reg.test("bba"));</code></pre><h3 id="3、转义字符"><a href="#3、转义字符" class="headerlink" title="3、转义字符"></a>3、转义字符</h3><pre><code class="line-numbers language-js">** * 检查一个字符串中是否含有. *  . 表示任意字符 * 在正则表达式中使用\作为转义字符 * \.来表示. * \\来表示\ *  * 注意：使用构造函数时，由于他的参数是一个字符串，而\是字符串中的转义字符 *      如果使用\则需要使用\\来代替 * */ var reg = /\./; reg = /\\/; reg = new RegExp("\\\\"); // console.log(reg.test("abc")); // console.log(reg);</code></pre><h3 id="4、字符串与正则"><a href="#4、字符串与正则" class="headerlink" title="4、字符串与正则"></a>4、字符串与正则</h3><h4 id="1、splict"><a href="#1、splict" class="headerlink" title="1、splict()"></a>1、splict()</h4><pre><code class="line-numbers language-js">var str = "1a2b3c4d5e6f7";/** * split() * -可以将一个字符串拆分为一个数组 * -方法中可以传递一个正则表达式作为参数， *   这样方法会根据正则表达式去拆分字符串 * */ /**  * 根据任意字母来将字符串拆分  * */ var result = str.split(/[A-z]/);    //[1,2,3,4,5...]</code></pre><h4 id="2、search"><a href="#2、search" class="headerlink" title="2、search()"></a>2、search()</h4><pre><code class="line-numbers language-js">/** * search() * -可以搜索字符串中是否含有指定内容 * -如果搜索到指定内容，则会返回第一次出现的索引，如果没有搜索到，返回-1 * -他可以接受一个正则表达式作为参数，然后会根据正则表达式去检索字符串 * */ str = "hello hello"; /**  * 搜索字符串中是否含有abc或aec或afc  * */ result = str.search(/a[bef]c/);  console.log(result); //-1</code></pre><h4 id="3、match"><a href="#3、match" class="headerlink" title="3、match()"></a>3、match()</h4><pre><code class="line-numbers language-js">/** * match() * -可以根据正则表达式，从一个字符串中将符合条件的内容提取出来 * -默认情况下我们的match只会找到第一个符合要求的内容，找到以后就停止检索 *  可以设置正则表达式为全局匹配模式，这样就会匹配到所有内容 *  可以为一个正则表达式设置多个匹配模式，且顺序无所谓 * -match()会将匹配到的内容封装到一个数组中返回，即使只查询到一个结果 * */ var str = "1a2a3a4a5e6f7A8B9C"; result = str.match(/[a-z]/ig); //console.log(result[5]); console.log(result); // [a,a,a,a,e,f,A,B,C]</code></pre><h4 id="4、replace"><a href="#4、replace" class="headerlink" title="4、replace()"></a>4、replace()</h4><pre><code class="line-numbers language-js">/** * replace() * -可以将字符串中指定内容替换为新的内容 * -参数：1.被替换的内容，可以接受正则表达式作为参数 *       2.新的内容 * -默认只会替换第一个， * */ //result = str.replace(/[a-z]/gi,"@_@"); result = str.replace(/[a-z]/gi,""); console.log(result); // 123456789</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS数组常用方法总结</title>
      <link href="2022/05/18/ArryFunction/"/>
      <url>2022/05/18/ArryFunction/</url>
      
        <content type="html"><![CDATA[<h2 id="1、push-方法"><a href="#1、push-方法" class="headerlink" title="1、push()方法"></a>1、push()方法</h2><pre><code class="line-numbers language-js">var arr = ["孙某某","唐某某","宋某某"];/** * push() *   -该方法可以向数组的末尾添加一个或多个元素，并返回数组新的长度 *   -可以将要添加的元素作为方法的参数传递， *     这样这些元素将会自动添加到数组的末尾 *   -该方法会将数组新的长度作为返回值返回 * */var result = arr.push("田某某","严11","杨22","333");//console.log(arr); //console.log("result ="+result);</code></pre><h2 id="2、pop-方法"><a href="#2、pop-方法" class="headerlink" title="2、pop()方法"></a>2、pop()方法</h2><pre><code class="line-numbers language-js"> /**  * pop()  *  -该方法可以删除数组的最后一个元素，并将被删除的元素作为返回值返回  * */  var result = arr.pop();  //console.log(arr);  //console.log("result ="+result);</code></pre><h2 id="3、unshift-方法"><a href="#3、unshift-方法" class="headerlink" title="3、unshift()方法"></a>3、unshift()方法</h2><pre><code class="line-numbers language-js">/**  * unshift()  *  -向数组的开头添加一个或多个元素，并返回新的数组长度  *  -向前边插入元素以后，其他的元素索引会依次调整  * */  //console.log(arr);  arr.unshift("123","789");  console.log(arr);</code></pre><h2 id="4、shift-方法"><a href="#4、shift-方法" class="headerlink" title="4、shift()方法"></a>4、shift()方法</h2><pre><code class="line-numbers language-js">/**  * shift()  *  -可以删除数组第一个元素，并将被删除的元素作为返回值返回  * */ result = arr.shift(); result = arr.shift(); console.log(arr); console.log("result ="+result);</code></pre><h2 id="5、slice-方法"><a href="#5、slice-方法" class="headerlink" title="5、slice()方法"></a>5、slice()方法</h2><pre><code class="line-numbers language-js">var arr = ["孙某某","唐某某","宋某某","123","789"];/** * slice() * -可以用来从数组中提取指定元素（切片） * -该方法不会改变原数组，而是将截取到的元素封装到一个新数组中返回 * -参数：1.截取开始的位置的索引，包含开始索引 *       2.截取结束的位置的索引，不包含结束索引 *          -第二个参数可以省略不写，此时会截取从开始索引往后的所有元素 *          -索引可以传递一个负值，如果传递一个负值，则从后往前计算 * 、           -1倒数第一个 *              -2倒数第二个 * */ var result = arr.slice(1,4); result = arr.slice(3); result = arr.slice(1,-2); // console.log(arr); // console.log(result);</code></pre><h2 id="6、splice-方法"><a href="#6、splice-方法" class="headerlink" title="6、splice()方法"></a>6、splice()方法</h2><pre><code class="line-numbers language-js">/** * splice() * -可以用来删除数组中的指定元素 * -可以用来在数组指定位置中增加元素 * -使用splice()会影响到原数组，会将制定元素从原数组中删除， *  并将被删除的元素作为返回值返回 * -参数：第一个，表示开始位置的索引 *       第二个，表示删除的数量 *       第三个及以后，可以传递一些新的元素， *       这些元素将会自动插入到开始位置索引前面 * */ var arr = ["孙某某","唐某某","宋某某","123","789"]; var result = arr.splice(3,0,"qqq","www","eee"); console.log(arr); //console.log(result);</code></pre><h2 id="7、contact-方法"><a href="#7、contact-方法" class="headerlink" title="7、contact()方法"></a>7、contact()方法</h2><pre><code class="line-numbers language-js">var arr = ["孙某某","唐某某","宋某某"];var arr2 = ["123","789","456"];var arr3 = ["qqq","www","eee"];/** * concat()可以连接两个或多个数组，并将新的数组返回 * -该方法不会对原数组产生影响 * */ var result = arr.concat(arr2,arr3,"米老鼠","唐老鸭");</code></pre><h2 id="8、join-方法"><a href="#8、join-方法" class="headerlink" title="8、join()方法"></a>8、join()方法</h2><pre><code class="line-numbers language-js">/** * join()该方法可以将数组转换为一个字符串 * -该方法不会对原数组产生影响，而是将转换后的字符串作为结果返回 * -在join中可以指定字符串作为参数，这个字符串将会成为数组中元素的连接符 *  如果不使用连接符，默认使用,作为连接符 * */ var arr = ["孙某某","唐某某","宋某某"]; result = arr.join(""); //console.log(arr); //console.log(result);</code></pre><h2 id="9、reverse-方法"><a href="#9、reverse-方法" class="headerlink" title="9、reverse()方法"></a>9、reverse()方法</h2><pre><code class="line-numbers language-js">/** * reverse() * -该方法用来反转数组（前边的去后边，后边的去前边） * -该方法会直接修改原数组 * */ var arr = ["孙某某","唐某某","宋某某","唐老鸭"]; arr.reverse(); //console.log(arr);  var arr = ["b","d","e","a","c"];</code></pre><h2 id="10、sort-方法"><a href="#10、sort-方法" class="headerlink" title="10、sort()方法"></a>10、sort()方法</h2><pre><code class="line-numbers language-js">/** * sort() * -可以用来对数组中的元素进行排序 * -也会影响原数组，默认会按照Unicode编码进行排序 * */ //arr.sort(); //arr.reverse(); /**  * 即使对于纯数字的数组，使用sort()排序时也会按照Unicode编码进行排序，  * 所以对于数字进行排序时，可能会得到错误的结果  *   * 我们可以自己指定排序规则  * 我们可以在sort()中添加一个回调函数，来指定排序规则  *   回调函数中需要定义两个形参，  * 浏览器将会分别使用数组中的元素作为实参去调用回调函数  * 他使用哪个元素调用不确定，但是肯定的是在数组中a一定在b前面  * 浏览器会根据回调函数的返回值来决定元素的顺序，  *   * 如果返回一个大于0的值，则元素会交换位置  * 如果返回小于0的值，则元素位置不变  * 如果返回一个0，则认为两个元素相等，也不交换位置  *   * -如果需要升序排列，则返回a-b，如果需要降序排列，则返回b-a  * */ arr = [5,4]; arr.sort(function(a,b){     //a在前     if(a &gt; b){         return -1;     }else if(a &lt; b){         return 1;     }else{         return 0;     } }); console.log(arr);</code></pre><h2 id="11、forEach"><a href="#11、forEach" class="headerlink" title="11、forEach()"></a>11、forEach()</h2><pre><code class="line-numbers language-js">/** * 一般使用for循环遍历数组 * JS中还为我们提供了一个方法，用来遍历数组 * forEach() * -这个方法只支持IE8以上的浏览器，IE8及以下的浏览器均不支持该方法， *  所以如果需要兼容IE8，还是使用for循环 * */ //创建一个数组 var arr = ["孙某某","唐某某","宋某某","123"]; /**  * forEach()方法需要一个函数作为参数  * -像这种函数，由我们创建但是不由我们调用的，我们称为回调函数  * -数组中有几个元素，函数就执行几次，每次执行时，  *  浏览器会将遍历到的元素以实参的形式传递进来，我们可以来定义形参来读取这些内容  * -浏览器会在回调函数中传递三个参数，  *  第一个参数，就是当前正在遍历的元素  *  第二个参数，就是当前正在遍历的索引  *  第三个参数，就是正在遍历的数组  * */ arr.forEach(function(value,index,obj){     console.log(value);</code></pre><p>注意对比<code>map()</code>方法：</p><ul><li><p>map和forEach的行为相似</p></li><li><p><code>map()</code>返回新的数组，不会改变原来的数组；</p></li><li><p><code>forEach()</code>原地操作，会改变原来数组</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迭代器与生成器</title>
      <link href="2022/04/25/Iterator-Generator/"/>
      <url>2022/04/25/Iterator-Generator/</url>
      
        <content type="html"><![CDATA[<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p><strong>迭代器</strong>（iterator），是确使用户可在容器对象（container，例如链表或数组）上遍访的对象，使用该接口无需关心对象的内部实现细节。</p><p>从迭代器的定义我们可以看出来，迭代器是帮助我们对某个数据结构进行遍历的对象。</p><ul><li><p> 在JavaScript中，迭代器也是一个具体的对象，这个对象需要符合迭代器协议（iterator protocol）：</p></li><li><p>迭代器协议定义了产生一系列值（无论是有限还是无限个）的标准方式；</p></li><li><p>那么在js中这个标准就是一个特定的<strong>next方法</strong>；</p></li><li><p> next方法有如下的要求：</p></li><li><p>一个无参数或者一个参数的函数，返回一个应当拥有以下两个属性的对象：</p></li><li><p><strong>done（boolean）</strong> </p><ul><li>如果迭代器可以产生序列中的下一个值，则为 false。（这等价于没有指定 done 这个属性。）</li><li> 如果迭代器已将序列迭代完毕，则为 true。这种情况下，value 是可选的，如果它依然存在，即为迭代结束之后的默认返回值。</li></ul></li><li><p><strong>value</strong></p><ul><li>迭代器返回的任何 JavaScript 值。done 为 true 时可省略。</li></ul></li></ul><p>迭代器实现：</p><p><img src="https://gitee.com/Yuukyou/pic/raw/master/blog/image-20220425163600080.png" alt="image-20220425163600080"></p><h3 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a>可迭代对象</h3><ul><li>什么又是可迭代对象呢？<ul><li>它和迭代器是不同的概念；</li><li>当一个对象实现了iterable protocol协议时，它就是一个可迭代对象；</li><li>这个对象的要求是必须实现 <strong>@@iterator</strong> 方法，在代码中我们使用 Symbol.iterator 访问该属性；</li></ul></li><li> 当我们要问一个问题，我们转成这样的一个东西有什么好处呢？</li><li>当一个对象变成一个可迭代对象的时候，进行某些迭代操作，比如 for…of 操作时，其实就会调用它的@@iterator 方法；</li></ul><p><img src="/2022/04/25/Iterator-Generator/codeStudy\blog\source_posts\Iterator-Generator\image-20220429161731851.png" alt="image-20220429161731851"></p><h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p>什么是生成器？</p><ul><li><p>生成器是ES6中新增的一种函数控制、使用的方案，它可以让我们更加灵活的控制函数什么时候继续执行、暂停执行等。</p></li><li><p>平时我们会编写很多的函数，这些函数终止的条件通常是返回值或者发生了异常。</p></li><li><p> <strong>生成器函数也是一个函数，但是和普通的函数有一些区别：</strong> </p></li><li><p>首先，生成器函数需要在function的后面加一个符号：***** </p></li><li><p>其次，生成器函数可以通过yield关键字来控制函数的执行流程： </p></li><li><p>最后，生成器函数的返回值是一个Generator（生成器）：</p><ul><li> 生成器事实上是一种<strong>特殊的迭代器</strong>；</li><li> MDN：Instead, they return a special type of iterator, called a <strong>Generator</strong>.</li></ul></li><li><p>我们发现上面的生成器函数foo的执行体压根没有执行，它只是返回了一个生成器对象。</p><ul><li>那么我们如何可以让它执行函数中的东西呢？调用next即可； </li><li>我们之前学习迭代器时，知道迭代器的next是会有返回值的；</li><li>但是我们很多时候不希望next返回的是一个undefined，这个时候我们可以通过yield来返回结果</li></ul></li></ul><p><img src="https://gitee.com/Yuukyou/pic/raw/master/blog/image-20220429165648505.png" alt="image-20220429165648505"></p><ul><li>函数既然可以暂停来分段执行，那么函数应该是可以传递参数的，我们是否可以给每个分段来传递参数呢？<ul><li>答案是可以的；</li><li>我们在调用next函数的时候，可以给它传递参数，那么这个参数会作为上一个yield语句的返回值；</li><li>注意：也就是说我们是为本次的函数代码块执行提供了一个值；</li></ul></li></ul><p><img src="https://gitee.com/Yuukyou/pic/raw/master/blog/image-20220429170221638.png" alt="image-20220429170221638"></p><h3 id="生成器代替迭代器"><a href="#生成器代替迭代器" class="headerlink" title="生成器代替迭代器"></a>生成器代替迭代器</h3><p><img src="https://gitee.com/Yuukyou/pic/raw/master/blog/image-20220429171616724.png" alt="image-20220429171616724"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 生成器 </tag>
            
            <tag> promise </tag>
            
            <tag> asyc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>promise基本用法</title>
      <link href="2022/04/20/promise/"/>
      <url>2022/04/20/promise/</url>
      
        <content type="html"><![CDATA[<h3 id="异步的概念"><a href="#异步的概念" class="headerlink" title="异步的概念"></a>异步的概念</h3><p>异步（Asynchronous, async）是与同步（Synchronous, sync）相对的概念。</p><p>在我们学习的传统单线程编程中，程序的运行是同步的（同步不意味着所有步骤同时运行，而是指步骤在一个控制流序列中按顺序执行）。而异步的概念则是不保证同步的概念，也就是说，一个异步过程的执行将不再与原有的序列有顺序关系。</p><p>简单来理解就是：同步按你的代码顺序执行，异步不按照代码顺序执行，异步的执行效率更高。</p><p>以上是关于异步的概念的解释，接下来我们通俗地解释一下异步：异步就是从主线程发射一个子线程来完成任务。</p><h3 id="回调地狱"><a href="#回调地狱" class="headerlink" title="回调地狱"></a>回调地狱</h3><p><strong>回调地狱概念：回调函数套回调函数的情况就叫做回调地狱(函数作为参数层层嵌套)</strong></p><p>回调函数：一个函数作为参数需要依赖另一个函数执行调用</p><p>回调地狱原因：回调地狱是由于<strong>糟糕的编码习惯</strong>造成的，功能逻辑代码<strong>嵌套的层次太多</strong>,导致<strong>可读性降低</strong>,<strong>维护困难</strong>,避免回调地狱的最重要的方面是将功能移开,保持代码简单，不嵌套并分成小模块,也就是多多进行代码封装<br>解决方式：promise解决方式、 async/await解决方式</p><h3 id="Promise的API是怎么样的："><a href="#Promise的API是怎么样的：" class="headerlink" title="Promise的API是怎么样的："></a>Promise的API是怎么样的：</h3><ul><li><p>Promise是一个类，可以翻译成 承诺、许诺 、期约；</p></li><li><p>当我们需要给予调用者一个承诺：待会儿我会给你回调数据时，就可以创建一个Promise的对象；</p></li><li><p>在通过new创建Promise对象时，我们需要传入一个回调函数，我们称之为executor</p><ul><li><p>这个回调函数会被立即执行，并且给传入另外两个回调函数resolve、reject； </p></li><li><p> 当我们调用resolve回调函数时，会执行Promise对象的then方法传入的回调函数；</p></li><li><p>当我们调用reject回调函数时，会执行Promise对象的catch方法传入的回调函数；</p></li></ul></li></ul><h3 id="Promise代码结构："><a href="#Promise代码结构：" class="headerlink" title="Promise代码结构："></a>Promise代码结构：</h3><p><img src="https://gitee.com/Yuukyou/pic/raw/master/blog/image-20220420103629725.png" alt="image-20220420103629725"></p><p>上面Promise使用过程，我们可以将它划分成<strong>三个状态</strong>：</p><ul><li><p> <em>待定（pending）</em>: 初始状态，既没有被兑现，也没有被拒绝；</p></li><li><p>当执行executor中的代码时，处于该状态；</p></li><li><p><em>已兑现（fulfilled）</em>: 意味着操作成功完成；</p><ul><li>执行了resolve时，处于该状态；</li></ul></li><li><p> <em>已拒绝（rejected）</em>: 意味着操作失败；</p></li><li><p>执行了reject时，处于该状态；</p></li></ul><h3 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h3><ul><li>Executor是在创建Promise时需要传入的一个回调函数，这个回调函数会被立即执行，并且传入两个参数： </li></ul><p><img src="/2022/04/20/promise/image-20220420103924101.png" alt="image-20220420103924101"></p><ul><li><p>通常我们会在Executor中确定我们的Promise状态：</p><ul><li><p>通过resolve，可以兑现（fulfilled）Promise的状态，我们也可以称之为已决议（resolved）；</p></li><li><p>通过reject，可以拒绝（reject）Promise的状态；</p></li></ul></li><li><p> 这里需要注意：一旦状态被确定下来，Promise的状态会被 锁死，该Promise的状态是不可更改的 </p></li><li><p>在我们调用resolve的时候，如果resolve传入的值本身不是一个Promise，那么会将该Promise的状态变成 兑现（fulfilled）；</p></li><li><p>在之后我们去调用reject时，已经不会有任何的响应了（并不是这行代码不会执行，而是无法改变Promise状态）；</p></li></ul><h3 id="resolve不同值的区别"><a href="#resolve不同值的区别" class="headerlink" title="resolve不同值的区别"></a>resolve不同值的区别</h3><ul><li>情况一：如果resolve传入一个普通的值或者对象，那么这个值会作为then回调的参数；</li></ul><p><img src="https://gitee.com/Yuukyou/pic/raw/master/blog/image-20220420104658089.png" alt="image-20220420104658089"></p><ul><li>情况二：如果resolve中传入的是另外一个Promise，那么这个新Promise会决定原Promise的状态： </li></ul><p><img src="https://gitee.com/Yuukyou/pic/raw/master/blog/image-20220420104713591.png" alt="image-20220420104713591"></p><ul><li> 情况三：如果resolve中传入的是一个对象，并且这个对象有<strong>实现then方法（thenable）</strong>，那么会执行该then方法，并且根据then方法的结果来决定Promise的状态：</li></ul><p><img src="https://gitee.com/Yuukyou/pic/raw/master/blog/image-20220420104726554.png" alt="image-20220420104726554"></p><h3 id="then方法"><a href="#then方法" class="headerlink" title="then方法"></a>then方法</h3><p>（then方法是<strong>实例方法</strong>）</p><p>1、传入两个参数</p><ul><li><p>then方法是Promise对象上的一个方法：它其实是放在Promise的原型上的 Promise.prototype.then</p></li><li><p>then方法接受两个参数：</p><ul><li><p>fulfilled的回调函数：当状态变成fulfilled时会回调的函数；</p></li><li><p>preject的回调函数：当状态变成reject时会回调的函数；</p></li></ul></li></ul><p><img src="https://gitee.com/Yuukyou/pic/raw/master/blog/image-20220420105359828.png" alt="image-20220420105359828"></p><p>2、多次调用</p><ul><li><p> 一个Promise的then方法是可以被多次调用的：</p></li><li><p>每次调用我们都可以传入对应的fulfilled回调；</p></li><li><p>当Promise的状态变成fulfilled的时候，这些回调函数都会被执行；</p></li></ul><p><img src="https://gitee.com/Yuukyou/pic/raw/master/blog/image-20220420105516633.png" alt="image-20220420105516633"></p><p>3、返回值</p><ul><li><p>then方法本身是有返回值的，它的<strong>返回值是一个Promise</strong>，所以我们可以进行如下的链式调用： </p><ul><li>但是then方法返回的Promise到底处于什么样的状态呢？ </li></ul></li><li><p>Promise有三种状态，那么这个Promise处于什么状态呢？</p><ul><li><p>当then方法中的回调函数本身在执行的时候，那么它处于pending状态；</p></li><li><p>当then方法中的回调函数返回一个结果时，那么它处于fulfilled状态，并且会将结果<strong>作为resolve的参数</strong>；</p><ul><li><p> 情况一：返回一个普通的值； </p></li><li><p> 情况二：返回一个Promise； </p></li><li><p> 情况三：返回一个thenable值； </p></li></ul></li><li><p>当then方法抛出一个异常时，那么它处于reject状态；</p></li></ul></li></ul><h3 id="catch方法"><a href="#catch方法" class="headerlink" title="catch方法"></a>catch方法</h3><p>（catch方法是<strong>实例方法</strong>）</p><p>返回值</p><ul><li><p> 事实上catch方法也是会<strong>返回一个Promise对象</strong>的，所以catch方法后面我们可以继续调用then方法或者catch方法：</p></li><li><p>下面的代码，后续是catch中的err2打印，还是then中的res打印呢？</p></li><li><p>答案是res打印，这是因为catch传入的回调在执行完后，默认状态依然会是fulfilled的；</p></li></ul><p><img src="https://gitee.com/Yuukyou/pic/raw/master/blog/image-20220420105901104.png" alt="image-20220420105901104"></p><ul><li> 那么如果我们希望后续继续执行catch，那么需要抛出一个异常：</li></ul><p><img src="https://gitee.com/Yuukyou/pic/raw/master/blog/image-20220420105918465.png" alt="image-20220420105918465"></p><h3 id="finally方法"><a href="#finally方法" class="headerlink" title="finally方法"></a>finally方法</h3><p>（finally方法是<strong>实例方法</strong>）</p><ul><li><p>finally是在ES9（ES2018）中新增的一个特性：表示无论Promise对象无论变成fulfilled还是reject状态，<strong>最终都会被执行的代码</strong>。 </p></li><li><p> finally方法是不接收参数的，因为无论前面是fulfilled状态，还是reject状态，它都会执行。</p></li></ul><p><img src="https://gitee.com/Yuukyou/pic/raw/master/blog/image-20220420110115998.png" alt="image-20220420110115998"></p><h3 id="resolve方法"><a href="#resolve方法" class="headerlink" title="resolve方法"></a>resolve方法</h3><ul><li><p> 前面我们学习的then、catch、finally方法都属于Promise的实例方法，都是存放在Promise的prototype上的。 </p></li><li><p>下面我们再来学习一下Promise的类方法。 </p></li><li><p>有时候我们已经有一个现成的内容了，希望将其转成Promise来使用，这个时候我们可以使用 Promise.resolve 方法来完成。 </p><ul><li>Promise.resolve的用法相当于new Promise，并且执行resolve操作：</li></ul><pre><code class="line-numbers language-js">Promise.resolve("why")// 等价于new Promise((resolve) =&gt; resolve("why"))</code></pre></li><li><p> resolve参数的形态：</p></li><li><p>情况一：参数是一个普通的值或者对象</p></li><li><p>情况二：参数本身是Promise</p></li><li><p>情况三：参数是一个thenable</p></li></ul><h3 id="reject方法"><a href="#reject方法" class="headerlink" title="reject方法"></a>reject方法</h3><ul><li><p> reject方法类似于resolve方法，只是会将Promise对象的状态设置为reject状态。 </p></li><li><p>Promise.reject的用法相当于new Promise，只是会调用reject：</p></li></ul><pre><code class="line-numbers language-js">Promise.reject("why")// 等价于new Promise((resolve, reject) =&gt; reject("why"))</code></pre><ul><li> Promise.reject传入的参数无论是什么形态，都会直接作为reject状态的参数传递到catch的。</li></ul><h3 id="all方法"><a href="#all方法" class="headerlink" title="all方法"></a>all方法</h3><ul><li><p>另外一个类方法是Promise.all： </p><ul><li><p>它的作用是将多个Promise包裹在一起形成一个新的Promise； </p></li><li><p>新的Promise状态由包裹的所有Promise共同决定：</p><ul><li><p>当所有的Promise状态变成fulfilled状态时，新的Promise状态为fulfilled，并且会将所有Promise的返回值 <strong>组成一个数组</strong>； </p></li><li><p>当有一个Promise状态为reject时，新的Promise状态为reject，并且会将<strong>第一个reject的返回值作为参数</strong>；</p></li></ul></li></ul></li></ul><p><img src="https://gitee.com/Yuukyou/pic/raw/master/blog/image-20220420112157782.png" alt="image-20220420112157782"></p><p><img src="https://gitee.com/Yuukyou/pic/raw/master/blog/image-20220420112213327.png" alt="image-20220420112213327"></p><h3 id="allSettled方法"><a href="#allSettled方法" class="headerlink" title="allSettled方法"></a>allSettled方法</h3><ul><li><p>all方法有一个缺陷：当有其中一个Promise变成reject状态时，新Promise就会立即变成对应的reject状态。 </p><ul><li>那么对于resolved的，以及依然处于pending状态的Promise，我们是获取不到对应的结果的；</li></ul></li><li><p>在ES11（ES2020）中，添加了新的API Promise.allSettled： </p><ul><li>该方法会在所有的Promise都有结果（settled），无论是fulfilled，还是reject时，才会有最终的状态；</li><li>并且这个Promise的结果一定是fulfilled的；</li></ul></li></ul><p><img src="https://gitee.com/Yuukyou/pic/raw/master/blog/image-20220420112826804.png" alt="image-20220420112826804"></p><ul><li><p>我们来看一下打印的结果：</p><ul><li><p>allSettled的结果是一个数组，数组中存放着每一个Promise的结果，并且是对应一个对象的；</p></li><li><p>这个对象中包含status状态，以及对应的value值；</p></li></ul></li></ul><h3 id="race方法"><a href="#race方法" class="headerlink" title="race方法"></a>race方法</h3><ul><li>如果有一个Promise有了结果，我们就希望决定最终新Promise的状态，那么可以使用race方法：<ul><li>race是竞技、竞赛的意思，表示多个Promise相互竞争，谁先有结果，那么就使用谁的结果；</li></ul></li></ul><p><img src="https://gitee.com/Yuukyou/pic/raw/master/blog/image-20220420112905455.png" alt="image-20220420112905455"></p><h3 id="any方法"><a href="#any方法" class="headerlink" title="any方法"></a>any方法</h3><ul><li><p>any方法是ES12中新增的方法，和race方法是类似的：</p><ul><li><p>any方法会等到一个fulfilled状态，才会决定新Promise的状态；</p></li><li><p>如果所有的Promise都是reject的，那么也会等到所有的Promise都变成rejected状态；</p></li></ul></li><li><p> 如果所有的Promise都是reject的，那么会报一个AggregateError的错误。</p></li></ul><p><img src="https://gitee.com/Yuukyou/pic/raw/master/blog/image-20220420112952867.png" alt="image-20220420112952867"></p>]]></content>
      
      
      
        <tags>
            
            <tag> promise </tag>
            
            <tag> JavaScript高级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode剑指offer刷题笔记</title>
      <link href="2022/04/18/leetcode/"/>
      <url>2022/04/18/leetcode/</url>
      
        <content type="html"><![CDATA[<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h4 id="BFS（广度优先）、层序遍历"><a href="#BFS（广度优先）、层序遍历" class="headerlink" title="BFS（广度优先）、层序遍历"></a>BFS（广度优先）、层序遍历</h4><p>I、</p><p><img src="https://gitee.com/Yuukyou/pic/raw/master/blog/image-20220418211443839.png" alt="image-20220418211443839"></p><p>疑点：<strong>js如何实现构建二叉树？</strong></p><pre><code class="line-numbers language-js">/** * Definition for a binary tree node. * function TreeNode(val) { *     this.val = val; *     this.left = this.right = null; * } *//** * @param {TreeNode} root * @return {number[]} */var levelOrder = function (root) {  // 非空判定  if (root == null) {    return [];  }  // BFS 广度优先搜索  let queue = [root],    //队列中放的是树！！不是某个    res = [];  while (queue.length) {    // 队头出    let node = queue.shift();    //此时对头是根节点，一整棵树！    res.push(node.val);    // 把当前元素的左右子节点加入队列 -----左右节点，也是一整颗子树！    if (node.left) queue.push(node.left);    if (node.right) queue.push(node.right);  }  return res;};</code></pre><p>II、<strong>记录树的深度</strong></p><p><img src="https://gitee.com/Yuukyou/pic/raw/master/blog/image-20220420211046404.png" alt="image-20220420211046404"></p><p>代码随想录层序<strong>遍历模板</strong>：（记录深度）</p><pre><code class="line-numbers language-js">var levelOrder = function(root) {    //二叉树的层序遍历    let res=[],queue=[];    queue.push(root);    if(root===null){        return res;    }    while(queue.length!==0){        // 记录当前层级节点数---列队的长度就是当前层的节点个数        let length=queue.length;        //存放每一层的节点         let curLevel=[];        for(let i=0;i&lt;length;i++){            let node=queue.shift();            curLevel.push(node.val);            // 存放当前层下一层的节点            node.left&amp;&amp;queue.push(node.left);            node.right&amp;&amp;queue.push(node.right);        }        //把每一层的结果放到结果数组        res.push(curLevel);    }    return res;};</code></pre><p>III、之字形打印</p><p><img src="https://gitee.com/Yuukyou/pic/raw/master/blog/image-20220421012929060.png" alt="image-20220421012929060"></p><p>原理和记录深度情况II相同</p><ul><li>注意单双数标识符 j 写在while循环外，不然每次while循环j又回到1</li><li>当层数为偶数时，从队列（准确来说是栈）尾巴弹出，扫描到左右子树时需要<strong>将左右子树反向添加到队头</strong>（ **.unshift()**函数 ），不然下一次循环就会扫描到该层子树节点而不是该层节点。（大坑，坑了我一个小时，我是废物我是废物我是废物）</li></ul><pre><code class="line-numbers language-js">/** * Definition for a binary tree node. * function TreeNode(val) { *     this.val = val; *     this.left = this.right = null; * } *//** * @param {TreeNode} root * @return {number[][]} */var levelOrder = function(root) {    let queue=[root]    let res = []    let j = 1    if (!root) return res    while(queue.length){        let current = []        let length = queue.length        if (j%2 === 0){            // 偶数            for(let i = 0; i&lt;length; i++){                let node = queue.pop()                current.push(node.val)                node.right &amp;&amp; queue.unshift(node.right)    //偶数时注意将左右叶子节点从头添加，不是从后推入                node.left &amp;&amp; queue.unshift(node.left)            }        }else{            // 奇数            for(let i = 0; i&lt;length; i++){                let node = queue.shift()                current.push(node.val)                node.left &amp;&amp; queue.push(node.left)                node.right &amp;&amp; queue.push(node.right)            }        }        res.push(current)        j = j + 1    }    return res};</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解JavaScript</title>
      <link href="2022/04/17/javaScripRun/"/>
      <url>2022/04/17/javaScripRun/</url>
      
        <content type="html"><![CDATA[<h3 id="一、深入JavaScript运行原理"><a href="#一、深入JavaScript运行原理" class="headerlink" title="一、深入JavaScript运行原理"></a>一、深入JavaScript运行原理</h3><h4 id="浏览器工作原理"><a href="#浏览器工作原理" class="headerlink" title="浏览器工作原理"></a>浏览器工作原理</h4><p><img src="https://gitee.com/Yuukyou/pic/raw/master/blog/image-20220417173216309.png" alt="image-20220417173216309"></p><p>输入服务器地址发送请求，下载index.html，碰见什么标签下载什么资源（详细见：<strong>浏览器从输入url到页面展示经历了什么</strong>）</p><h4 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h4><p>我们经常会说：不同的浏览器有不同的内核组成</p><ul><li>Gecko：早期被Netscape和Mozilla Firefox浏览器浏览器使用；</li><li>Trident：微软开发，被IE4~IE11浏览器使用，但是Edge浏览器已经转向Blink； </li><li>Webkit：苹果基于KHTML开发、开源的，用于Safari，Google Chrome之前也在使用；</li><li>Blink：是Webkit的一个分支，Google开发，目前应用于Google Chrome、Edge、Opera等；</li><li>等等…</li></ul><p>事实上，我们经常说的浏览器内核指的是浏览器的排版引擎： </p><p><strong>排版引擎</strong>（layout engine），也称为<strong>浏览器引擎</strong>（browser engine）、<strong>页面渲染引擎</strong>（rendering engine） </p><p>或<strong>样版引擎</strong>。</p><p><img src="https://gitee.com/Yuukyou/pic/raw/master/blog/image-20220417173624607.png" alt="image-20220417173624607"></p><h4 id="V8引擎的原理"><a href="#V8引擎的原理" class="headerlink" title="V8引擎的原理"></a><strong>V8引擎的原理</strong></h4><p><img src="https://gitee.com/Yuukyou/pic/raw/master/blog/image-20220417173902385.png" alt="image-20220417173902385"></p><ul><li><p>V8引擎本身的源码<strong>非常复杂</strong>，大概有超过<strong>100w行C++代码</strong>，通过了解它的架构，我们可以知道它是如何对JavaScript执行的：</p></li><li><p>Parse模块会将JavaScript代码转换成<strong>AST（抽象语法树）</strong>，这是因为解释器并不直接认识JavaScript代码</p><ul><li>如果函数没有被调用，那么是不会被转换成AST的；</li><li>Parse的V8官方文档：<a href="https://v8.dev/blog/scanner">https://v8.dev/blog/scanner</a></li></ul></li><li><p>Ignition是一个解释器，会将AST转换成ByteCode（字节码）<br>时会收集TurboFan优化所需要的信息（比如函数参数的类型信息，有了类型才能进行真实的运算）；</p><ul><li>如果函数只调用一次，Ignition会执行解释执行ByteCode； </li><li>Ignition的V8官方文档：<a href="https://v8.dev/blog/ignition-interpreter">https://v8.dev/blog/ignition-interpreter</a></li></ul></li><li><p>TurboFan是一个编译器，可以将字节码编译为CPU可以直接执行的机器码；</p><ul><li>如果一个函数被多次调用，那么就会被标记为热点函数，那么就会经过TurboFan转换成优化的机器码，提高代码的执行性能； </li><li>但是，机器码实际上也会被还原为ByteCode，这是因为如果后续执行函数的过程中，类型发生了变化（比如sum函数原来执行的是number类型，后来执行变成了string类型），之前优化的机器码并不能正确的处理运算，就会逆向的转换成字节码；</li><li>TurboFan的V8官方文档：<a href="https://v8.dev/blog/turbofan-jit">https://v8.dev/blog/turbofan-jit</a></li></ul></li></ul><h4 id="JavaScript执行过程"><a href="#JavaScript执行过程" class="headerlink" title="JavaScript执行过程"></a>JavaScript执行过程</h4><p>1、初始化全局对象</p><ul><li>js引擎会在<strong>执行代码之前</strong>，会在堆内存中创建一个<strong>全局对象</strong>：Global Object（GO） <ul><li>该对象 <strong>所有的作用域</strong>（scope）都可以访问； </li><li>里面会包含Date、Array、String、Number、setTimeout、setInterval等等；</li><li>其中还有一个<strong>window属性</strong>指向自己；</li></ul></li></ul><p><img src="https://gitee.com/Yuukyou/pic/raw/master/blog/image-20220417174820779.png" alt="image-20220417174820779"></p><p>2、执行上下文栈（调用栈）</p><ul><li><p> js引擎内部有一个<strong>执行上下文栈（Execution Context Stack，简称ECS）</strong>，它是用于执行<strong>代码的调用栈</strong>。 </p></li><li><p>那么现在它要执行谁呢？执行的是<strong>全局的代码块</strong>： </p><ul><li><p>全局的代码块为了执行会构建一个 <strong>Global Execution Context（GEC）</strong>； </p></li><li><p>GEC会 被放入到ECS中 执行；</p></li></ul></li><li><p><strong>GEC被放入到ECS中里面包含两部分内容：</strong></p><ul><li><strong>第一部分：</strong>在代码执行前，<strong>在parser转成AST的过程</strong>中，会将全局定义的变量、函数等加入到GlobalObject中，但是并<strong>不会赋值</strong>；</li><li>这个过程也称之为<strong>变量的作用域提升</strong>（hoisting） </li></ul></li><li><p><strong>第二部分：</strong>在代码执行中，对变量赋值，或者执行其他的函数；</p></li></ul><p><img src="https://gitee.com/Yuukyou/pic/raw/master/blog/image-20220417192058830.png" alt="image-20220417192058830"></p><p><img src="https://gitee.com/Yuukyou/pic/raw/master/blog/image-20220417192110808.png" alt="image-20220417192110808"></p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VUE头条后台项目总结</title>
      <link href="2022/04/12/toutiao-admin/"/>
      <url>2022/04/12/toutiao-admin/</url>
      
        <content type="html"><![CDATA[<h3 id="VUE标签及属性"><a href="#VUE标签及属性" class="headerlink" title="VUE标签及属性"></a>VUE标签及属性</h3><h4 id="1、-lt-template-gt"><a href="#1、-lt-template-gt" class="headerlink" title="1、< template >"></a>1、&lt; template &gt;</h4><p>template是模板占位符，可以帮助我们包裹元素，但template并不会渲染在DOM节点中</p><p>，并且template还可以使用v-for等指令，vue实例绑定的元素内部的template标签不支持v-show指令，即v-show=”false”对template标签来说不起作用。但是此时的template标签支持v-if、v-else-if、v-else、v-for这些指令。</p><blockquote><p>拓展：VUE生命周期，template和render函数渲染次序</p></blockquote><h4 id="2、-lt-style-scop-gt"><a href="#2、-lt-style-scop-gt" class="headerlink" title="2、< style  scop >"></a>2、&lt; style  scop &gt;</h4><p>加上scop表示样式作用域，只作用于当前文件。（不同文件的同名样式会导致冲突，后导入的包会覆盖之前的）</p><p>&lt; style  scop lang=“less”&gt; 其中lang表示编译方式，默认是css</p><h4 id="3、prop"><a href="#3、prop" class="headerlink" title="3、prop"></a>3、prop</h4><ul><li><p>prop的作用就是父组件向子组件单向传递数据，该过程是单向的，传递的属性可以是静态的，也可以是动态的，可以是数字、字符串、数组、对象以及校验函数进行校验。</p></li><li><p>所有的prop都使得其父子组件之间形成了一个单向下行绑定：父组件的prop的更新会向下流动到子组件中，但反过来不行，这样就会防止从子组件意外改变父组件以及同级子组件的状态，从而导致应用的数据流难以理解。</p></li><li><p>每次父组件发生更新时，子组件中所有的prop都将刷新为最新的值，意味着不能在子组件内部改变prop，这样的话Vue会在控制台抛出一个警告。</p></li><li><p>在正常情况下，一般在父组件中通过v-bind定义一个动态值，子组件通过Prop接收该值，所以，很多人认为，Prop只能接收动态值。但是，其实Prop可以接受静态属性。</p></li></ul><blockquote><p><strong>tips：由于HTML中的属性是不区分大小写的，所以当使用DOM中的模板（HTML中）时，驼峰写法需要转化为短横线写法。但是，如果使用字符串模板（JS中）时，不受限制，可以为所欲为。</strong></p></blockquote><h4 id="4、-v-for-：key-diff算法"><a href="#4、-v-for-：key-diff算法" class="headerlink" title="4、 v-for ：key(diff算法)"></a>4、 v-for ：key(diff算法)</h4><p><img src="https://gitee.com/Yuukyou/pic/raw/master/blog/image-20220413234024899.png" alt="image-20220413234024899"></p><p><img src="https://gitee.com/Yuukyou/pic/raw/master/blog/image-20220413234105407.png" alt="image-20220413234105407"></p><p>面试题：react、vue中的key有什么作用？（key的内部原理）（<strong>diff算法</strong>）</p><pre><code class="line-numbers language-html">1. 虚拟DOM中key的作用：    key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】, 随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：                                    2.对比规则：    (1).旧虚拟DOM中找到了与新虚拟DOM相同的key：        ①.若虚拟DOM中内容没变, 直接使用之前的真实DOM！        ②.若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM。    (2).旧虚拟DOM中未找到与新虚拟DOM相同的key        创建新的真实DOM，随后渲染到到页面。                                            3. 用index作为key可能会引发的问题：    1. 若对数据进行：逆序添加、逆序删除等破坏顺序操作:    会产生没有必要的真实DOM更新 ==&gt; 界面效果没问题, 但效率低。    2. 如果结构中还包含输入类的DOM：    会产生错误DOM更新 ==&gt; 界面有问题。4. 开发中如何选择key?:    1.最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值。    2.如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，使用index作为key是没有问题的。</code></pre><h4 id="5、-sync、-native、"><a href="#5、-sync、-native、" class="headerlink" title="5、 .sync、.native、"></a>5、 .sync、.native、</h4><h4 id="6、插槽（slot）：匿名、具名、作用域"><a href="#6、插槽（slot）：匿名、具名、作用域" class="headerlink" title="6、插槽（slot）：匿名、具名、作用域"></a>6、插槽（slot）：匿名、具名、作用域</h4><ol><li><p>作用：让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式，适用于 <strong>父组件 ===&gt; 子组件</strong> 。</p></li><li><p>分类：默认插槽、具名插槽、作用域插槽</p></li><li><p>使用方式：</p><ol><li><p>默认插槽：</p><pre><code class="line-numbers language-vue">父组件中：        &lt;Category&gt;           &lt;div&gt;html结构1&lt;/div&gt;        &lt;/Category&gt;子组件中：        &lt;template&gt;            &lt;div&gt;               &lt;!-- 定义插槽 --&gt;               &lt;slot&gt;插槽默认内容...&lt;/slot&gt;            &lt;/div&gt;        &lt;/template&gt;</code></pre></li><li><p>具名插槽：</p><pre><code class="line-numbers language-vue">父组件中：        &lt;Category&gt;            &lt;template slot="center"&gt;              &lt;div&gt;html结构1&lt;/div&gt;            &lt;/template&gt;            &lt;template v-slot:footer&gt;               &lt;div&gt;html结构2&lt;/div&gt;            &lt;/template&gt;        &lt;/Category&gt;子组件中：        &lt;template&gt;            &lt;div&gt;               &lt;!-- 定义插槽 --&gt;               &lt;slot name="center"&gt;插槽默认内容...&lt;/slot&gt;               &lt;slot name="footer"&gt;插槽默认内容...&lt;/slot&gt;            &lt;/div&gt;        &lt;/template&gt;</code></pre></li><li><p>作用域插槽：</p><ol><li><p>理解：数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。（games数据在Category组件中，但使用数据所遍历出来的结构由App组件决定）（<strong>子组件向父组件传递数据</strong>）</p></li><li><p>具体编码：</p><pre><code class="line-numbers language-vue">父组件中：        &lt;Category&gt;            &lt;template scope="scopeData"&gt;                &lt;!-- 生成的是ul列表 --&gt;                &lt;ul&gt;                    &lt;li v-for="g in scopeData.games" :key="g"&gt;{{g}}&lt;/li&gt;                &lt;/ul&gt;            &lt;/template&gt;        &lt;/Category&gt;        &lt;Category&gt;            &lt;template slot-scope="scopeData"&gt;                &lt;!-- 生成的是h4标题 --&gt;                &lt;h4 v-for="g in scopeData.games" :key="g"&gt;{{g}}&lt;/h4&gt;            &lt;/template&gt;        &lt;/Category&gt;子组件中：        &lt;template&gt;            &lt;div&gt;                &lt;slot :games="games"&gt;&lt;/slot&gt;            &lt;/div&gt;        &lt;/template&gt;                &lt;script&gt;            export default {                name:'Category',                props:['title'],                //数据在子组件自身                data() {                    return {                        games:['红色警戒','穿越火线','劲舞团','超级玛丽']                    }                },            }        &lt;/script&gt;</code></pre></li></ol></li></ol></li></ol><h3 id="删除文章失败？（JS大数字问题）"><a href="#删除文章失败？（JS大数字问题）" class="headerlink" title="删除文章失败？（JS大数字问题）"></a>删除文章失败？（JS大数字问题）</h3><p>JavaScript 能够准确表示的整数范围在<code>-2^53</code>到<code>2^53</code>之间（不含两个端点），超过这个范围，无法精确表示这个值，这使得 JavaScript 不适合进行科学和金融方面的精确计算。</p><p>关于一些json方法：</p><p><strong>JSON 的常规用途是同 web 服务器进行数据传输。</strong></p><p><strong>在从 web 服务器接收数据时，数据永远是字符串。</strong></p><p><strong>通过 JSON.parse() 解析数据，这些数据会成为 JavaScript 对象。</strong></p><pre><code class="line-numbers language-js">/*将服务器端接受的数据转换为js对象*/JSON.parse()  </code></pre><p><strong>在向 web 服务器发送数据时，数据必须是字符串。</strong></p><p><strong>通过 JSON.stringify() 把 JavaScript 对象转换为字符串。</strong></p><pre><code>/*将js对象转换为字符串发送给服务器*/JSON.stringify()  </code></pre><p>json-bigint 会把超出 JS 安全整数范围的数字转为一个 BigNumber 类型的对象，对象数据是它内部的一个算法处理之后的，我们要做的就是在使用的时候转为字符串来使用。 </p><p>axios 为了方便我们使用数据，它会在内部使用 <code>JSON.parse()</code> 把后端返回的数据转为 JavaScript 对象，</p><pre><code>解决思路：Axios 会在内部使用 JSON.parse 把后端返回的数据转为 JavaScript 数据对象。所以解决思路就是：不要让 axios 使用 JSON.parse 来转换这个数据，而是使用 json-biginit 来做转换处理。axios 提供了一个 API：transformResponse，在这里对返回的原数据进行操作</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScrip高级</title>
      <link href="2022/01/01/JavaScrip/"/>
      <url>2022/01/01/JavaScrip/</url>
      
        <content type="html"><![CDATA[<h3 id="一、super-关键字"><a href="#一、super-关键字" class="headerlink" title="一、super 关键字"></a>一、super 关键字</h3><blockquote><h3 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h3></blockquote><ol><li>super调用父类构造函数</li></ol><p>super关键字可以让子类的构造函数调用父类的构造函数，变量指向上一级</p><pre><code class="line-numbers language-js">    class Father {        constructor(x, y) {            this.x = x;            this.y = y;        }        sum() {            console.log(this.x + this.y);        }    }    class Son extends Father {        constructor(x, y) {            super(x, y); //调用了父类中的构造函数         // this.x = x;         // this.y = y;        }    }        var son = new Son(1, 2);        var son1 = new Son(11, 22);        son.sum();        son1.sum();</code></pre><p>在子类构造函数中如果直接写 this.x  = x ，那么实例化对象时，调用的是子类的构造函数，父类没有得到x、y。 son 想要调用 father 的sum（）方法，sum方法中的x，y都是父类的，所以sum没有办法相加。</p><p> &nbsp; &nbsp;sum中的this.x必须是从sum中构造函数获取的</p><p>    如果构造函数中有super 那么super必须放在最前面</p><ol start="2"><li>super调用父类普通方法</li></ol><pre><code class="line-numbers language-js">    // super 关键字调用父类普通函数    class Father {        say() {            return '我是爸爸';        }    }    class Son extends Father {        say() {            // console.log('我是儿子');            console.log(super.say() + '的儿子');            // super.say() 就是调用父类中的普通函数 say()        }    }    var son = new Son();    son.say();    // 继承中的属性或者方法查找原则: 就近原则    // 1. 继承中,如果实例化子类输出一个方法,先看子类有没有这个方法,如果有就先执行子类的    // 2. 继承中,如果子类里面没有,就去查找父类有没有这个方法,如果有,就执行父类的这个方法(就近原则)&lt;/script&gt;</code></pre><p>在子类中 super.say() 可以直接调用父类的say方法；继承中的属性或者方法查找原则: <strong>就近原则</strong></p><h3 id="二、this关键字"><a href="#二、this关键字" class="headerlink" title="二、this关键字"></a>二、this关键字</h3><blockquote><h3 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h3></blockquote><ol><li>在 ES6 中类没有变量提升，所以必须先定义类，才能通过类实例化对象.</li><li>类里面的共有属性和方法一定要加this使用.</li><li>类里面的this指向问题. </li><li>constructor 里面的this指向实例对象, 方法里面的this 指向这个方法的调用</li></ol><h3 id="三、构造函数和原型"><a href="#三、构造函数和原型" class="headerlink" title="三、构造函数和原型"></a>三、构造函数和原型</h3><blockquote><h3 id="构造函数和原型"><a href="#构造函数和原型" class="headerlink" title="构造函数和原型"></a>构造函数和原型</h3></blockquote><h4 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1. 构造函数"></a>1. 构造函数</h4><p>在 ES6之前 ，对象不是基于类创建的，而是用一种称为构建函数的特殊函数来定义对象和它们的特征。</p><p>创建对象可以通过以下三种方式：</p><ol><li><p>对象字面量</p></li><li><p>new Object()</p></li><li><p>自定义构造函数</p></li></ol><p>构造函数存在的问题：（内存浪费）</p><p>每新建一个构造函数就会开辟一个新的内存空间，同一个函数也会单独开辟新的空间，造成内存浪费。</p><p><img src="https://gitee.com/Yuukyou/pic/raw/master/blog/image-20220417172029775.png" alt="image-20220417172029775"></p><h4 id="2-构造函数原型prototype"><a href="#2-构造函数原型prototype" class="headerlink" title="2.构造函数原型prototype"></a>2.构造函数原型prototype</h4><p>JavaScript 规定，<strong>每一个构造函数都有一个 prototype 属性</strong>，指向另一个对象。注意这个 prototype 就<strong>是一个对象</strong>，这个对象的所有属性和方法，都会被构造函数所拥有。<br><strong>我们可以把那些不变的方法，直接定义在 prototype 对象上，这样所有对象的实例就可以共享这些方法。</strong></p><p>问答？</p><ol><li>原型是什么 ？<br>一个<strong>对象</strong>，我们也称为 prototype 为原型对象。</li><li>原型的作用是什么 ？<br>共享方法。</li></ol><p>一般情况下，将公共属性定义到构造函数里，公共方法定义到原型对象上</p><h4 id="3-对象原型-proto"><a href="#3-对象原型-proto" class="headerlink" title="3. 对象原型__proto__"></a>3. 对象原型__proto__</h4><pre><code class="line-numbers language-js">    function Star(uname, age) {        this.uname = uname;        this.age = age;    }    Star.prototype.sing = function() {        console.log('我会唱歌');    }    var ldh = new Star('刘德华', 18);    var zxy = new Star('张学友', 19);    ldh.sing();    console.log(ldh); // 对象身上系统自己添加一个 __proto__ 指向我们构造函数的原型对象 prototype    console.log(ldh.__proto__ === Star.prototype);    // 方法的查找规则: 首先先看ldh 对象身上是否有 sing 方法,如果有就执行这个对象上的sing    // 如果么有sing 这个方法,因为有__proto__ 的存在,就去构造函数原型对象prototype身上去查找sing这个方法</code></pre><p>方法的<strong>查找规则</strong>:</p><ol><li> 首先先看ldh 对象身上是否有 sing 方法,如果有就执行这个对象上的sing</li><li>如果么有sing 这个方法,因为有__proto__ 的存在,就去构造函数原型对象prototype身上去查找sing这个方法</li></ol><p>对象都会有一个属性 <strong>proto</strong> 指向构造函数的 prototype 原型对象，之所以我们对象可以使用构造函数 prototype 原型对象的属性和方法，就是因为对象有 <strong>proto</strong> 原型的存在。</p><ul><li>__proto__对象原型和原型对象 prototype 是等价的</li><li>__proto__对象原型的意义就在于为对象的查找机制提供一个方向，或者说一条路线，但是它是一个非标准属性，<em>因此实际开发中，不可以使用这个属性，它只是内部指向原型对象 prototype</em></li></ul><h4 id="4-constructor构造函数"><a href="#4-constructor构造函数" class="headerlink" title="4. constructor构造函数"></a>4. constructor构造函数</h4><pre><code class="line-numbers language-js">    function Star(uname, age) {        this.uname = uname;        this.age = age;    }    // 很多情况下,我们需要手动的利用constructor 这个属性指回 原来的构造函数    // Star.prototype.sing = function() {    //     console.log('我会唱歌');    // };    // Star.prototype.movie = function() {    //     console.log('我会演电影');    // }    Star.prototype = {        // 如果我们修改了原来的原型对象,给原型对象赋值的是一个对象,则必须手动的利用constructor指回原来的构造函数        constructor: Star,        sing: function() {            console.log('我会唱歌');        },        movie: function() {            console.log('我会演电影');        }    }    var ldh = new Star('刘德华', 18);    var zxy = new Star('张学友', 19);</code></pre><p>很多情况( 公共函数很多时 )下，我们需要重写原型对象prototype，这时候需要手动的利用constructor 这个属性指回 原来的构造函数，例如上段代码的14行。</p><h4 id="5-构造函数、实例、原型对象三者之间的关系"><a href="#5-构造函数、实例、原型对象三者之间的关系" class="headerlink" title="5. 构造函数、实例、原型对象三者之间的关系"></a>5. 构造函数、实例、原型对象三者之间的关系</h4><p><img src="https://gitee.com/Yuukyou/pic/raw/master/blog/image-20220417172049633.png" alt="image-20220417172049633"></p><p>构造函数是原型对象的父级，原型对象通过构造函数创建出来。</p><p>实例对象通过原型对象指向（找到）构造函数<code>ldh.__proto__.constructor</code></p><h4 id="6-原型链（面试很容易问到）"><a href="#6-原型链（面试很容易问到）" class="headerlink" title="6. 原型链（面试很容易问到）"></a>6. 原型链（<strong>面试很容易问到</strong>）</h4><p><img src="https://gitee.com/Yuukyou/pic/raw/master/blog/image-20220417172057243.png" alt="image-20220417172057243"></p><p>原型对象prototype也是一个对象，它也有也有对象原型__ proto __，它指向Object原型对象prototype，Object原型对象的原型对象指向空。即Object就是所有类的父类。</p><p>面试可能让你画原型链。</p><p>JS的成员查找规则：</p><ol><li>当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性。</li><li>如果没有就查找它的原型（也就是 __proto__指向的 prototype 原型对象）。</li><li>如果还没有就查找原型对象的原型（Object的原型对象）。</li><li>依此类推一直找到 Object 为止（null）。</li><li>__proto__对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线。</li></ol><p>简而言之，顺着原型链往上找（<strong>就近原则</strong>）。</p><p><strong>原型对象this指向（面试常考问题）</strong>：不管是构造函数里面的this还是原型对象里面的this，都指向实例对象。</p><h3 id="四、继承"><a href="#四、继承" class="headerlink" title="四、继承"></a>四、继承</h3><p>ES6之前并没有给我们提供 extends 继承。我们可以通过<strong>构造函数+原型对象</strong>模拟实现继承，被称为组合继承。</p><h4 id="1-1借用构造函数继承父类属性"><a href="#1-1借用构造函数继承父类属性" class="headerlink" title="1.1借用构造函数继承父类属性"></a>1.1借用构造函数继承父类<strong>属性</strong></h4><p>核心原理： 通过 call() 把父类型的 this 指向子类型的 this ，这样就可以实现子类型继承父类型的属性。   </p><pre><code class="line-numbers language-js">    // 父类    function Person(name, age, sex) {      this.name = name;      this.age = age;      this.sex = sex;    }    // 子类    function Student(name, age, sex, score) {      Person.call(this, name, age, sex);  // 此时父类的 this 指向子类的 this，同时调用这个函数      this.score = score;    }    var s1 = new Student('zs', 18, '男', 100);    console.dir(s1); </code></pre><h4 id="1-2借用原型对象继承方法"><a href="#1-2借用原型对象继承方法" class="headerlink" title="1.2借用原型对象继承方法"></a>1.2借用原型对象继承方法</h4><p>没太听懂。保留：P14-P15  P5面试重点</p><h4 id="2-类的本质"><a href="#2-类的本质" class="headerlink" title="2.类的本质"></a>2.类的本质</h4><ol><li>class本质还是function.</li><li> 类的所有方法都定义在类的prototype属性上</li><li> 类创建的实例,里面也有__proto__ 指向类的prototype原型对象</li><li>所以ES6的类它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。</li><li>所以ES6的类其实就是语法糖.</li></ol><p>一些个构造函数的特征（类和构造函数特征一样）：</p><pre><code>    // (1) 构造函数有原型对象prototype     // (2) 构造函数原型对象prototype 里面有constructor 指向构造函数本身    // (3) 构造函数可以通过原型对象添加方法    // (4) 构造函数创建的实例对象有__proto__ 原型指向 构造函数的原型对象</code></pre><h3 id="五、ES5中新增的方法（数组、字符串、对象方法）"><a href="#五、ES5中新增的方法（数组、字符串、对象方法）" class="headerlink" title="五、ES5中新增的方法（数组、字符串、对象方法）"></a>五、ES5中新增的方法（数组、字符串、对象方法）</h3><ol><li>数组：</li></ol><p>(1). forEach()遍历<strong>整个</strong>数组</p><p><code>array.forEach(function(currentValue, index, arr)</code></p><p>currentValue：数组当前项的值<br>index：数组当前项的索引<br>arr：数组对象本身</p><p>(2).filter()筛选数组</p><p><code>array.filter(function(currentValue, index, arr))</code></p><p> filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的<strong>所有</strong>元素,主要用于筛选数组<br>注意它直接返回一个新数组<br> currentValue: 数组当前项的值<br> index：数组当前项的索引<br> arr：数组对象本身</p><p>(3).some()判断数组是否存在某个元素</p><p><code>array.some(function(currentValue, index, arr)</code></p><p> some() 方法用于检测数组中的元素是否满足指定条件.   通俗点 查找数组中是否有满足条件的元素<br>注意它返回值是布尔值, 如果查找到这个元素, 就返回true ,  如果查找不到就返回false.<br><strong>如果找到第一个满足条件的元素,则终止循环. 不在继续查找.</strong><br> currentValue: 数组当前项的值<br> index：数组当前项的索引<br> arr：数组对象本身</p><ol start="2"><li>字符串</li></ol><p>(1).str.trim()去除字符串两端的空格，返回的是一个新的字符串</p><ol start="2"><li>对象</li></ol><p>(1).Object.keys() 用于获取对象自身所有的属性</p><p>效果类似 for…in<br>返回一个由属性名组成的数组</p><p>(2).Object.defineProperty() 定义对象中新属性或修改原有的属性。(<strong>vue2用来实现响应式</strong>)</p><p>Object.defineProperty(obj, prop, descriptor)</p><p>obj：必需。目标对象<br>prop：必需。需定义或修改的属性的名字<br>descriptor：必需。目标属性所拥有的特性</p><p>Object.defineProperty()   第三个参数 descriptor 说明： 以对象形式 { } 书写</p><p> value: 设置属性的值  默认为undefined<br> writable: 值是否可以重写。true | false  默认为false<br> enumerable: 目标属性是否可以被枚举。true | false 默认为 false<br> configurable: 目标属性是否可以被删除或是否可以再次修改特性 true | false  默认为false</p><h3 id="六、函数进阶"><a href="#六、函数进阶" class="headerlink" title="六、函数进阶"></a>六、函数进阶</h3><blockquote><h3 id="函数进阶"><a href="#函数进阶" class="headerlink" title="函数进阶"></a>函数进阶</h3></blockquote><h4 id="1-函数的定义和调用"><a href="#1-函数的定义和调用" class="headerlink" title="1.函数的定义和调用"></a>1.函数的定义和调用</h4><ol><li>函数声明方式 function 关键字 (命名函数)</li><li>函数表达式 (匿名函数)</li><li>new Function() <code>var fn = new Function('参数1','参数2'..., '函数体')</code></li></ol><p>Function 里面参数都必须是字符串格式<br>第三种方式执行效率低，也不方便书写，因此较少使用<br>所有函数都是 Function 的实例(对象)<br>函数也属于对象</p><pre><code class="line-numbers language-js">    // 1. 自定义函数(命名函数)     function fn() {};    // 2. 函数表达式 (匿名函数)    var fun = function() {};    // 3. 利用 new Function('参数1','参数2', '函数体');    var f = new Function('a', 'b', 'console.log(a + b)');</code></pre><h4 id="2-函数的调用方式"><a href="#2-函数的调用方式" class="headerlink" title="2.函数的调用方式"></a>2.函数的调用方式</h4><ol><li>普通函数</li><li>对象的方法</li><li>构造函数</li><li>绑定事件函数</li><li>定时器函数</li><li>立即执行函数</li></ol><pre><code class="line-numbers language-js">    // 1. 普通函数    function fn() {        console.log('人生的巅峰');    }    // fn();   fn.call()        // 2. 对象的方法    var o = {        sayHi: function() {            console.log('人生的巅峰');        }    }    o.sayHi();        // 3. 构造函数    function Star() {};  // 构造函数首字母习惯大写，构造函数本质和普通函数一样，但是构函需要用new调用。    new Star();       // 4. 绑定事件函数    btn.onclick = function() {};   // 点击了按钮就可以调用这个函数    // 5. 定时器函数    setInterval(function() {}, 1000);  这个函数是定时器自动1秒钟调用一次    // 6. 立即执行函数    (function() {        console.log('人生的巅峰');    })();    // 立即执行函数是自动调用</code></pre><h4 id="3-this指向问题"><a href="#3-this指向问题" class="headerlink" title="3.this指向问题"></a>3.this指向问题</h4><table><thead><tr><th>调用方式</th><th>this指向</th></tr></thead><tbody><tr><td>普通函数调用</td><td>Windows</td></tr><tr><td>构造函数调用</td><td>实例对象    原型对象里面的方法也指向实例对象</td></tr><tr><td>对象方法调用</td><td>该方法所属对象</td></tr><tr><td>事件绑定方法</td><td>绑定事件对象</td></tr><tr><td>定时器函数</td><td>Windows</td></tr><tr><td>立即执行函数</td><td>Windows</td></tr></tbody></table><p>3.1改变函数内部this指向：</p><ol><li>call()方法：<code>fun.call(thisArg, arg1, arg2, ...) </code></li></ol><ul><li> thisArg：在 fun 函数运行时指定的 this 值</li><li> arg1，arg2：传递的其他参数</li><li> 返回值就是函数的返回值，因为它就是调用函数</li><li> 因此当我们想改变 this 指向，同时想调用这个函数的时候，可以使用 call，比如继承（具体参考7继承）</li></ul><ol start="2"><li><p>apply方法：<code>fun.apply(thisArg, [argsArray])</code></p><ul><li> thisArg：在fun函数运行时指定的 this 值</li><li> argsArray：传递的值，必须包含在数组里面</li><li> 返回值就是函数的返回值，因为它就是调用函数</li><li> 因此 apply 主要跟数组有关系，比如使用 Math.max() 求数组的最大值</li></ul><pre><code class="line-numbers language-js">var arr = [1,2,3,5,4]var max = Math.max.apply(Math,arr); </code></pre><p>apply()与call()都是改变this指向，apply常用于数组应用方法。</p></li><li><p>bind方法：<code>fun.bind(thisArg, arg1, arg2, ...</code></p></li></ol><ul><li> thisArg：在 fun 函数运行时指定的 this 值</li><li> arg1，arg2：传递的其他参数</li><li> 返回由指定的 this 值和初始化参数改造的<strong>原函数拷贝</strong></li><li>因此当我们只是想改变 this 指向，并且不想调用这个函数的时候，可以使用 bind</li></ul><p>4.call、aplly、bind总结</p><p>相同点:<br>都可以改变函数内部的this指向</p><p>区别点:<br>call 和 apply  会调用函数, 并且改变函数内部this指向.<br>call 和 apply 传递的参数不一样, call 传递参数 aru1, aru2..形式  apply 必须数组形式[arg]<br>bind  不会调用函数, 可以改变函数内部this指向.</p><p>call 经常做继承.<br>apply 经常跟数组有关系.  比如借助于数学对象实现数组最大值最小值<br>bind  不调用函数,但是还想改变this指向. 比如改变定时器内部的this指向.</p><h4 id="4-严格模式"><a href="#4-严格模式" class="headerlink" title="4.严格模式"></a>4.严格模式</h4><p>JavaScript 除了提供正常模式外，还提供了严格模式（strict mode）。ES5 的严格模式是采用具有限制性 JavaScript 变体的一种方式，即在严格的条件下运行 JS 代码。<br>严格模式在 IE10 以上版本的浏览器中才会被支持，旧版本浏览器中会被忽略。<br>严格模式对正常的 JavaScript 语义做了一些更改： </p><ol><li>消除了 Javascript 语法的一些不合理、不严谨之处，减少了一些怪异行为。</li><li>消除代码运行的一些不安全之处，保证代码运行的安全。</li><li>提高编译器效率，增加运行速度。</li><li>禁用了在 ECMAScript 的未来版本中可能会定义的一些语法，为未来新版本的 Javascript 做好铺垫。比如一些保留字如：class, enum, export, extends, import, super 不能做变量名</li></ol><h6 id="4-1严格模式中的变化"><a href="#4-1严格模式中的变化" class="headerlink" title="4.1严格模式中的变化"></a>4.1严格模式中的变化</h6><ol><li><p>变量规定</p><ul><li>在正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，变量都必须先用var 命令声明，然后再使用。</li><li>严禁删除已经声明变量。例如，delete x; 语法是错误的。</li></ul></li><li><p> 严格模式下 this 指向问题</p></li></ol><ul><li><ol><li>以前在全局作用域函数中的 this 指向 window 对象。</li></ol></li><li><ol start="2"><li>严格模式下全局作用域中函数中的 this 是 undefined。</li></ol></li><li><ol start="3"><li>以前构造函数时不加 new也可以 调用,当普通函数，this 指向全局对象</li></ol></li><li><ol start="4"><li>严格模式下,如果 构造函数不加new调用, this 指向的是undefined 如果给他赋值则 会报错</li></ol></li><li><ol start="5"><li>new 实例化的构造函数指向创建的对象实例。</li></ol></li><li><ol start="6"><li>定时器 this 还是指向 window 。</li></ol></li><li><ol start="7"><li>事件、对象还是指向调用者。</li></ol></li></ul><h3 id="七、闭包"><a href="#七、闭包" class="headerlink" title="七、闭包"></a>七、闭包</h3><h4 id="1-什么是闭包？"><a href="#1-什么是闭包？" class="headerlink" title="1.什么是闭包？"></a>1.什么是闭包？</h4><p>闭包（closure）指有权访问另一个函数作用域中变量的<strong>函数</strong>。</p><p>闭包是一个函数</p><h4 id="2-闭包的作用"><a href="#2-闭包的作用" class="headerlink" title="2.闭包的作用"></a>2.闭包的作用</h4><p>延伸了变量的作用范围，保存变量防止销毁</p><pre><code class="line-numbers language-js">&lt;script&gt;        // 闭包（closure）指有权访问另一个函数作用域中变量的函数。        // 一个作用域可以访问另外一个函数的局部变量         // 我们fn 外面的作用域可以访问fn 内部的局部变量        // 闭包的主要作用: 延伸了变量的作用范围        function fn() {            var num = 10;        // function fun() {        //     console.log(num);        // }        // return fun;        return function() {            console.log(num);        }    }    var f = fn();    f();    // 类似于    // var f = function() {    //         console.log(num);    //     }    // var f =  function fun() {    //         console.log(num);    //     }&lt;/script&gt;</code></pre><h4 id="3-闭包案例"><a href="#3-闭包案例" class="headerlink" title="3.闭包案例"></a>3.闭包案例</h4><p>经典面试题：利用闭包的方式得到当前 li 的索引</p><pre><code class="line-numbers language-js">// 2. 利用闭包的方式得到当前小li 的索引号        for (var i = 0; i &lt; lis.length; i++) {            // 利用for循环创建了4个立即执行函数            // 立即执行函数也成为小闭包因为立即执行函数里面的任何一个函数都可以使用它的i这变量            (function(i) {                // console.log(i);                lis[i].onclick = function() {                    console.log(i);                }            })(i);</code></pre><h3 id="八、深拷贝和浅拷贝"><a href="#八、深拷贝和浅拷贝" class="headerlink" title="八、深拷贝和浅拷贝"></a>八、深拷贝和浅拷贝</h3><ol><li>浅拷贝只是拷贝一层, 更深层次对象级别的只拷贝引用（拷贝地址）.</li><li>深拷贝拷贝多层, 每一级别的数据都会拷贝（开辟新的内存空间）.</li><li>Object.assign(target, …sources)    es6 新增方法可以浅拷贝</li></ol><h3 id="九、正则表达式"><a href="#九、正则表达式" class="headerlink" title="九、正则表达式"></a>九、正则表达式</h3><pre><code class="line-numbers language-js">1. 通过调用 RegExp 对象的构造函数创建   var 变量名 = new RegExp(/表达式/); 2. 通过字面量创建   var 变量名 = /表达式/; 3.test() 正则对象方法，用于检测字符串是否符合该规则，该对象会返回 true 或 false，其参数是测试字符串。   regexObj.test(str) regexObj 是写的正则表达式str 我们要测试的文本就是检测str文本是否符合我们写的正则表达式规范.</code></pre><h4 id="1-边界符"><a href="#1-边界符" class="headerlink" title="1.边界符"></a>1.边界符</h4><p><img src="https://gitee.com/Yuukyou/pic/raw/master/blog/image-20220417172118562.png" alt="image-20220417172118562"></p><h4 id="2-字符类"><a href="#2-字符类" class="headerlink" title="2.字符类"></a>2.字符类</h4><p>字符类表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内。</p><ol><li>[]  方括号   ：</li></ol><p><code>  /[abc]/.test('andy')     // true</code></p><p>后面的字符串只要包含 abc 中任意一个字符，都返回 true 。</p><ol start="2"><li>[-]  方括号内部 范围符-   </li></ol><p><code>   /^[a-z]$/.test(c')     // true</code></p><p>方括号内部加上 - 表示范围，这里表示 a 到 z 26个英文字母都可以。</p><ol start="3"><li> [^]  方括号内部 取反符^   </li></ol><p><code>   /[^abc]/.test('andy')     // false</code>   </p><p>方括号内部加上 ^ 表示取反，只要包含方括号内的字符，都返回 false 。注意和边界符 ^ 区别，边界符写到方括号外面。  </p><ol start="4"><li>字符组合</li></ol><p><code>   /[a-z1-9]/.test('andy')     // true</code></p><p>方括号内部可以使用字符组合，这里表示包含 a 到 z 的26个英文字母和 1 到 9 的数字都可以。</p><h4 id="4-量词符"><a href="#4-量词符" class="headerlink" title="4.量词符"></a>4.量词符</h4><p>量词符用来设定某个模式出现的次数。</p><p><img src="https://gitee.com/Yuukyou/pic/raw/master/blog/image-20220417172128838.png" alt="image-20220417172128838"></p><h4 id="5-预定义类"><a href="#5-预定义类" class="headerlink" title="5.预定义类"></a>5.预定义类</h4><p><img src="https://gitee.com/Yuukyou/pic/raw/master/blog/image-20220417172134688.png" alt="image-20220417172134688"></p><p>正则完整符号参考手册：<a href="https://jquery.cuishifeng.cn/regexp.html">https://jquery.cuishifeng.cn/regexp.html</a></p><h4 id="6-replace替换"><a href="#6-replace替换" class="headerlink" title="6.replace替换"></a>6.replace替换</h4><p>replace() 方法可以实现替换字符串操作，用来替换的参数可以是一个字符串或是一个正则表达式。</p><p><code>   stringObject.replace(regexp/substr,replacement)</code></p><p>第一个参数:   被替换的字符串 或者  正则表达式<br>第二个参数:   替换为的字符串<br>返回值是一个替换完毕的新字符串</p><p>正则表达式参数：<code>   /表达式/[switch]</code></p><p>switch(也称为修饰符) 按照什么样的模式来匹配. 有三种值：</p><ul><li>g：全局匹配 </li><li>i：忽略大小写 </li><li>gi：全局匹配 + 忽略大小写</li></ul><h3 id="十、let关键字（ES6部分开始）"><a href="#十、let关键字（ES6部分开始）" class="headerlink" title="十、let关键字（ES6部分开始）"></a>十、let关键字（ES6部分开始）</h3><p>前景（变量提升）：JavaScript 引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做<strong>变量提升</strong>（hoisting）</p><p>另外ES5声明变量只提供了var和function两种形式。</p><p>let声明的变量只在所处于的块级有效（块级即花括号内）。</p><pre><code class="line-numbers language-js">if (true) {     let a = 10; }console.log(a) // a is not defined</code></pre><p>注意：使用let关键字声明的变量才具有块级作用域，使用var声明的变量不具备块级作用域特性。</p><p>使用let变量会出现<strong>暂时性死区</strong>：当在一个块级作用域内使用let声明变量，则let会自动与块{}进行绑定：</p><pre><code class="line-numbers language-js"> var tmp = 123; if (true) {      tmp = 'abc';     let tmp;  } </code></pre><p>经典面试题：</p><p><img src="https://gitee.com/Yuukyou/pic/raw/master/blog/image-20220413105712809.png" alt="image-20220413105712809"></p><p>此时输出为2  2 </p><p><img src="https://gitee.com/Yuukyou/pic/raw/master/blog/image-20220417172151029.png" alt="image-20220417172151029"></p><p>此时输出为0 1</p><p>此题的关键点在于<strong>每次循环都会产生一个块级作用域</strong>，每个块级作用域中的变量都是不同的，函数执行时输出的是自己上一级（循环产生的块级作用域）作用域下的i值.</p><h3 id="十一、const关键字"><a href="#十一、const关键字" class="headerlink" title="十一、const关键字"></a>十一、const关键字</h3><p>作用：声明常量，常量就是值（内存地址）不能变化的量。声明常量时<strong>必须赋值</strong>。</p><p>const也具有块级作用域：</p><pre><code class="line-numbers language-js">if (true) {     const a = 10; } console.log(a) // a is not defined</code></pre><p>值类型数据（栈储存）不可更改，引用类型（对储存）可以更改</p><p>（值类型和应用类型储蓄形式：<a href="http://www.360doc.com/content/18/1224/18/13328254_804168072.shtml%EF%BC%89">http://www.360doc.com/content/18/1224/18/13328254_804168072.shtml）</a></p><pre><code class="line-numbers language-js"> const PI = 3.14; PI = 100; // Assignment to constant variable. </code></pre><pre><code class="line-numbers language-js"> const ary = [100, 200]; ary[0] = 'a'; ary[1] = 'b'; console.log(ary); // ['a', 'b'];  ary = ['a', 'b']; // Assignment to constant variable.</code></pre><p><img src="https://gitee.com/Yuukyou/pic/raw/master/blog/image-20220417172158555.png" alt="image-20220417172158555"></p><h3 id="十二、解构：数组、对象"><a href="#十二、解构：数组、对象" class="headerlink" title="十二、解构：数组、对象"></a>十二、解构：数组、对象</h3><h3 id="十三、箭头函数"><a href="#十三、箭头函数" class="headerlink" title="十三、箭头函数"></a>十三、箭头函数</h3><p>ES6中新增的定义函数的方式。</p><pre><code class="line-numbers language-js">() =&gt; {} const fn = () =&gt; {}</code></pre><p>函数体中只有一句代码，且代码的执行结果就是返回值，可以省略大括号</p><pre><code class="line-numbers language-js"> function sum(num1, num2) {      return num1 + num2;  } const sum = (num1, num2) =&gt; num1 + num2; </code></pre><p>如果形参只有一个，可以省略小括号</p><pre><code class="line-numbers language-js"> function fn (v) {     return v; }  const fn = v =&gt; v;</code></pre><p><strong>箭头函数中的this：</strong></p><p>箭头函数不绑定this关键字，<strong>箭头函数中的this，指向的是函数定义位置的上下文this</strong>。</p><pre><code class="line-numbers language-js"> const obj = { name: '张三'}  function fn () {      console.log(this);     return () =&gt; {          console.log(this)     }  }  const resFn = fn.call(obj);  resFn(); //此时输出obj</code></pre><p>经典面试题：</p><p>注意：定义对象的{}不产生作用域，只有函数才有作用域。</p><pre><code class="line-numbers language-js">    var age = 100;    var obj = {        age: 20,        say: () =&gt; {            alert(this.age)        }    }    obj.say(); //100</code></pre><h3 id="十四、Arrray扩展方法"><a href="#十四、Arrray扩展方法" class="headerlink" title="十四、Arrray扩展方法"></a>十四、Arrray扩展方法</h3><h4 id="1、扩展运算符（展开语法）"><a href="#1、扩展运算符（展开语法）" class="headerlink" title="1、扩展运算符（展开语法）"></a>1、扩展运算符（展开语法）</h4><p>扩展运算符可以应用于合并数组。</p><pre><code class="line-numbers language-js">// 方法一  let ary1 = [1, 2, 3]; let ary2 = [3, 4, 5]; let ary3 = [...ary1, ...ary2]; // 方法二  ary1.push(...ary2);</code></pre><p>将类数组或可遍历对象转换为真正的数组</p><pre><code class="line-numbers language-js">let oDivs=document.getElementsByTagName('div'); oDivs = [...oDivs];</code></pre><h4 id="2、构造函数方法：Array-from"><a href="#2、构造函数方法：Array-from" class="headerlink" title="2、构造函数方法：Array.from()"></a>2、构造函数方法：Array.from()</h4><p>将类数组或可遍历对象转换为真正的数组</p><pre><code class="line-numbers language-js">let arrayLike = {    '0': 'a',    '1': 'b',    '2': 'c',    length: 3}; let arr2 = Array.from(arrayLike); // ['a', 'b', 'c']</code></pre><p>方法还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</p><pre><code class="line-numbers language-js"> let arrayLike = {      "0": 1,     "1": 2,     "length": 2 } let newAry = Array.from(aryLike, item =&gt; item *2)</code></pre><h4 id="3、实例方法：find"><a href="#3、实例方法：find" class="headerlink" title="3、实例方法：find()"></a>3、实例方法：find()</h4><p>用于找出第一个符合条件的数组成员，如果没有找到返回undefined</p><pre><code class="line-numbers language-js"> let ary = [{     id: 1,     name: '张三‘ }, {      id: 2,     name: '李四‘ }];  let target = ary.find((item, index) =&gt; item.id == 2);</code></pre><h4 id="4、实例方法：findIndex"><a href="#4、实例方法：findIndex" class="headerlink" title="4、实例方法：findIndex()"></a>4、实例方法：findIndex()</h4><p>用于找出第一个符合条件的数组成员的位置，如果没有找到返回-1</p><pre><code class="line-numbers language-js">let ary = [1, 5, 10, 15];let index = ary.findIndex((value, index) =&gt; value &gt; 9); console.log(index); // 2</code></pre><h4 id="5、实例方法：includes"><a href="#5、实例方法：includes" class="headerlink" title="5、实例方法：includes()"></a>5、实例方法：includes()</h4><p>表示某个数组是否包含给定的值，返回布尔值。</p><pre><code class="line-numbers language-js">[1, 2, 3].includes(2) // true [1, 2, 3].includes(4) // false</code></pre><h3 id="十五、String-的扩展方法"><a href="#十五、String-的扩展方法" class="headerlink" title="十五、String 的扩展方法"></a>十五、String 的扩展方法</h3><h4 id="1、模板字符串"><a href="#1、模板字符串" class="headerlink" title="1、模板字符串"></a>1、模板字符串</h4><p>ES6新增的创建字符串的方式，使用反引号定义。</p><pre><code class="line-numbers language-js"> let name = `zhangsan`;</code></pre><p>模板字符串中可以解析变量。</p><pre><code class="line-numbers language-js"> let name = '张三';  let sayHello = `hello,my name is ${name}`; // hello, my name is zhangsan</code></pre><p>模板字符串中可以换行</p><pre><code class="line-numbers language-js"> let result = {      name: 'zhangsan',      age: 20,      sex: '男'  }  let html = ` &lt;div&gt;     &lt;span&gt;${result.name}&lt;/span&gt;     &lt;span&gt;${result.age}&lt;/span&gt;     &lt;span&gt;${result.sex}&lt;/span&gt; &lt;/div&gt; `;</code></pre><p>在模板字符串中可以调用函数。</p><pre><code class="line-numbers language-js"> const sayHello = function () {     return '哈哈哈哈 追不到我吧 我就是这么强大'; };  let greet = `${sayHello()} 哈哈哈哈`;  console.log(greet); // 哈哈哈哈 追不到我吧 我就是这么强大 哈哈哈哈</code></pre><h4 id="2、实例方法：startsWith-和-endsWith"><a href="#2、实例方法：startsWith-和-endsWith" class="headerlink" title="2、实例方法：startsWith() 和 endsWith()"></a>2、实例方法：startsWith() 和 endsWith()</h4><p>startsWith()：表示参数字符串是否在原字符串的头部，返回布尔值<br>endsWith()：表示参数字符串是否在原字符串的尾部，返回布尔值</p><pre><code class="line-numbers language-js"> let str = 'Hello world!'; str.startsWith('Hello') // true  str.endsWith('!')       // true</code></pre><h4 id="3、实例方法：repeat"><a href="#3、实例方法：repeat" class="headerlink" title="3、实例方法：repeat()"></a>3、实例方法：repeat()</h4><p>repeat方法表示将原字符串重复n次，返回一个新字符串。</p><pre><code class="line-numbers language-js">'x'.repeat(3)      // "xxx" 'hello'.repeat(2)  // "hellohello"</code></pre><h3 id="十六、Set-数据结构"><a href="#十六、Set-数据结构" class="headerlink" title="十六、Set 数据结构"></a>十六、Set 数据结构</h3><p>ES6 提供了新的数据结构  Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p><p>Set本身是一个构造函数，用来生成  Set  数据结构。</p><pre><code class="line-numbers language-js">const s = new Set();</code></pre><p>Set函数可以接受一个数组作为参数，用来初始化。</p><pre><code class="line-numbers language-js">const set = new Set([1, 2, 3, 4, 4]);</code></pre><p><strong>set去重</strong>：</p><pre><code class="line-numbers language-js">const s3 = new Set(["a","a","b","b"]);console.log(s3.size)const ary = [...s3];</code></pre><h4 id="1、实例方法："><a href="#1、实例方法：" class="headerlink" title="1、实例方法："></a>1、实例方法：</h4><ul><li>add(value)：添加某个值，返回 Set 结构本身</li><li>delete(value)：删除某个值，返回一个布尔值，表示删除是否成功</li><li>has(value)：返回一个布尔值，表示该值是否为 Set 的成员</li><li>clear()：清除所有成员，没有返回值</li></ul><pre><code class="line-numbers language-js"> const s = new Set(); s.add(1).add(2).add(3); // 向 set 结构中添加值  s.delete(2)             // 删除 set 结构中的2值  s.has(1)                // 表示 set 结构中是否有1这个值 返回布尔值  s.clear()               // 清除 set 结构中的所有值</code></pre><h4 id="2、遍历"><a href="#2、遍历" class="headerlink" title="2、遍历"></a>2、遍历</h4><p>Set 结构的实例与数组一样，也拥有forEach方法，用于对每个成员执行某种操作，没有返回值</p><pre><code class="line-numbers language-js">s.forEach(value =&gt; console.log(value))</code></pre><h3 id="十七、同步和异步"><a href="#十七、同步和异步" class="headerlink" title="十七、同步和异步"></a>十七、同步和异步</h3><p><img src="https://gitee.com/Yuukyou/pic/raw/master/blog/image-20220417172208313.png" alt="image-20220417172208313"></p><p><img src="https://gitee.com/Yuukyou/pic/raw/master/blog/image-20220417172213469.png" alt="image-20220417172213469"></p><p>答案：2457<strong>3186</strong></p><p>错：2457<strong>3816</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端，js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>H5实训笔记</title>
      <link href="2021/09/07/H5CSS3/"/>
      <url>2021/09/07/H5CSS3/</url>
      
        <content type="html"><![CDATA[<h2 id="CSS动画"><a href="#CSS动画" class="headerlink" title="CSS动画"></a>CSS动画</h2><p><code>transition:</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> H5 </tag>
            
            <tag> CSS3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于XGBoost的集成学习算法</title>
      <link href="2021/08/17/XGBoost/"/>
      <url>2021/08/17/XGBoost/</url>
      
        <content type="html"><![CDATA[<p>   2021暑假已过大半，我的大二也即将结束，大二与大三似乎过度得很仓促。不太愿意承认自己马上就要大三了，好像什么都还没做这个夏天又要过去了，好像什么都没做就马上要走出大学的校门了。</p><p>   这个暑假事情是比较多的，要准备9月初数模国赛，大创项目也要准备开题路演，而我又在实习。本来计划这个暑假初步完成大创的前端初稿，沉淀一下前端知识，得推一推了。马上开学而数模计划学习进度才刚过半，距离9月10号没剩几天了，得抓紧了✊练了一套19年国赛D题，本来以为会主要把时间花在模型训练，没想到的是大半时间都卡在数据清洗😅，这道题断断续续给我做了半个月😅下面主要写的是XGBoost模型建立的代码，以及参数调整方法，本项目所用到的所有代码都已上传到<a href="https://github.com/yuukyou-chan/MathModeling2019D">我的Github</a>，包括数据清洗，欢迎学习交流。</p><p>正文分割线</p><hr><p>  &nbsp;在学习集成算法之前，我有学过一点神经网络和智能算法（模拟退火，遗传算法）我发现其实这些算法是有点共性的，智能算法像是神经网络的祖先，里面提到的梯度下降等各种概念特别是遗传算法和非常神经网络神似。</p><p>  集成学习主要分为Bagging，Boosting，前者代表为随机森林，后者为XGBoost、GBDT</p><p>按照我的理解XGBoost就像是用多个小而简单的多项式相加代换一个复杂整体的表达式，就像高数里面最令人头疼泰勒展开式一样。这里算法细节不在具体解释，下面上代码：</p><blockquote><h2 id="代码展示"><a href="#代码展示" class="headerlink" title="代码展示"></a>代码展示</h2></blockquote><p>导包基操：</p><pre><code class="line-numbers language-python"># 导入包import numpy as npimport pandas as pdimport matplotlib.pyplot as pltfrom sklearn.ensemble import RandomForestRegressorimport xgboost as xgb# 导入数据from xgboost import plot_importancedata = pd.read_excel('合并.xls')data.head()# 切分数据集feas = data.columnsfeas_var = feas[0:11]  # 多维输入变量feas_lab = feas[12]  # 输出变量X = data[feas_var]  Y = data[feas_lab]# 切分训练集和测试集from sklearn.model_selection import train_test_splitx_train, x_valid, y_train, y_valid = train_test_split(X, Y, test_size=0.3, random_state=90)</code></pre><p>模型训练：</p><pre><code class="line-numbers language-python"># 训练模型xgb_model = xgb.XGBRegressor(n_estimators=1000, random_state=50, verbosity=1, max_depth=15, min_child_weight=4, gamma=0.6)xgb_model.fit(x_train, y_train, eval_metric='mae', eval_set=[(x_valid, y_valid)], early_stopping_rounds=100)</code></pre><p>模型评价：</p><pre><code class="line-numbers language-python"># 模型评价from sklearn.metrics import mean_absolute_error, mean_squared_error, accuracy_scorexgb_pred = xgb_model.predict(x_valid)print(np.corrcoef(xgb_pred, y_valid)[0, 1] ** 2)    # 相关系数print(mean_squared_error(xgb_pred, y_valid))        #均方误差print(mean_absolute_error(xgb_pred, y_valid))       #平均绝对误差# 准确率# accuracy = accuracy_score(y_valid,xgb_pred)# print('accuarcy:%.2f%%'%(accuracy*100))# 显示重要特征plot_importance(xgb_model)plt.show()</code></pre><p>结果展示：</p><p><img src="https://i.loli.net/2021/08/17/vKdCB5M39DOUVsE.png" alt="评价模型"></p><p>相关系数0.75还算可以吧</p><p><img src="https://i.loli.net/2021/08/17/sOmg9LDoWGawkS2.png" alt="特征重要度"></p><p>很明显压强对于自建点检测值偏差影响较大</p><blockquote><h2 id="参数调整"><a href="#参数调整" class="headerlink" title="参数调整"></a>参数调整</h2></blockquote><p>任何模型训练最头疼的就是参数调整了吧，之前写得神经网络调参也是我最头疼的一块，神经网络参数改动一点点效果也真的改动亿点点，不敢乱调神经网络，还好XGBoost比神经网络好调参，我在网上找到了一些XGBoost调参方法收藏一下。</p><p><img src="https://i.loli.net/2021/08/17/EOILlkZfwx9McNq.png" alt="各项参数"></p><p><img src="https://i.loli.net/2021/08/17/SbfgNotcIuPjKHA.png" alt="参数调节"></p><p>一般先调生成树的个数，一般树个数越多，效果越好，但是树的增加会是代码运行非常缓慢，存在边际效益递减，树的的个数越多，搭配较小的学习率更好。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 集成算法 </tag>
            
            <tag> XGBoost </tag>
            
            <tag> 数据清洗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端常考面试题</title>
      <link href="2021/07/17/front-end-interview/"/>
      <url>2021/07/17/front-end-interview/</url>
      
        <content type="html"><![CDATA[<h2 id="HTML、CSS常考20道"><a href="#HTML、CSS常考20道" class="headerlink" title="HTML、CSS常考20道"></a>HTML、CSS常考20道</h2><ol><li><blockquote><h5 id="行内元素、块级元素以及非替换元素、替换元素的区别（🌟🌟🌟）"><a href="#行内元素、块级元素以及非替换元素、替换元素的区别（🌟🌟🌟）" class="headerlink" title="行内元素、块级元素以及非替换元素、替换元素的区别（🌟🌟🌟）"></a>行内元素、块级元素以及非替换元素、替换元素的区别（🌟🌟🌟）</h5></blockquote><p>行内元素与块级元素的区别：</p><p>1）行内元素与块级元素直观上的区别</p><p>​    行内元素会在一条直线上排列，都是同一行的，水平方向排列</p><p>​    块级元素各占据一行，垂直方向排列。块级元素从新行开始结束接着一个断行。</p><p>2)块级元素可以包含行内元素和块级元素。行内元素不能包含块级元素。</p><p>3)行内元素与块级元素属性的不同，主要是盒模型属性上</p><p>4）行内元素设置width无效，height无效(可以设置line-height)，margin上下无效，padding上下无效</p></li><li><blockquote><h5 id="img的title和alt属性（🌟🌟）"><a href="#img的title和alt属性（🌟🌟）" class="headerlink" title="img的title和alt属性（🌟🌟）"></a>img的title和alt属性（🌟🌟）</h5></blockquote><ul><li>title是全局属性，可以用于所有的html元素</li></ul></li><li><blockquote><h5 id="meta标签的作用以及常用的meta标签（🌟🌟）"><a href="#meta标签的作用以及常用的meta标签（🌟🌟）" class="headerlink" title="meta标签的作用以及常用的meta标签（🌟🌟）"></a>meta标签的作用以及常用的meta标签（🌟🌟）</h5></blockquote></li><li><blockquote><h5 id="DOCTPE标签（🌟🌟🌟）"><a href="#DOCTPE标签（🌟🌟🌟）" class="headerlink" title="DOCTPE标签（🌟🌟🌟）"></a>DOCTPE标签（🌟🌟🌟）</h5></blockquote><ul><li>标准模式、兼容模式</li></ul></li><li><blockquote><h5 id="scrip标签的defer和async（推迟和异步属性）（🌟）"><a href="#scrip标签的defer和async（推迟和异步属性）（🌟）" class="headerlink" title="scrip标签的defer和async（推迟和异步属性）（🌟）"></a>scrip标签的defer和async（推迟和异步属性）（🌟）</h5></blockquote></li><li><blockquote><h5 id="W3C盒模型和怪异盒模型（🌟🌟🌟）"><a href="#W3C盒模型和怪异盒模型（🌟🌟🌟）" class="headerlink" title="W3C盒模型和怪异盒模型（🌟🌟🌟）"></a>W3C盒模型和怪异盒模型（🌟🌟🌟）</h5></blockquote><p><img src="https://gitee.com/Yuukyou/pic/raw/master/blog/%E6%A0%87%E5%87%86%E7%9B%92%E6%A8%A1%E5%9E%8B.png" alt="标准盒模型"></p><p>​    在标准盒模型下，width和height是内容区域即content的width和height。而盒子总宽度为</p><p>​    在标准模式下，一个块的总宽度= width + margin(左右) + padding(左右) + border(左右)</p><p><img src="https://gitee.com/Yuukyou/pic/raw/master/blog/IE%E6%88%96%E6%80%AA%E5%BC%82%E7%9B%92%E6%A8%A1%E5%9E%8B.png" alt="怪异盒模型">IE盒模型或怪异盒模型显而易见的区别就是，width和height除了content区域外，还包含padding和border。盒子的总宽度为 一个块的总宽度= width + margin(左右)（即width已经包含了padding和border值)</p></li><li><blockquote><h5 id="水平垂直居中的方法（还有只水平居中、只垂直居中）（🌟🌟🌟）"><a href="#水平垂直居中的方法（还有只水平居中、只垂直居中）（🌟🌟🌟）" class="headerlink" title="水平垂直居中的方法（还有只水平居中、只垂直居中）（🌟🌟🌟）"></a>水平垂直居中的方法（还有只水平居中、只垂直居中）（🌟🌟🌟）</h5></blockquote></li><li><blockquote><h5 id="BFC（🌟🌟🌟）"><a href="#BFC（🌟🌟🌟）" class="headerlink" title="BFC（🌟🌟🌟）"></a>BFC（🌟🌟🌟）</h5></blockquote><ul><li><p>BFC是什么</p><p>BFC(Block formatting context)直译为”块级格式化上下文”</p></li><li><p>触发条件</p><p>1、float的值不是none。</p><p>2、position的值不是static或者relative。</p><p>3、display的值是inline-block、table-cell、flex、table-caption或者inline-flex</p><p>4、overflow的值不是visible</p></li><li><p>特性及作用</p><p>解决</p><ol><li>浮动元素的父元素高度坍塌</li><li>两栏自适应布局</li><li>外边距垂直方向重合</li></ol></li></ul></li><li><blockquote><h5 id="清除浮动的方法（🌟🌟🌟）"><a href="#清除浮动的方法（🌟🌟🌟）" class="headerlink" title="清除浮动的方法（🌟🌟🌟）"></a>清除浮动的方法（🌟🌟🌟）</h5></blockquote><pre><code>    1. 额外标签法（在最后一个浮动标签后，新加一个标签，给其设置clear：both；）    2. 父级添加overflow属性（父元素添加overflow:hidden）（不推荐）    3. 使用after伪元素清除浮动（推荐使用）    4. 使用before和after双伪元素清除浮动</code></pre></li><li><blockquote><h5 id="position属性（绝对、相对、固定定位、粘性定位）（🌟🌟🌟）"><a href="#position属性（绝对、相对、固定定位、粘性定位）（🌟🌟🌟）" class="headerlink" title="position属性（绝对、相对、固定定位、粘性定位）（🌟🌟🌟）"></a>position属性（<strong>绝对、相对、固定定位</strong>、粘性定位）（🌟🌟🌟）</h5></blockquote></li><li><blockquote><h5 id="CSS隐藏元素的方式（🌟🌟🌟）"><a href="#CSS隐藏元素的方式（🌟🌟🌟）" class="headerlink" title="CSS隐藏元素的方式（🌟🌟🌟）"></a>CSS隐藏元素的方式（🌟🌟🌟）</h5></blockquote><ul><li>举例：display：none和visibility：hidden的区别（可以结合重排重绘说明）</li></ul></li><li><p>Flex布局（🌟🌟🌟）</p><ul><li>Flex容器和项目常见属性，举例：常用考察布局</li></ul><p>三个重要概念：轴，对齐，弹性</p></li><li><p>双栏布局、三栏布局（每种布局掌握多种方法）（🌟🌟🌟）</p></li><li><p>重排和重绘（🌟🌟🌟）</p></li><li><p>CSS选择器（🌟🌟）</p><ul><li>了解各个选择器的优先级</li><li>important属性</li></ul><p>ID选择器、标签选择器、类选择器、伪类选择器、属性选择器、结构选择器（6种）</p></li><li><p>CSS动画（难点，代码实现）（🌟🌟）</p><ul><li>animation属性</li><li>transition属性</li></ul></li><li><p>CSS实现三角形（手写实现）（🌟）</p></li><li><p>CSS Sprites（🌟🌟）</p><ul><li>原理和优势</li></ul></li><li><p>CSS长度相关题：px、rem、em（🌟）</p></li><li><p>伪类、伪元素（🌟）</p></li></ol><h2 id="JavaScript高频题"><a href="#JavaScript高频题" class="headerlink" title="JavaScript高频题"></a>JavaScript高频题</h2><ol><li><blockquote><h5 id="js数据类型（🌟🌟🌟）"><a href="#js数据类型（🌟🌟🌟）" class="headerlink" title="js数据类型（🌟🌟🌟）"></a>js数据类型（🌟🌟🌟）</h5></blockquote><ul><li><p>基本类型（6种，null，undefined比较像容易被问到，es6的symbol）</p></li><li><p>引用类型（1种object）</p><p>js中有六种数据类型，包括五种基本数据类型（Number,String,Boolean,Undefined,Null）,和一种复杂数据类型（Object）</p><p><strong>1.Number类型</strong></p><p>Number类型包含整数和浮点数（浮点数数值必须包含一个小数点，且小数点后面至少有一位数字）两种值。</p><p>NaN:非数字类型。特点：① 涉及到的 任何关于NaN的操作，都会返回NaN  ② NaN不等于自身。</p><p>isNaN() 函数用于检查其参数是否是非数字值。</p><p>isNaN(123)  //false  isNaN(“hello”)  //true</p><p><strong>2.String类型</strong></p><p>字符串有length属性。</p><p>字符串转换：转型函数String(),适用于任何数据类型（null,undefined 转换后为null和undefined）；toString()方法（null,defined没有toString()方法）。</p><p><strong>3.Boolean类型</strong></p><p>该类型只有两个值，true和false</p><p><strong>4.Undefined类型</strong></p><p>只有一个值，即undefined值。使用var声明了变量，但未给变量初始化值，那么这个变量的值就是undefined。</p><p><strong>5.Null类型</strong></p><p>null类型被看做空对象指针，前文说到null类型也是空的对象引用。</p><p>三大引用类型</p><p>​        引用类型的赋值其实是对象保存在栈区地址指针的赋值，因此两个变量指向同一个对象，任何的操作都会相互影响，而简单值类型</p><p><strong>1.Object类型</strong></p><p>我们看到的大多数类型值都是Object类型的实例，创建Object实例的方式有两种。</p><p>第一种是使用new操作符后跟Object构造函数，如下所示</p><p>var person = new Object();</p><p>person.name = “Micheal”;</p><p>person.age = 24;</p><p>第二种方式是使用对象字面量表示法，如下所示</p><p>var person = {</p><p>　　name : “Micheal”,</p><p>　　age : 24</p><p>};</p><p><strong>2.Array类型</strong></p><p>数组的每一项可以用来保存任何类型的数据，也就是说，可以用数组的第一个位置来保存字符串，第二个位置保存数值，第三个位置保存对象….另外，数组的大小是可以动态调整的。</p><p>创建数组的基本方式有两种</p><p>第一种是使用Array构造函数，如下所示</p><p>var colors = new Array(“red”,”blue”,”yellow”);</p><p>第二种是使用数组字面量表示法，如下所示</p><p>var colors = [“red”,”blue”,”yellow”];</p><p><strong>3 Function类型</strong></p><p>每个函数都是Function类型的实例，而且都与其他引用类型一样具有属性和方法。函数通常是使用函数声明语法定义的，如下所示</p><p>function sum(num1,num2){</p><p>　　return num1 + num2;</p><p>};</p><p>这和使用函数表达式定义函数的方式相差无几。</p><p>var sun = function (){</p><p>　　return sum1 + sum2;</p><p>};</p></li></ul></li><li><blockquote><h5 id="判断变量的类型（🌟🌟🌟）"><a href="#判断变量的类型（🌟🌟🌟）" class="headerlink" title="判断变量的类型（🌟🌟🌟）"></a>判断变量的类型（🌟🌟🌟）</h5></blockquote><ul><li>typeof</li><li>instanceof及原理</li><li>Object.toString().call()及原理([可以输出对象的内部属性[class]])</li></ul><p>​    <strong>typeof 操作符</strong></p><p>​    由于<code>js</code>中的变量是松散类型的，所以它提供了一种检测当前变量的数据类型的方法，也就是typeof关键字.</p><pre><code class="line-numbers language-js">typeof  123　　 //Numbertypeof  'abc'　　//Stringtypeof   true    //Booleantypeof   undefined  //Undefinedtypeof   null     //Objecttypeof   { }      //Objecttypeof   [ ]      //Objecttypeof   console.log()    //Function</code></pre><p>​    <strong>null类型进行typeof操作符后，结果是object</strong>，原因在于，null类型被当做一个空对象引用。</p><p>​        </p><p>​    <strong>Object.toString().call()</strong></p><p>​    在JavaScript里使用typeof判断数据类型，只能区分基本类型，即：number、string、undefined、boolean、    object。<br>​    对于null、array、function、object来说，使用typeof都会统一返回object字符串。<br>​    要想区分对象、数组、函数、单纯使用typeof是不行的。在JS中，可以通过Object.prototype.toString方法，    判断某个对象之属于哪种内置类型。<br>​    分为null、string、boolean、number、undefined、array、function、object、date、math。</p></li><li><blockquote><h5 id="数据类型转换（🌟🌟）（复杂、适当看看就行）"><a href="#数据类型转换（🌟🌟）（复杂、适当看看就行）" class="headerlink" title="数据类型转换（🌟🌟）（复杂、适当看看就行）"></a>数据类型转换（🌟🌟）（复杂、适当看看就行）</h5></blockquote><ul><li><p>相等==和全等===</p></li><li><p>强制类型转换和隐式转换</p></li><li><p>包装类型</p><p>相等 ==： 先转换类型再比较<br>全等 ===：直接比较，不转换类型，只要是类型不同就不相等，类型相同的看值是否相等<br>Object.is(value1,value2)：ES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。Object.is就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。</p></li></ul><p>​    强制类型转换：通过String（），Number（），Boolean（）函数强制转换</p><p>​    隐式转换：不同类型的变量比较要先转类型，叫做类型转换，类型转换也叫隐式转换。隐式转换通常发生在    运算符加减乘除，等于，还有小于，大于等。</p><pre><code class="line-numbers language-js">console.log(typeof '11')**//输出string**console.log(typeog 11) **//输出number**console.log('11' &lt; 4 ) **//输出false**</code></pre><p>​    1.字符串加数字,数字就会转成字符串。</p><p>​    2.数字减字符串，字符串转成数字。如果字符串不是纯数字就会转成NaN。字符串减数字也一样。两个字符    串相减也先转成数字。</p><p>​    3.乘，除，大于，小于跟减的转换也是一样。</p><pre><code class="line-numbers language-js">console.log(10+'20') //2010console.log(10-'20')//-10 numberconsole.log(10-'one') //NaN not a numberconsole.log(10-'101a') //NaNconsole.log(10*'20') //200 numberconsole.log('10'*'20') //200 numberconsole.log(20/'10') //2 numberconsole.log('20'/'10') //2 numberconsole.log('20'/'one') //NaN</code></pre></li><li><blockquote><h5 id="原型和原型链（🌟🌟🌟）"><a href="#原型和原型链（🌟🌟🌟）" class="headerlink" title="原型和原型链（🌟🌟🌟）"></a>原型和原型链（🌟🌟🌟）</h5></blockquote><ul><li>举例：给一个构造函数，描述构造函数、实例和原型之间的关系（比如说构造函数的prototype属性是指向原型等）</li></ul></li><li><blockquote><h5 id="闭包（🌟🌟🌟）"><a href="#闭包（🌟🌟🌟）" class="headerlink" title="闭包（🌟🌟🌟）"></a>闭包（🌟🌟🌟）</h5></blockquote><ul><li>概念</li><li>优缺点</li></ul></li><li><blockquote><h5 id="call-apply-bind的区别（🌟🌟🌟）"><a href="#call-apply-bind的区别（🌟🌟🌟）" class="headerlink" title="call/apply/bind的区别（🌟🌟🌟）"></a>call/apply/bind的区别（🌟🌟🌟）</h5></blockquote></li><li><blockquote><h5 id="DOM事件流（红宝书P347）和委托事件（P347）（🌟🌟🌟）"><a href="#DOM事件流（红宝书P347）和委托事件（P347）（🌟🌟🌟）" class="headerlink" title="DOM事件流（红宝书P347）和委托事件（P347）（🌟🌟🌟）"></a>DOM事件流（红宝书P347）和委托事件（P347）（🌟🌟🌟）</h5></blockquote><ul><li>捕获、冒泡</li><li>事件委托及好处</li></ul></li><li><blockquote><h5 id="cookie和storage区别（🌟🌟🌟）"><a href="#cookie和storage区别（🌟🌟🌟）" class="headerlink" title="cookie和storage区别（🌟🌟🌟）"></a>cookie和storage区别（🌟🌟🌟）</h5></blockquote><ul><li><p>cookie的构成</p></li><li><p>localStorage和sessionStorage</p><p>举例：cookie的HTTPOnly（加上之后无法通过js获取cookie，从而防止xss攻击）</p></li></ul></li><li><blockquote><h5 id="数组-对象常见的方法（这些方法会不会改变原始值）（🌟🌟）"><a href="#数组-对象常见的方法（这些方法会不会改变原始值）（🌟🌟）" class="headerlink" title="数组/对象常见的方法（这些方法会不会改变原始值）（🌟🌟）"></a>数组/对象常见的方法（这些方法会不会改变原始值）（🌟🌟）</h5></blockquote><ul><li>Array：slice/splice/concat/filter/map/reduce</li><li>Object：key/assign（Object.assign可用于浅拷贝）</li></ul></li><li><blockquote><h5 id="new一个对象时内部发生了什么（🌟）"><a href="#new一个对象时内部发生了什么（🌟）" class="headerlink" title="new一个对象时内部发生了什么（🌟）"></a>new一个对象时内部发生了什么（🌟）</h5></blockquote></li><li><p>防抖和节流（🌟</p></li><li><p>JS动画相关：requestAnimationFrame相比于setlnterval实现动画效果的优势是什么</p></li><li><p>this指向（考察概念，或给一段代码说结果）（🌟🌟）</p></li><li><p>作用域链（🌟）</p></li><li><p>let/var/const（🌟🌟🌟）【15-17是ES6易考点知识，阮一峰ES6入门】</p><p>使用var声明的变量，其作用域为该语句所在的函数内，且存在变量提升现象；<br>使用let声明的变量，其作用域为该语句所在的代码块内，不存在变量提升；<br>使用const声明的是常量，在后面出现的代码中不能再修改该常量的值。</p></li><li><p>异步编程：promise和async await（🌟🌟🌟）</p><ul><li>内部状态</li><li>promise.race和promise.all</li></ul></li><li><p>箭头函数（🌟🌟）</p></li><li><p>JS运行机制（介绍什么是event loop、setTimeout和promise结合题目写结果）</p><ul><li>单线程、解释性语言</li><li>事件循环</li><li>宏任务/微任务</li></ul></li><li><p>实现继承的方式（红宝书P162）（🌟🌟）</p></li><li><p>垃圾回收（P78）（🌟）</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 面经 </tag>
            
            <tag> html </tag>
            
            <tag> css </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HadoopExpriment</title>
      <link href="2021/05/30/Hadoop/"/>
      <url>2021/05/30/Hadoop/</url>
      
        <content type="html"><![CDATA[<p>图片我懒得搬了，要一张一张的改路径太麻烦了</p><h2 id="实验三"><a href="#实验三" class="headerlink" title="实验三"></a>实验三</h2><p>七、实验步骤</p><p>（一）Hbase shell 命令</p><p>1.启动hadoop</p><p>cd /usr/local/hadoop</p><p>./sbin/start-all.sh</p><p>2.启动hbase和hbase shell</p><p>cd /usr/local/hbase</p><p>./bin/start-hbase.sh</p><p>./bin/hbase shell</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps14.jpg" alt="img"> </p><p>l 进入HBase Shell命令行模式以后，用户可以通过输入Shell命令操作HBase数据库。</p><p>\3. 用list命令查看当前HBase数据库中已经创建了哪些表</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps15.jpg" alt="img"> </p><p>\4. 若已存在student表，则删除</p><p>disable ‘student’</p><p>drop ‘student’</p><p>\5. 用create命令创建表</p><p>create ‘student’,’Sname’,’Ssex’,’Sage’,’Sdept’,’course’</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps16.jpg" alt="img"> </p><p>\6. 查看数据</p><p>l HBase中有两个用于查看数据的命令：1. get命令，用于查看表的某一行数据；2. scan命令用于查看某个表的全部数据</p><p>get ‘student’,’20202020’</p><p>scan ‘student’</p><p>\7. 用put命令将自己的姓名、学号添加到student表中。例如姓名为‘Zhangsan’，学号‘20202020’:</p><p>put ‘student’,’20202020’,’Sname’,’Zhangsan’</p><p>l 即为student表添加了学号为20202020，名字为Zhangsan的一行数据，其行键为20202020</p><p>put ‘student’,’20202020’,’course:math’,’80’</p><p>l 即为20202020行下的course列族的math列添加了一个数据。</p><p>\8. 在HBase中用delete以及deleteall命令进行删除数据操作，它们的区别是：1. delete用于删除一个数据，是put的反向操作；2. deleteall操作用于删除一行数据。</p><p>delete ‘student’,’20202020’,’Ssex’</p><p>l 删除了student表中20202020行下的Ssex列的所有数据。</p><p>get ‘student’，‘20202020’</p><p>l 查看是否删除成功</p><p>deleteall ‘student’,’20202020’</p><p>l 删除了student表中的95001行的全部数据。</p><p>\8. 查询表历史数据</p><p>1）在创建表的时候，指定保存的版本数（假设指定为5）</p><p>create ‘teacher’,{NAME=&gt;’username’,VERSIONS=&gt;5}</p><p>2）插入数据然后更新数据，使其产生历史版本数据，注意：这里插入数据和更新数据都是用put命令</p><p>put ‘teacher’,’91001’,’username’,’Mary’</p><p>put ‘teacher’,’91001’,’username’,’Mary1’</p><p>put ‘teacher’,’91001’,’username’,’Mary2’</p><p>put ‘teacher’,’91001’,’username’,’Mary3’</p><p>put ‘teacher’,’91001’,’username’,’Mary4’  </p><p>put ‘teacher’,’91001’,’username’,’Mary5’</p><p>3）查询时，指定查询的历史版本数。默认会查询出最新的数据。（有效取值为1到5）</p><p>get ‘teacher’,’91001’,{COLUMN=&gt;’username’,VERSIONS=&gt;5}</p><p>\9. 退出HBase数据库表操作</p><p>exit</p><p>l 注意：这里退出HBase数据库是退出对数据库表的操作，而不是停止启动HBase数据库后台运行。</p><p>\10. 停止HBase运行</p><p>bin/stop-hbase.sh</p><p>11.关闭Hadoop</p><p>./sbin/stop-all.sh  </p><p>（二）Java API编程实例</p><p>\1. 启动hadoop，启动hbase(运行java代码时一定要保证hbase是启动状态)</p><p>cd /usr/local/hadoop</p><p>./sbin/start-all.sh</p><p>cd /usr/local/hbase</p><p>./bin/start-hbase.sh</p><p>2.在Eclipse中新建Java Project（Project名字为你名字的拼音，注意下图框起来部分）——&gt;新建Class</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps17.png" alt="img"><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps18.jpg" alt="img"> </p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps19.jpg" alt="img"> </p><p>\3. 在工程中导入外部jar包</p><p>l 在项目名称上右键选Property，在弹出的对话框左侧列表中选择Java Build Path，如下图所示：选择Add External JARs</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps20.png" alt="img"><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps21.jpg" alt="img"> </p><p>l 导入hbase安装目录中的lib（usr/local/hbase/lib,注意目录不要选错）文件中的所有jar包</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps22.jpg" alt="img"> </p><p>4.编写代码并运行</p><p>l 在Linux系统中打开浏览器，输入网址<a href="http://dblab.xmu.edu.cn/blog/install-hbase/%E5%A4%8D%E5%88%B6%E4%BB%A3%E7%A0%81%E3%80%82">http://dblab.xmu.edu.cn/blog/install-hbase/复制代码。</a></p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps23.jpg" alt="img"> </p><p>l 复制完成后，编译运行，Run as Java Application。运行成功后如图</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps24.jpg" alt="img"> </p><p>\5. 进入Hbase shell</p><p>scan ‘Score’ </p><p>\6. 在Eclipse中执行其它语句（除了createTable语句外，每人任选两条以上语句执行，每次执行一条，在Eclipse执行完后在shell中查看结果。）</p><p>l 主函数中的语句请任选两条执行，只需删除其前的//，并将其它语句注释掉即可，如：执行insertRow时请将其他语句注释</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps25.jpg" alt="img"> </p><p>l 执行完成后在shell中查看结果</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps26.jpg" alt="img"> </p><p>7.关闭hbase和hadoop</p><p>bin/stop-hbase.sh</p><p>./sbin/stop-all.sh  </p><h2 id="实验四"><a href="#实验四" class="headerlink" title="实验四"></a>实验四</h2><p>七、实验步骤</p><p>（一）安装 Hadoop-Eclipse-Plugin</p><p>进入本地文件系统的“下载”文件夹，单击右键，点在终端打开。</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps45.jpg" alt="img"> </p><p>l 在终端中输入命令(或者直接在文件系统中将该jar包拷贝到/usr/local/eclipse/plugins/中)</p><p>sudo cp hadoop-eclipse-plugin-2.6.0.jar /usr/local/eclipse/plugins/</p><p>l 复制完成后 使用以下命令，查看该jar包是否复制成功。</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps46.jpg" alt="img"> </p><p>l 在shell中运行以下命令重启 Eclipse </p><p>/usr/lib/eclipse/eclipse -clean</p><p>（二）在hadoop的HDFS文件系统中新建输入文件夹</p><p>1.启动hadoop</p><p>cd /usr/local/hadoop</p><p>./sbin/start-all.sh</p><p>2.在HDFS中创建用户目录</p><p>l 本实验环境的Hadoop为伪分布式，伪分布式读取的则是 HDFS 上的数据。要使用 HDFS，首先需要创建用户目录。（已存在该文件夹则跳过这步）</p><p>bin/hdfs dfs -mkdir -p /user/hadoop</p><p>l 接着将 etc/hadoop 中的文件作为输入文件复制到分布式文件系统中，即将 /usr/local/hadoop/etc/hadoop 复制到分布式文件系统中的 /user/hadoop/input 中。上一步已创建了用户目录 /user/hadoop ，因此命令中就可以使用相对目录如 input，其对应的绝对路径就是 /user/hadoop/input:</p><p>bin/hdfs dfs -put etc/hadoop/*.xml input</p><p>l 查看input中的文件</p><p>bin/hdfs dfs –ls /user/hadoop/input</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps47.jpg" alt="img"> </p><p>l 程序统计的就是这些文件中的词频。</p><p>l 也可以自己创建文件拷贝到hdfs中进行统计。</p><p>（三） 配置 Hadoop-Eclipse-Plugin</p><p>1.启动Eclipse</p><p>l 启动 Eclipse 后就可以在左侧的Project Explorer中看到 DFS Locations</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps48.jpg" alt="img"> </p><p>\2. 进一步配置插件</p><p>l 第一步，选择 Window 菜单下的 Preference。</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps49.jpg" alt="img"> </p><p>l 此时会弹出一个窗体，窗体的左侧会多出 Hadoop Map/Reduce 选项，点击此选项，选择 Hadoop 的安装目录（如/usr/local/hadoop，Ubuntu不好选择目录，直接输入就行）。</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps50.jpg" alt="img"> </p><p>l 第二步：切换 Map/Reduce 开发视图，选择 Window 菜单下选择 Open Perspective -&gt; Other，弹出一个窗体，从中选择 Map/Reduce 选项即可进行切换。</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps51.jpg" alt="img"> </p><p>l 第三步：建立与 Hadoop 集群的连接，点击 Eclipse软件右下角的 Map/Reduce Locations 面板，在面板中单击右键，选择 New Hadoop Location。</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps52.png" alt="img"><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps53.jpg" alt="img"> </p><p>l 在弹出来的 General 选项面板中，General 的设置要与 Hadoop 的配置一致。一般两个 Host 值是一样的，如果是伪分布式，填写 localhost 即可，另外我们使用的<a href="http://dblab.xmu.edu.cn/blog/install-hadoop/">Hadoop伪分布式配置</a>，设置 fs.defaultFS 为 hdfs://localhost:9000，则 DFS Master 的 Port 要改为 9000。Map/Reduce(V2) Master 的 Port 用默认的即可，Location Name 随意填写。</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps54.jpg" alt="img"> </p><p>（四）在 Eclipse 中操作 HDFS 中的文件</p><p>l 配置好后，点击左侧 Project Explorer 中的 MapReduce Location （点击三角形展开）就能直接查看 HDFS 中的文件列表了，双击可以查看内容，右键点击可以上传、下载、删除 HDFS 中的文件，无需再通过繁琐的 hdfs dfs -ls 等命令进行操作了。</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps55.jpg" alt="img"> </p><p>（五）在 Eclipse 中创建 MapReduce 项目</p><p>l 点击 File 菜单，选择 New -&gt; Project…选择 Map/Reduce Project，点击 Next。</p><p>l 填写 Project name 为 WordCount 即可，点击 Finish 就创建好了项目。</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps56.jpg" alt="img"> </p><p>l 右键点击刚创建的 WordCount 项目，选择 New -&gt; Class</p><p>l 需要填写两个地方：在 Package 处填写 org.apache.hadoop.examples；在 Name 处填写 WordCount。</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps57.jpg" alt="img"> </p><p>l 创建 Class 完成后，在 Project 的 src 中就能看到 WordCount.java 这个文件。将如下 WordCount 的代码复制到该文件中。</p><p>l 用linux浏览器打开网址复制WordCount代码<a href="http://dblab.xmu.edu.cn/blog/hadoop-build-project-using-eclipse/">http://dblab.xmu.edu.cn/blog/hadoop-build-project-using-eclipse/</a></p><p>（六）通过 Eclipse 运行 MapReduce</p><p>l 在运行 MapReduce 程序前，还需要将 /usr/local/hadoop/etc/hadoop 中将有修改过的配置文件（如伪分布式需要修改 core-site.xml 和 hdfs-site.xml，本镜像已完成修改），以及 log4j.properties 复制到 WordCount 项目下的 src 文件夹（~/workspace/WordCount/src）中。在shell中完成复制。</p><p>cp /usr/local/hadoop/etc/hadoop/core-site.xml ~/workspace/WordCount/src</p><p>cp /usr/local/hadoop/etc/hadoop/hdfs-site.xml ~/workspace/WordCount/src</p><p>cp /usr/local/hadoop/etc/hadoop/log4j.properties ~/workspace/WordCount/src</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps58.jpg" alt="img"> </p><p>l 复制完成后，务必右键点击 WordCount 选择 refresh 进行刷新（不会自动刷新，需要手动刷新），可以看到文件结构如下所示：</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps59.jpg" alt="img"> </p><p>l 点击工具栏中的 Run 图标，或者右键点击 Project Explorer 中的 WordCount.java，选择 Run As -&gt; Run on Hadoop，就可以运行 MapReduce 程序了。不过由于没有指定参数，运行时会提示 “Usage: wordcount “，需要通过Eclipse设定一下运行参数。</p><p>l 右键点击刚创建的 WordCount.java，选择 Run As -&gt; Run Configurations，在此处可以设置运行时的相关参数（如果 Java Application 下面没有 WordCount，那么需要先双击 Java Application）。切换到 “Arguments” 栏，在 Program arguments 处填写 “input output” 就可以了。</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps60.jpg" alt="img"> </p><p>l 设定参数后，再次运行程序，可以看到运行成功的提示。</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps61.jpg" alt="img"> </p><p>l 可以在Shell中查看结果：</p><p>./bin/hdfs dfs –cat output/*</p><p><img src="file:///C:\Users\19681\AppData\Local\Temp\ksohtml5852\wps62.jpg" alt="img"> </p><p>l 提示：如果提示错误“-Syntax error, parameterized types are only availble if source level is 1.5 or greater”。单击错误提示图标，在弹出的对话框中，在Change project compliance and JRE to 1.5 这行文字上双击，就可以让错误信息消失。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>基于RNN、LSTM神经网络的基金净值预测</title>
      <link href="2021/05/30/LSTMkeras/"/>
      <url>2021/05/30/LSTMkeras/</url>
      
        <content type="html"><![CDATA[<blockquote><p>都是神经网络惹的祸</p></blockquote><p>&nbsp; &nbsp; &nbsp; &nbsp; 这个月花了将近100G的流量，大半都拿来下学习视频了。上次写了个爬虫把基金数据爬下来了，说是要数据分析一波，头脑热了一个礼拜，每天晚上都在搞神经网络的代码，光是装TensorFlow环境就搞了我3个晚上，到处在网上找代码学习，本来就差最后一步就把要程序跑出来了，结果卡在了反归一化上面，输入输出维度不匹配，又搞了好几天，终于神经网络把我劝退了。我发现这样是行不通的，整得太浮躁了，不懂计算原理直接啃代码，连输入输出是什么都不懂，一些基本的激活函数、归一函数、评价模型都不懂想直接调包也没那么容易，出结果<br></p><p>&nbsp; &nbsp; &nbsp; &nbsp;后来大概过了大半个月，机缘巧合正好需要用到机器学习，我拾起了之前留下的烂摊子，慢慢（假的）基础知识学习，又搞起了机器学习。<br></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 今天终于能把神经网络跑出来了😁好久没更新博客了，主要是最近没啥时间搞自己的东西，作业都写不完</p><h2 id="大家好，我是调包侠"><a href="#大家好，我是调包侠" class="headerlink" title="大家好，我是调包侠"></a>大家好，我是调包侠</h2><p>虽然把神经网络跑出来了，中间还有些小问题，预测效果也不是很好，但是能跑出来</p><p>我就非常开心了，后面会再把基础打扎实一些。<br></p><p>先看效果图：</p><p><img src="https://gitee.com/Yuukyou/pic/raw/master/blog/%E9%A2%84%E6%B5%8B.png" alt="预测"></p><p>两条线基本拟合度不是很好，甚至可以说两条线没什么关系，细节波动预测不到，但是大致走势还比较正确（已经调整过很多种方案了，这是还比较像人样的）<br></p><p>看看他的过去：可以说是毫不相干😡<br></p><p>最开始这是纯RNN模型</p><p><img src="https://gitee.com/Yuukyou/pic/raw/master/blog/RNN.png" alt="RNN"></p><p>后来我改成了LSTM模型，发现更离谱：（后来我把模型的第一层改成LSTM就得到了图一）</p><p><img src="https://gitee.com/Yuukyou/pic/raw/master/blog/LSTM.png"></p><p>大概可以看出加入LSTM模型，预测值将会变得更趋于平缓，我猜可能是因为LSTM模型对长期记忆性导致的<br></p><p>其中存在的问题是每次Epoch的val_loss值都是不变，而且loss值为什么都是nan，我去看了网上说是每次训练出来的权重不变（或者说没有更新），或者是模型错误造成的，俺不懂怎么办了，百思不得其解，有没有懂得大佬指点一下，感激涕零😭<img src="https://gitee.com/Yuukyou/pic/raw/master/blog/%E6%8D%9F%E5%A4%B1%E5%80%BC.png" alt="损失值"></p><h2 id="下面康康学习过程"><a href="#下面康康学习过程" class="headerlink" title="下面康康学习过程"></a>下面康康学习过程</h2><p>好多包，我好爱</p><pre><code class="line-numbers language-python">import numpy as npimport tensorflow as tffrom tensorflow.keras.layers import Dropout, Dense, SimpleRNN, LSTMimport matplotlib.pyplot as pltimport osimport pandas as pdfrom sklearn.preprocessing import MinMaxScalerfrom sklearn.metrics import mean_squared_error, mean_absolute_errorimport math</code></pre><p>导入数据和数据预处理：</p><pre><code class="line-numbers language-python">yiliao = pd.read_csv('./SH600519.csv')#print(yiliao)training_set = yiliao.iloc[0:2426 - 300, 2:3].values  #前（1975-300）天的净值作为训练集，表格从0开始计数，2:3是提取[1:2）列，前闭后开，故提取出第二列净值test_set = yiliao.iloc[2426 - 300:, 2:3].values  #后300天的开盘价作为测试集#归一化sc = MinMaxScaler(feature_range=(0, 1))  #定义归一化；缩放到（0,1）之间training_set_scaled = sc.fit_transform(training_set)  #求得训练集的最大最小值这些训练集固有的属性，并在训练集上进行归一化test_set = sc.fit_transform(test_set)  #利用训练集的属性对测试集进行归一化</code></pre><p>还是数据预处理，将数据训练集和测试集划分</p><pre><code class="line-numbers language-python">测试集：csv表格中的前1975-300=1675天的数据#利用for循环，遍历整个训练集，提取训练集中连续60天的开盘价作为输入特征x_train,第61天的数据作为标签，for循环共构建1975-300-60=1615for i in range(60, len(training_set_scaled)):    x_train.append(training_set_scaled[i - 60:i, 0])    y_train.append(training_set_scaled[i: 0])#打乱训练集顺序np.random.seed(7)np.random.shuffle(x_train)np.random.seed(7)np.random.shuffle(y_train)tf.random.set_seed(7)#将训练集由list格式变为array格式x_train, y_train = np.array(x_train), np.array(y_train)#此处整个数据集送入，送入样本数为x_train.shape[0]及1615组数据x_train = np.reshape(x_train, (x_train.shape[0], 60, 1))#测试集：csv表格中后300天数据#...省略for i in range(60, len(test_set)):    x_test.append(test_set[i - 60:i, 0])    y_test.append(test_set[i, 0])#测试集变arry并reshape为符合RNN输入要求：[送入样本数， 循环核时间展开步数， 每个时间步输入的特征个数]x_test, y_test = np.array(x_test), np.array(y_test)x_test = np.reshape(x_test, (x_test.shape[0], 60, 1))</code></pre><p>设定模型：</p><pre><code class="line-numbers language-python">model = tf.keras.Sequential([    SimpleRNN(80, return_sequences=True),    Dropout(0.2),    SimpleRNN(100),    Dropout(0.2),    Dense(1)])model.compile(optimizer=tf.keras.optimizers.Adam(0.001),loss='mean_squared_error')  #损失函数用均方误差</code></pre><p>保存训练好的模型：</p><pre><code class="line-numbers language-python">checkpoint_sava_path = "./checkpoint/jijin.ckpt"if os.path.exists(checkpoint_sava_path + '.index'):    print('--------load the model--------')    model.load_weights(checkpoint_sava_path)cp_callback = tf.keras.callbacks.ModelCheckpoint(filepath=checkpoint_sava_path,                                                 save_weights_only=True,                                                 save_best_only=True,                                                 monitor='val_loss')history = model.fit(x_train, y_train, batch_size=128, epochs=5, validation_data=(x_test, y_test), validation_freq=1,                    callbacks=[cp_callback])model.summary()file = open('./weight.txt', 'w')  #参数提取for v in model.trainable_variables:    file.write(str(v.name) + '\n')    file.write(str(v.shape) + '\n')    file.write(str(v.numpy()) + '\n')file.close()loss = history.history['loss']val_loss = history.history['val_loss']</code></pre><p>画出损失函数图：</p><pre><code>plt.plot(loss, label='Training Loss')plt.plot(val_loss, label='Validation Loss')plt.title('Training and Validation Loss')plt.legend()plt.show()</code></pre><p>测试集输入模型开始预测：</p><pre><code class="line-numbers language-python">predicted_stock_price = model.predict(x_test)# 对预测数据还原--从（0-1）反归一化到原始范围predicted_stock_price = sc.inverse_transform(predicted_stock_price)# 对真实数据还原--从0-1）反归一化到原始范围real_stock_price = sc.inverse_transform(test_set[60:])# 画出真实数据和预测数据对比曲线plt.plot(real_stock_price, color='red', label='Jijin Price')plt.plot(predicted_stock_price, color='blue', label='Predicted Jijin Price')plt.title('Jijin Price Prediction')plt.xlabel('Time')plt.ylabel('Jijin Price')plt.legend()plt.show()</code></pre><p>评价模型：</p><pre><code class="line-numbers language-python">mse = mean_squared_error(predicted_stock_price, real_stock_price)# 均方根误差rmse = math.sqrt(mean_squared_error(predicted_stock_price, real_stock_price))# 平均绝对误差mae = mean_absolute_error(predicted_stock_price, real_stock_price)</code></pre><p>以上<br></p><p><strong>完整代码会上传到我的<a href="https://github.com/yuukyou-chan">Github</a>，欢迎fock，顺便求助一下俺的问题555</strong></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 神经网络 </tag>
            
            <tag> LSTM </tag>
            
            <tag> RNN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习入门笔记</title>
      <link href="2021/05/21/ML/"/>
      <url>2021/05/21/ML/</url>
      
        <content type="html"><![CDATA[<h1 id="一、数据处理"><a href="#一、数据处理" class="headerlink" title="一、数据处理"></a>一、数据处理</h1><h2 id="缺失值判断："><a href="#缺失值判断：" class="headerlink" title="缺失值判断："></a>缺失值判断：</h2><ol><li><p><code>pd.isnull(movie)</code> 如果是缺失值返回true；</p><p>返回结果是一张表，表里填满 true和false；</p></li><li><p>判断整张表是否有缺失值：</p><p><code>np.any(pd.isnull(movie))</code></p><p>反三：any-all      isnull-notnull</p><p>返回结果为一个值：true/false</p></li></ol><h2 id="缺失值删除和替换"><a href="#缺失值删除和替换" class="headerlink" title="缺失值删除和替换"></a>缺失值删除和替换</h2><ol><li><p><code>movie(“列变量名”).fillna(value=movie["列变量名"].mean(), inplace=True)</code>  </p><p>替换变量函数：fillna( )</p><p>.mean()：用该列平均值替换NaN值</p><p>inplace=Ture:   不创建新的对象，直接对原始对象进行修改；</p><p>inplace=False：对数据进行修改，创建并返回新的对象承载其修改结果。</p></li><li><p>替换所有缺失值：</p><pre><code class="line-numbers language-python">for i in movie.columns：    #遍历列  if np.any(pd.isnull(movie[i])) == True:  #如果此列有NaN值        movie[i].fillna(value=movie[i].mean(), inplace=True)np.any(pd.isnull(movie))  #检测是否替换完成</code></pre></li><li><p>删除缺失值（整张表中）</p><p><code>data = movie.dropna()</code></p></li><li><p>缺失值不是NaN的处理情况</p><p>如将 “？”替换成np.nan</p><p><code>wis = wis.replace(to_replace='?',value=np.NaN)</code></p></li></ol><h2 id="数据离散化"><a href="#数据离散化" class="headerlink" title="数据离散化"></a>数据离散化</h2><p><code>pd.qcut(data,q)</code></p><h2 id="数据合并"><a href="#数据合并" class="headerlink" title="数据合并"></a>数据合并</h2><p><code>pd.concat({data, data_dummies}, axis=1)</code> axis参数表作用方向：此句中的axis=1表示两张表按行(水平方向)拼接</p><p><code>pd.merge(left, right, how="inner", left_on=None,right_on=None)</code></p><h2 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h2><p>seaborn库介绍</p><ul><li>seaborn.implot() 可以再绘制二维散点图时自动完成回归拟合</li><li>data=  ：关联数据集</li><li>hue=“</li></ul><p>matplotlin库介绍</p><p>绘制柱状图：</p><p><img src="https://gitee.com/Yuukyou/pic/raw/master/blog/%E6%9F%B1%E7%8A%B6%E5%9B%BE.png" alt="柱状图"></p><h2 id="数据归一化"><a href="#数据归一化" class="headerlink" title="数据归一化"></a>数据归一化</h2><pre><code class="line-numbers language-python">from sklearn.preprocessing import MinMaxScaler</code></pre><p><img src="https://gitee.com/Yuukyou/pic/raw/master/blog/%E6%95%B0%E6%8D%AE%E5%BD%92%E4%B8%80%E5%8C%96.png" alt="数据归一化"></p><p><img src="/2021/05/21/ML/%E5%BD%92%E4%B8%80%E5%8C%96%E5%AE%9E%E4%BE%8B.png" alt="归一化实力"></p><h2 id="数据标准化"><a href="#数据标准化" class="headerlink" title="数据标准化"></a>数据标准化</h2><p><img src="https://gitee.com/Yuukyou/pic/raw/master/blog/%E6%95%B0%E6%8D%AE%E6%A0%87%E5%87%86%E5%8C%96API.png" alt="数据标准化AIP"></p><p>实例：修改归一化实例图中的<code>transfer = StandardScaler</code> 即可</p><h2 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h2><p>API：<code>sklearn.linear_model.LinearRegression()</code></p><p>属性：LinearRegression.coef_：回归系数</p><p><img src="https://gitee.com/Yuukyou/pic/raw/master/blog/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92.png" alt="线性回归"></p><p>优化算法:</p><ul><li>正规方程(直接矩阵运算求w权重,如果特征多求解速度慢,只能在线性回归总运用),</li><li>梯度下降(沿着切线向下的方向，递归迭代计算权重,广泛使用)：找到当误差最小时，最优自变量|权重|参数</li><li>性能评估：使用均方误差；<br>适用场景：</li><li>小规模数据建议LinearRegression(不能解决过拟合问题)和岭回归；</li><li>大规模用SGDRegressor：随机梯度下降</li></ul><h3 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h3><p>目的：求出当误差最小时，最优自变量|权重|参数</p><p><code>sklearn.linear_model.SGDRegression()</code></p><ul><li>包：from sklearn.linear_model import SGDRegressor</li><li>支持loss函数(损失类型),和正则化惩罚项来拟合线性回归模型</li><li>loss=‘squared_loss’:默认普通最小二乘法</li><li>可以用网络搜索算法来优化学习率和梯度迭代次数</li><li>fit_intercept=True :是否计算偏置</li><li>learning_rate=‘invscaling’:学习率</li><li>‘invscaling’：学习率算法 包含 “comstant”,“optimal”,‘invscaling’,</li></ul><p>对于常数值的学习率可以使用<strong>“comstant”</strong>==0</p><p>max_iter=None,梯度迭代次数<br>SGDRegressor.coef_:查看回归系数函数</p><p><img src="https://gitee.com/Yuukyou/pic/raw/master/blog/image-20210528133121562.png" alt="数据处理"></p><p><img src="https://gitee.com/Yuukyou/pic/raw/master/blog/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E5%B8%B8%E7%94%A8%E5%B8%B8%E6%95%B0.png" alt="梯度下降常用常数"></p><p><code>learning_rate = "constant" </code>指学习率为常数，但是一般常数学习率效果不好，需要使用动态变化的学习率（invscaling）</p><p>eta0：<strong>一般取值 0.01 ~ 0.001 为宜</strong></p><h2 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h2><p>思想：输入最原始、最基本的数据，通过模型来进行特征工程，进行更高级的特征学习（多个特征值聚合成一个特征值），然后通过传入的数据来确定合适的参数，让模型更好的拟合数据。</p><p>激活函数：</p><ul><li>作用：增加模型的非线性分割能力，提供鲁棒性（健壮性），缓解梯度消失，加速模型收敛</li><li>常用sigmoid：（0-1）、tanh</li></ul><p>损失函数：</p><p>学习率（leaning rate）：</p><ul><li><p>当学习率设置过小时，收敛过程变得十分缓慢。</p></li><li><p>当学习率设置过大时，梯度可能会在最小值来回震荡，跳过最小值，甚至无法收敛。</p></li></ul><p>参数axis：</p><ul><li>表示操作抽</li><li>axis = 0 ：表纵向</li><li>axis = 1 ：表横向</li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 数据挖掘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库学习笔记（持续更新4.18）</title>
      <link href="2021/04/17/DataBase/"/>
      <url>2021/04/17/DataBase/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章：绪论"><a href="#第一章：绪论" class="headerlink" title="第一章：绪论"></a>第一章：绪论</h1><h1 id="第二章：关系型数据库"><a href="#第二章：关系型数据库" class="headerlink" title="第二章：关系型数据库"></a>第二章：关系型数据库</h1><blockquote><h3 id="1、一些概念"><a href="#1、一些概念" class="headerlink" title="1、一些概念"></a>1、一些概念</h3></blockquote><p>关系：实体与实体之间的联系（可以看做一张二维表）、</p><p>候选码：若关系中的一个属性或属性组的值能够唯一地标识一个元组，且他的真子集不能唯一的标识一个元组，则称这个属性或属性组做候选码。</p><p>主码：若一个关系有多个候选码，则选定其中一个为主码</p><p>主属性：候选码的各个属性成为主属性</p><p>全码：表中的所有属性都是这个表的候选码，则称为全码</p><p><strong>外键（外码）</strong>：<mark>如果公共关键字在一个关系中是主键，那么这个公共关键字被称为另一个关系的外键。</mark></p><p>关系三种类型：①基本表（基本关系）②查询表③视图表</p><p>关系模式：关系的描述称为关系模式（即为表头）</p><blockquote><h3 id="2、关系完整性"><a href="#2、关系完整性" class="headerlink" title="2、关系完整性"></a>2、关系完整性</h3></blockquote><ol><li>实体完整性：实体完整性要求每个数据表都必须有主键，而作为主键的所有字段，其属性必须是独一及<strong>非空值</strong>。</li><li>参照完整性：参照的关系中的属性值必须能够在被参照关系找到或者取空值</li><li>用户定义完整性</li></ol><blockquote><h3 id="3、列级完整性约束和表级完整性约束"><a href="#3、列级完整性约束和表级完整性约束" class="headerlink" title="3、列级完整性约束和表级完整性约束"></a>3、列级完整性约束和表级完整性约束</h3></blockquote><p>列级约束有六种：Primary key（主键）、foreign key（外键） 、 unique（唯一）、 check （检查）、default （默认）、not null/ null（非空/空值 ）<br>表级约束有四种：Primary key（主键）、foreign key（外键） 、 unique（唯一）、 check （检查）</p><p><strong>只能是列级完整性约束</strong>：default （默认）、not null/ null（非空/空值 ）</p><h1 id="第三章：SQL语句"><a href="#第三章：SQL语句" class="headerlink" title="第三章：SQL语句"></a>第三章：SQL语句</h1><blockquote><h3 id="1、数据类型"><a href="#1、数据类型" class="headerlink" title="1、数据类型"></a>1、数据类型</h3></blockquote><p><img src="https://gitee.com/Yuukyou/pic/raw/master/blog/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B1.png" alt="数据类型1"></p><p><img src="https://gitee.com/Yuukyou/pic/raw/master/blog/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B2.png" alt="数据类型2"></p><blockquote><h3 id="2、基本表的定义、修改与删除"><a href="#2、基本表的定义、修改与删除" class="headerlink" title="2、基本表的定义、修改与删除"></a>2、基本表的定义、修改与删除</h3></blockquote><h5 id="基本操作语句"><a href="#基本操作语句" class="headerlink" title="基本操作语句"></a>基本操作语句</h5><h5 id="表的定义"><a href="#表的定义" class="headerlink" title="表的定义"></a>表的定义</h5><pre><code class="line-numbers language-sql">create table student (    列名 数据类型 列级完整性约束    sno char(9) unique,    ssex char(2),    primary KEY(sno),    foreing key(sno) refferences student(sno));</code></pre><h5 id="表的修改"><a href="#表的修改" class="headerlink" title="表的修改"></a>表的修改</h5><p><img src="https://gitee.com/Yuukyou/pic/raw/master/blog/%E4%BF%AE%E6%94%B9%E8%A1%A8.png" alt="修改表"></p><p>[]:可以出现，可以不出现</p><p>&lt;&gt;:一定会出现<code> drop</code>是删除</p><p>注：上述</p><h5 id="表的删除"><a href="#表的删除" class="headerlink" title="表的删除"></a>表的删除</h5><blockquote><h3 id="3、数据查询"><a href="#3、数据查询" class="headerlink" title="3、数据查询"></a>3、数据查询</h3></blockquote><p><strong>数据查询是数据库的<mark>核心操作</mark></strong></p><p>查询的一般格式（块）为：</p><pre><code class="line-numbers language-sql">select  目标列表达式from 表明或视图名where 条件表达式group by 列名 having 选择组的条件order by 列名 asc/desc（升降序）</code></pre><p><mark><strong>执行顺序为</strong></mark>：from→where→select</p><h4 id="一、单表查询："><a href="#一、单表查询：" class="headerlink" title="一、单表查询："></a>一、单表查询：</h4><ol><li><p><strong>选择表中的若干列</strong></p><p>（1）查询指定列</p><pre><code class="line-numbers language-sql">select Sname，Sno，Sdeptfrom Student；</code></pre><p>（2）查询所有列</p><pre><code class="line-numbers language-sql">select *from Student；</code></pre><p>（3）查询经过计算的值</p><p>select语句中的目标表达式可以是表中的<strong>属性列</strong>，也可以是<strong>表达式</strong>，还可以是<strong>字符串常量</strong>、<strong>函数</strong>等</p><p>例：查询全体学生的姓名及其出生年份</p><pre><code class="line-numbers language-sql">select Sname，'Year of Birth' birth，2021-Sage   /*当前年份-年龄*/from Student；</code></pre><p>输出结果为：</p><table><thead><tr><th align="center">Sname</th><th align="center">birth</th><th align="center">2021-Sage</th></tr></thead><tbody><tr><td align="center">李勇</td><td align="center">Year of Birth</td><td align="center">1994</td></tr><tr><td align="center">李晨</td><td align="center">Year of Birth</td><td align="center">1995</td></tr></tbody></table><p>注意：上方代码块中的<code> 'Year of Birth' birth</code>表示将’Year of Birth’列命名为birth，中间用空格号分隔开</p><br></li><li><p><strong>选择表中的若干元组</strong></p></li></ol><p>（1）消除取值重复的行</p><p><strong>distinct</strong>：消除取值重复的行<code> select distinct Sno</code><br></p><p>若没有指定<code>distinct</code>关键字则默认为all</p><p>（2）查询满足条件的元组</p><p><strong>where</strong>：查询满足条件的元组</p><p><img src="/2021/04/17/DataBase/%E5%B8%B8%E7%94%A8%E6%9F%A5%E8%AF%A2%E6%9D%A1%E4%BB%B6.png" alt="常用查询条件"></p><pre><code class="line-numbers language-sql">①比较大小where Sdept='cs'where Sage&lt;20②确定范围where Sage between 20 and 23③确定集合where Sedpt in('CS','MA','IS')④字符分配  %：代表任意长度（可以为0）的字符串。  _：代表任意单个字符where Sname like'_阳%'（查询第二个字为阳的学生）⑤涉及空值的查询where Grade is null⑥多充条件查询使用 and 或者 or，通常 and的优先级高于 or，可以使用括号改变优先级where Sdept='CS'and Sage&lt;20注：实际上 in是多个 or运算符的缩写</code></pre><br><p>   3.<strong>order by语句</strong></p><p>升序：ASC</p><p>降序：DESC</p><p><strong>默认为升序</strong></p><p>例：查询结果按所在的系的系号升序排列，同一系中的学生按年龄降序排列：</p><p><code>order by Sdept，Sage desc</code></p><br><ol start="4"><li><strong>聚集函数</strong></li></ol><p><img src="/2021/04/17/DataBase/DataBase%5C%E8%81%9A%E9%9B%86%E5%87%BD%E6%95%B0.png" alt="聚集函数"></p><p><code>查询学生总人数：select count(distinct Sno)</code></p><p><code>计算平均成绩：select avg(Grade)</code></p><br><ol start="5"><li><strong>group by 语句</strong></li></ol><p>group by子句将查询结果按某一列或多列的值分组，值相等的为一组。</p><pre><code class="line-numbers language-sql">求各个课程号及相应选课人数select Con,count(Sno)from scgroup by Con***查询选修了三门以上课程的学生学号select Snofrom scgroup by Snohaving count()***求选课在三门以上（包括三门）且各门课程均及格的学生的学号及其总成绩，查询结果按总成绩降序列出select sno,sum(score)from scwhere score&gt;=60group by snohaving count(*)&gt;=3order by sum(score)desc执行过程：1.from   取出整个sc2.where  筛选score&gt;=60的元组3.group by  将选出的元组按sno分组4.having  筛选选课三门以上的分组5.select  将选中的组中提取学号和总成绩6.order by  将选取结果排序先用where语句查询效率更高，如果直接用group则将会在sc表中的所有元组进行分组，若先用where则group将在筛选出来的元组中进行分组，提高了查询效率。</code></pre><p>执行顺序为：where→group by→having</p><p>辨析：where作用于<strong>基本表</strong>或者<strong>视图</strong>，having作用于<strong>组</strong></p><br><h4 id="二、连接查询"><a href="#二、连接查询" class="headerlink" title="二、连接查询"></a>二、连接查询</h4><p><strong>1.等值于非等值连接查询</strong></p><p><code>where student.sno = sc.sno</code></p><p>以上比较运算符‘ = ’可以有：=、&gt;、&lt;、&gt;=、&lt;=</p><p><em>此时连接查询的where句子用来连接两个表的条件称为<strong>连接条件</strong>或者*<em>连接谓词</em></em></p><p>*连接谓词中的列名称为<strong>连接字段</strong>（student.sno）</p><br><p><strong>2.自身连接</strong></p><br><p><strong>3.外连接</strong></p><p>定义：有时想以学生标student为主体，列出每个学生的基本情况及选课情况，如果某个学生没有选课，仍把该学生的记录留在结果关系中，而在sc表中的属性值加上NULL，这时就需要外连接。</p><pre><code class="line-numbers language-sql">  </code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库，学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于爬虫爬取基金信息</title>
      <link href="2021/04/11/FundSpyder/"/>
      <url>2021/04/11/FundSpyder/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>  经常看到和听到神经网络这个名词，觉得逼格很高。昨天看了一下机器学习的神经网络算法，是挺高级的，还蛮感兴趣，就是看不懂哈哈哈哈。在B站上看了一个《一小时大话BP神经网络》教我如何从入门到放弃（打脸）。里面涉及的数学统计知识太多了，可惜我是个数学白痴，但是对机器学习确实蛮感兴趣的，神经网络学不明白可以换个简单的机器学习模型试试。后来想着能不能用机器学习预测一下基金走势，随便玩玩不做投资建议，体验一下机器学习的高大上，等我撸出机器学习模型的demo也算是半个涉足过人工智能领域的大学生了哈哈哈哈哈哈哈哈。</p><p>  这篇文章便是为了提供机器学习数据基础——收集基金信息。</p><h2 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h2><ol><li>选择一个好爬的基金网页，这里以天天基金为例（网上关于天天基金爬取教程还蛮多的哈，可能是好抓包）</li><li>打开浏览器的开发工具，切换到network下，点击下一页基金，查看发送的ajax请求。很容易发现有个请求里的jason数据就是我们想要的数据，抓到包就可以开始撸代码了！</li><li>具体代码思路不细说了，看代码注释也比较详细了</li></ol><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><pre><code class="line-numbers language-python">import requestsimport jsonimport reimport pandas as pddf_list = []  #用于存放每页表格for index in range(1,100):  #index是url中的页码，在url中用占位符表示    url = 'http://api.fund.eastmoney.com/f10/lsjz?callback=jQuery1830730414064313736_1618137747657&amp;fundCode=110023&amp;pageIndex={}&amp;pageSize=20&amp;startDate=&amp;endDate=&amp;_=1618137795389'.format(index)    #请求头    headers = {        #防盗链     确定来路        'Referer': 'http://fundf10.eastmoney.com/',        #身份证        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.114 Safari/537.36'    }    # 模拟浏览器发送请求  接收数据    resp = requests.get(url,headers=headers)    html = resp.text    res = re.findall('\((.*?)\)',html) #正则表达式把jquery....去掉    datas = json.loads(res[0])["Data"]["LSJZList"] # res是数组，要用res[0]表示                                                   # json.loads 用于提取字符串中的json格式    # 整理成表的形式    df = pd.DataFrame(datas)    df_list.append(df)  #apend方法：在表末尾添加元素df_data = pd.concat(df_list)df_data.to_csv('易方达医疗保健行业混合 (110023).csv',index=False) #index=false 表示不输出索引值</code></pre><h2 id="爬取结果"><a href="#爬取结果" class="headerlink" title="爬取结果"></a>爬取结果</h2><p>在工程文件路径下生成了一个.csv文件（.csv常用于数据分析）</p><p><img src="https://gitee.com/Yuukyou/pic/raw/master/blog/1.png" alt="1"></p><p>把这支基金从出生到现在的数据都爬完啦，也就不到2000组（为了便于观看，列名已经修改）</p><p><img src="https://gitee.com/Yuukyou/pic/raw/master/blog/2.png" alt="2"></p><hr><p>  以上就是数据收集的过程，不知道下篇能不能找到合适的机器学习模型建立，希望能找一个既简单拟合度又不是太离谱的模型吧😚😚😚</p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于java实现自动核查作业程序check</title>
      <link href="2021/03/30/JavaCheck/"/>
      <url>2021/03/30/JavaCheck/</url>
      
        <content type="html"><![CDATA[<h2 id="编写背景"><a href="#编写背景" class="headerlink" title="编写背景"></a>编写背景</h2><p>  大二上学期期末的时候堆了一堆实验报告要交，数据结构2个实验，java4个实验，还有线代截图要收，每次收作业即使通知同学们按规定命名文件但还有很多同学不按规定命名五花八门啥都有，每次收作业都要收个1 个多小时才能收齐，期末都没得时间复习了<span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p>  然后刚好那个学期学了java，对java还比较感兴趣和熟悉，刚一考完试我就开始动手了，边学边写花了我5个小时。整个代码的实现逻辑都是自己想的，然后剩下一下没学过的类和方法在网上学习。之前用python写过一个差不多的十几行的代码实现“微信群接龙”查找名字，这个程序也是借鉴了上次的思想。</p><p>  这是V1.0版本的，功能只有查找没交作业名单的功能，本来第二次更新V2.0的时候加入了自动重命名功能的，但是我今天在打开NetBeans的时候之前写代码都不见了55555，Github上也找不到（我记得当时备份了yue），现在这个代码还是我翻聊天记录找的，之前复制给别的班学委留下来的记录（还好当时发给别人过）。不然真的惨死了，真的一点都想不起来之前怎么写的了。</p><p>  <strong>V2.0</strong>版本虽然新增了自动重命名功能，但是我当时并没有把学号加进去，当时是有思路的，但嫌麻烦是懒得弄了，看需要吧，如果我或者大家需要自动重命名功能的话我到时会在重新写一个完整的。</p><p>  <strong>V3.0</strong>版本我当时是想做一个GUI然后打包的，方便大家使用，本来是想在暑假做的，后来暑假。。。（懂得都懂）结果现在关于GUI的知识也都已经忘完了，随缘<span class="github-emoji"><span>🙏</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f64f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>。如果哪天心血来潮的话再上线吧。</p><p>  话不多说，开干！</p><hr><p>——2021.4.1更新：已经在github上找到V2.0版本的代码了，一下文章是V2.0的文档。代码版本管理真的太重要了，之前的git操作都忘了差不多了，看来得重新再看看git原理了<span class="github-emoji"><span>✊</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/270a.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，顺便吐槽一下github打开真的太慢了，每次打开都好久好久都毛火完了，是不是该考虑转gitee了，有没有用过gitee的伙伴分享一下体验<span class="github-emoji"><span>🙏</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f64f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>🙏</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f64f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><h2 id="使用前的准备工作"><a href="#使用前的准备工作" class="headerlink" title="使用前的准备工作"></a>使用前的准备工作</h2><ol><li>Java开发环境，我们老师推荐我们用的是NetBeans，当然其他的也可以</li><li>一个存放了班级所有名字的.txt文件，注意格式每一行放一个人名</li><li>如果使用重命名功能，千万千万记得备份一份，万一重命名出现了BUG名字就乱套了</li><li>重命名功能可能不太稳定注意备份测试后使用</li></ol><h2 id="代码原理"><a href="#代码原理" class="headerlink" title="代码原理"></a>代码原理</h2><p>  一共两个类：</p><ol><li>Check类：是主类，包含核心查找方法以及人名的读取</li><li>FileNames类：主要包含关于文件操作的属性和方法</li></ol><h4 id="核心查找方法的原理："><a href="#核心查找方法的原理：" class="headerlink" title="核心查找方法的原理："></a>核心查找方法的原理：</h4><p>  第一步：创建全体名单数组（allName[]）</p><p>  用一个.txt文件按行存放每个同学的名字（可以从班级名字表中复制），再按行读取每个名字存到一个字符串数组（allName[]）里，这样就能确保每个名字独占一个数组空间。</p><p>  第二步：创建包含所有文件名的字符串型变量（txt）</p><p>  把下载的同学们的作业文件名也分别存到一个字符串型数组（name[]）里，再把每个文件名取出来集中放到一个字符串变量（txt）中。</p><p>  第三步：在txt中查找allName中的每一个元素</p><p>  使用java String 类中的contain方法即可实现。</p><h4 id="重命名方法原理："><a href="#重命名方法原理：" class="headerlink" title="重命名方法原理："></a>重命名方法原理：</h4><p>等待更新……</p><h2 id="源代码展示"><a href="#源代码展示" class="headerlink" title="源代码展示"></a>源代码展示</h2><p>Check类：（又重新添加了很多注释，应该不难看懂）</p><pre><code class="line-numbers language-java">package check;import java.io.File;import java.io.FileReader;import java.io.IOException;import java.io.LineNumberReader;/** * * @author Yuukyou *///check类public class Check {    String[] allName= new String[50];                                     //数组allNme用于存放完整的班级名单，默认长度为50，可根据具体人数修改    String txt = "";                                                                 //初始化txt变量            /***该方法用于全体人名的读取和写入***/   public  void printByFileReader(String filePath) throws IOException{        File file = new File("E:\\全体名单.txt");                                //打开存放有全体名单的txt文本文件，每一行存放一个人名        FileReader fileReader = new FileReader(file);        LineNumberReader reader = new LineNumberReader(fileReader);  //创建reader对象用于读取每一行的人名        String txt = "";            for(int lines=1;lines&lt;=35;lines++){                              //lines：行数，即读取人名数量，根据具体人数改变        txt = reader.readLine();                                           //txt记录每一次读取到的人名        allName[lines]=txt;                                                 //将每次txt中的人名存放到allName数组       // System.out.println("第"+lines+"行的内容是"+allName[lines]);     //此行用于测试是否存放成功   }        reader.close();        fileReader.close();}      /***check方法用于检测没交作业的同学***/  public void check(String[] all,String txt){                 //txt存放所有文件名            for(int i=1;i&lt;=35;i++){          boolean status =txt.contains(all[i]);                                //每次取全体名单中的一个元素，在txt中查找          if(!status) {              System.out.println(all[i]+"未交作业");}                        //若不存在则输出未交作业名单          }            }       public static void main(String[] args) throws IOException  {        // TODO code application logic here        FileNames Newname = new FileNames();        Newname.FileName("E:\\电商1903作业\\电商1903java实验报告\\实验一");        Check Allname  = new Check();        Allname.printByFileReader("E:\\全体名单.txt");        Allname.check(Allname.allName,Newname.FileName("E:\\电商1903作业\\电商1903java实验报告\\实验一"));          }    }</code></pre><p>FileNames类：（一些被注释掉的代码块是当时写代码时候的其他版本，没注释的是慢慢调式过来能用的版本，大家也可以自己把注释的代码块删了）</p><pre><code class="line-numbers language-java">package check;import java.io.File;import java.io.IOException;/** * * @author Yuukyou */public class FileNames {        static String partaddress = "E:\\电商1903作业\\电商1903java实验报告\\实验二";    static String alladdress = "E:\\全体名单.txt";    static String partName = "";  //调用txt前先使用FileName方法    public FileNames() {    }         public static String FileName(String filePath){        File file =new File(filePath);                        //传入        String[] name = file.list();                           //String[] list() : 返回一个字符串数组，这些字符串指定file路径下的所有文件和目录  ==》列出文件名        String txt="";        for(int i=1;i&lt;name.length;i++){                 //将所有文件名从数组name中取出，放到txt变量中            txt+=name[i];        }      //   测试 System.out.println(txt);        return txt;}           public static String GetFileName(String filePath) {        File file = new File(filePath);        String[] name = file.list();        //String txt="";        for (int i = 0; i &lt; name.length; i++) {            partName += name[i];        }           //System.out.println(partName);        return partName;    }                 public static void Rename(String filePath) throws IOException {        File file = new File(filePath);        String[] filename = new String[50];       // file.renameTo(new File(filePath));        //读取文件夹下的文件，存进一个文件数组        File[] listfile = file.listFiles();              //读取每个文件名称，找下标对应                       String[] name = file.list();       // for(int l=0;l&lt;name.length;l++){       // System.out.println(name[l]);}        int k= 0;        for (k=0; k &lt; name.length; k++) {            filename[k] += name[k];         System.out.println("第"+k+"个文件名"+filename[k]);        }              //  File file = new File(partaddress);     /* FileReader fileReader = new FileReader(file);        LineNumberReader reader = new LineNumberReader(fileReader);        String txt = "";    for(int lines=0;lines&lt;=35;lines++){        txt = reader.readLine();        filename[lines]=txt;        System.out.println("第"+lines+"行的内容是"+filename[lines]);    }*/        //遍历重命名         Check check = new Check();         check.printByFileReader(alladdress);        Check Allname = new Check();        Allname.printByFileReader(alladdress);        //System.out.println();        FileNames partname = new FileNames();        partname.GetFileName(partaddress);        //System.out.println(partname.FileName(partaddress));        for (int i = 1; i &lt; listfile.length; i++) {            if (listfile[i].isFile()) {               // boolean status = false;                for (int j = 0; j &lt;= Allname.allName.length; j++) {                   boolean  status = filename[i].contains(Allname.allName[j]);    // ！BUG：第0个文件名nulldesktop.ini                    // System.out.println(Allname.allName[j]);                    if (status) {                        String newname = "电商1903-java实验二-" + Allname.allName[j] + ".doc";                        File refile = new File(filePath + File.separator + newname);                        listfile[i].renameTo(refile);                        System.out.println("重命名成功"+newname);                        break;                    }                }                /*  if(check.check(Allname.allName,partname.FileName(partaddress)))                 {                 for(int j=1;j&lt;=35;j++){                 //文件定位                 String newname="电商1903-Java实验二"+Check.allName[j]+".doc";                 File refile=new File(filePath+File.separator+newname);                 listfile[i].renameTo(refile);                 }                 }*/                System.out.println(listfile[i] + "重命名成功！");            }        }    }}</code></pre><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>如果你觉得这篇文章对你还有点用的话，欢迎打赏博主一块小饼干(o^^o)没有小饼干留下你的小脚印也行(^з^)，如果有更好的算法或者功能方面的建议也欢迎评论区或者留言区交流哦(^_^)v</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 学委三件套 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Json格式和Ajax的学习</title>
      <link href="2021/03/22/JsonAndAjax/"/>
      <url>2021/03/22/JsonAndAjax/</url>
      
        <content type="html"><![CDATA[<blockquote><p>JSON格式</p></blockquote><p>基本语法：</p><ul><li><p>对象表示为键值对，数据用逗号分隔</p></li><li><p>花括号保存数组对象</p></li><li><p>方括号保存数组</p><p><strong>JSON 键值对</strong>是用来保存 JavaScript 对象的一种方式，和 JavaScript 对象的写法也大同小异，键/值对组合中的键名写在前面并用双引号 “” 包裹，使用冒号 : 分隔，然后紧接着值：</p><pre><code class="line-numbers language-json">{"name": "QinJiang"}{"age": "3"}{"sex": "男"}</code></pre></li></ul><p><strong>JSON与JavaScript的关系：</strong></p><p>   JSON 是 JavaScript 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串。</p><p><strong>JSON 和 JavaScript 对象互转</strong></p><p>要实现从JSON字符串转换为JavaScript 对象，使用 JSON.parse() 方法：</p><pre><code>var obj = JSON.parse('{"a": "Hello", "b": "World"}');//结果是 {a: 'Hello', b: 'World'}</code></pre><p>要实现从JavaScript 对象转换为JSON字符串，使用 JSON.stringify() 方法：</p><pre><code>var json = JSON.stringify({a: 'Hello', b: 'World'});//结果是 '{"a": "Hello", "b": "World"}'</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Json </tag>
            
            <tag> Ajax </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于IAR&amp;STM32调试过程问题记录</title>
      <link href="2021/03/19/IAR/"/>
      <url>2021/03/19/IAR/</url>
      
        <content type="html"><![CDATA[<h2 id="IAR烧录时提示没有设备连接"><a href="#IAR烧录时提示没有设备连接" class="headerlink" title="IAR烧录时提示没有设备连接"></a>IAR烧录时提示没有设备连接</h2><p>当连接好电脑鼠并且检查线路没有问题并且驱动程序正常运行时，点击调试，出现“STM32 no emulator connected via USB…..”提示。</p><p>在网上查找了很多资料基本上4个问题：</p><pre><code class="line-numbers language-供电">1、板子一定要供电！2、ST-LINK是否接触不良确保ST-LINK跟板子连接完好3、按住reset点击download硬件和接线都没问题情况下，这时候可能是SWD的引脚被占用了，或者被禁用了。这时候ST-LINK自然无法通过SWD跟板子通信，所以才会提示No Target connected。所以，这时候按住reset，再点击download，再松开reset。原理就是在程序运行到SWD引脚占用之前，把新的程序烧录进去，抢个时间差。但是这招不是每次都管用，有概率性失败。但是不要紧，我们还有第四招4、boot0 接高电平download正常程序后，再接回低电平，即可烧录————————————————版权声明：本文为CSDN博主「小康师兄」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/kangweijian/article/details/107564868```</code></pre><p>但是这4个方法我都试过一遍<strong>还是没有解决。</strong></p><p>最后看到一篇文章受到启发：<a href="https://blog.csdn.net/c1063891514/article/details/81545601">https://blog.csdn.net/c1063891514/article/details/81545601</a></p><p>解决方法与链接文章没太大关系</p><p>是这篇文章最后两张图引起了我的注意，便想是不是连接设备接口没设置对，设置好接口果然设备连接成功了！！！具体步骤如下：</p><p>1、右键点击demo-Debug，选择Opotions</p><p><img src="/2021/03/19/IAR/1.jpg" alt="1"></p><p>2、选择Debugger设置Driver为图示<img src="https://gitee.com/Yuukyou/pic/raw/master/blog/2.jpg" alt="2"></p><p>3、点击Download设置，将图示√上即可<img src="https://gitee.com/Yuukyou/pic/raw/master/blog/3.jpg" alt="image-3"></p><p>点击OK后IAR即可正常识别设备，记得<em><strong>编译</strong></em>后，再烧录！！</p><p>电脑鼠连接不上电脑这个问题真的困扰了我们队伍好久！找老师又找学长又找老师又找学长,头发都快给我薅没了！体会还蛮深刻的，网络真的是个好东西，不懂的多问问别人，虽然别人不一定能帮你解决问题，但是会给你启发！<br><br>最后发个喜报！我买的域名终于过审了！！！！普天同庆！！！<br></p><p>之前因为重重问题来来回回和腾讯打了5、6个电话，修改又驳回4次信息，最后腾讯还是冒着风险帮我把备案提交给管局的，真的差点我都不想要这个域名了，心底一块石头终于落地了。<br><br></p><p>如果你觉得这篇文章解决了你的问题或者说对你还有用的话，欢迎打赏博主一块小饼干⸜₍๑•⌔•๑ ₎⸝。</p><p>如果有什么问题可以在评论区底下留言哦，欢迎交流<em>⸜( •ᴗ• )⸝</em><br><br><br><br></p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IAR </tag>
            
            <tag> STM32 </tag>
            
            <tag> 电脑鼠 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown&amp;hexo&amp;Git常用操作</title>
      <link href="2021/03/05/GitAndHexo/"/>
      <url>2021/03/05/GitAndHexo/</url>
      
        <content type="html"><![CDATA[<h1 id="常用Hexo-amp-Git操作"><a href="#常用Hexo-amp-Git操作" class="headerlink" title="常用Hexo &amp; Git操作"></a>常用Hexo &amp; Git操作</h1><h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><h3 id="使用hexo新建文章"><a href="#使用hexo新建文章" class="headerlink" title="使用hexo新建文章"></a>使用hexo新建文章</h3><br><ul><li>新建文章命令 ：<code>$ hexo new &lt;title&gt;</code></li></ul><p>输入上行命令之后在post文件夹出现两个文件，title文件夹用于存放图片资源；md文件则用于书写文章。</p><ul><li>在md文件头部信息补充分类信息：<code>categories:</code>(注意空格)</li></ul><p><strong>md常用语法：</strong></p><ol><li><p>标题：<code>#H1    一级标签...</code></p></li><li><p>无序列表：<code>+ 123  /- 123  /* 123</code></p></li><li><p>有序列表：<code>1. ABC  /2. ABC  /3.ABC</code></p></li><li><p>引用说明区块：<code>&gt; 引用内容</code></p></li><li><p>代码块：<code>1.少量代码，单行使用，直接用`包起来   2.大量代码需要多行使用，用三个`包裹起来</code></p></li><li><p>在文章中插入图片：<code>![1](./title/1.jpg)</code></p></li><li><p>链接：<code>链接的文字放在[]中，链接地址放在随后的()中，链接也可以带title属性，链接地址后面空一格，然后用引号引起来:[简书](https://www.jianshu.com "创作你的创作")</code></p></li><li><p>分割线：</p><pre><code class="line-numbers language-markdown">---- - -------**** * *******____ _ _______</code></pre></li><li><p>首行缩进</p><pre><code class="line-numbers language-markdown">&amp;emsp; or &amp;#8195;  表示一个全角的空格&amp;emsp;&amp;emsp; 两个全角的空格（用的比较多）</code></pre></li></ol><br><h3 id="hexo常用命令"><a href="#hexo常用命令" class="headerlink" title="hexo常用命令"></a>hexo常用命令</h3><p><code> $ hexo clean</code> </p><p>清除缓存和已生成静态文件<br></p><br><p><code>$ hexo g</code></p><p>生成静态文件<br></p><br><p><code> $ hexo s</code></p><p>启动服务器<br></p><br><p><code>$ hexo d</code></p><p>部署网站<br></p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><h3 id="使用git管理代码版本"><a href="#使用git管理代码版本" class="headerlink" title="使用git管理代码版本"></a>使用git管理代码版本</h3><h3 id="git常用命令"><a href="#git常用命令" class="headerlink" title="git常用命令"></a>git常用命令</h3><p><code>$ git init</code></p><p>在当前目录新建一个git代码库</p><br><p><code>$ git status</code></p><p>查看跟踪状态</p><br><p><code>$ git add flies（.）</code></p><p>把本地文件添加到暂存区（.  添加当前目录所有文件到暂存区）</p><br><p><code>$ git commit </code></p><p>添加到<strong>本地</strong>仓库</p><br><p><code> $ git reset &lt;commit ID&gt;</code></p><p>回退：将提交的文件重新 变成红色（未提交状态）可以通过git log查看ID</p><br><p><code> $ git log</code></p><p>查看版本日志</p><p><code> $ git reflog</code></p><p>查看所有的操作日志和ID，包括已经撤回的记录</p><p>一些参数：</p><p>–hard：不保存所有变更，所有变更都会回到commit ID对应的状态</p><p>–soft：保留变更且更内容处于Staged</p><p>–mixed：保留变更且变更内容处于Modified）（不带参数默认是mixed）</p><p><code>$ git push</code></p><p>添加到远程仓库</p><br><p><code>$ git pull</code></p><p>从远程拉到本地仓库，并合并</p><br><p><code>$ git branch</code></p><p>查看分支</p><br><p><code>$ git branch name</code></p><p>新建name分支</p><br><p><code>$ git checkout -b &lt;name&gt;&lt;template&gt;</code></p><p>新建以template为模板，以name为名字的一个分支，并切换到该分支</p><p>如果template模板来自远程仓库则需要在前面加origin</p><br><p><code> $git checkout -d [branch name]</code> </p><p>删除分支</p><br><p><code> $git checkout -d [branch name]</code> </p><p>删除分支</p><br><p><code> $git fetch</code></p><p>查看远程仓库信息，执行该语句后可通过<code>$git checkout &lt;name&gt;</code> 切换到模板来自远程仓库的本地分支</p><p><code> $ git merge &lt;分支名&gt;</code> </p><p>合并分支</p><p><code> $ git remote add origin &lt;远程地址&gt;</code> </p><p>关联到远程仓库</p><h3 id="使用git多人协作"><a href="#使用git多人协作" class="headerlink" title="使用git多人协作"></a>使用git多人协作</h3><ol><li>从服务器将版本库克隆至本地（git clone ）</li></ol><p><code> $ git clone &lt;仓库地址&gt;</code> </p><ol start="2"><li>文件修改之后提交至暂存区</li></ol><p><code> $ git add .</code> </p><ol start="3"><li>将暂存区的文件更新至本地仓库</li></ol><p><code> $ git commit -m"说明信息"</code> </p><ol start="4"><li>将远程仓库拉至本地，确保拿到的是最新版的代码，防止覆盖别人的更新</li></ol><p><code>$ git pull</code> </p><ol start="5"><li>将本地仓库上传到远程仓库</li></ol><p><code>$ git push</code> </p><br>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git&amp;hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进来随便聊聊叭</title>
      <link href="2021/03/05/MyFristBlog/"/>
      <url>2021/03/05/MyFristBlog/</url>
      
        <content type="html"><![CDATA[<p>非常欢迎你来到我的博客，这是我的第一篇文章，我也不懂要写什么，就随便唠一下吧。</p><h4 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h4><p>​        我先介绍一下我自己吧，00后的大表哥，游手好闲无业网民，最喜欢吃大柳州的螺蛳粉，长板板混（蹲个大佬一起磕招），喜欢摄影，代码小菜鸡，秃头预备选手，只喜欢写一些实用代码（有好的点子一起交流）。</p><h4 id="建站故事"><a href="#建站故事" class="headerlink" title="建站故事"></a>建站故事</h4><p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本来说20年的寒假要搭建这个个人博客的，当时非常幸运地在南京参与电影《非常替身》制作，担任实习剪辑助理一职，由于工作太“闲”了，我就开始对未来思考，于是乎就有了搭建这个博客的想法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一开始我是想搭一个我们学校滑板论坛的，但是考虑到实用性和推广难度就放弃了。然后在寒假断断续续的看了一点vue，学了几天myslq，flag就开始立起来了，说是这个寒假完成，然后回到家就开始玩了。。。剩最后10天开学了，我才抓紧起来，建站过程挺曲折的，一个方面是因为我的拖延，另一个方面源自于自我的不肯定，东一下学js，西一下学vue，学了一下mysql，又想下学期就有数据库的课，现在会不会太着急了，想学Spring又怕跳的太快，只知道wordpress又懒得学php……就这样一直和自己的想法对抗中，好像我就是纠结体本身，终于最后被逼到什么都来不及学，直接建站！事实证明在建站过程中学习，比先学再做来得更高效直接，回顾以前自学python、html、css的时候也是等不及慢慢啃知识点，直接实战了。本在在Gitpage上面部署过一次博客（已经能用的那种），后来又想买个服务器和域名玩一下，就又重新整了一套。</p><p>就好像在博客首页的“送你一颗子弹”一样</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后选择了hexo这个框架也是蛮幸运的，他刚好是基于前端三剑客的框架，不用再学php了（投降）。但是它的缺点是没有直接管理网站文章的后台，随便吧。</p><blockquote><p>就这样这个博客就稀里糊涂的建了起来。</p></blockquote><h4 id="立一些flag"><a href="#立一些flag" class="headerlink" title="立一些flag"></a>立一些flag</h4><blockquote><p>虽然说这个博客是搬别人的框架，但是二次开发我也费了蛮多心血的，改动还是蛮多的，修饰博客的界面就像装潢自己小窝一样。</p></blockquote><p>Flag1：以后在这个博客上面主要发一些学习笔记吧，也会发一些书摘，随笔，可能会上线说说板块</p><p>Flag2：等我学会调用API了会上线识别qq账号留言评论功能，大家就能有头像啦！</p><p>Flag3：“什么时候心血来潮”上线滑板、相册、vlog板块</p><p>Flag4：每周更新两篇文章（！！！一定要做到！！！）</p><p>Flag5：给自己的网站设计一个logo并且用PS或者AI做出来（应该不难）</p><p>Flag6：把写过的代码都上传到github上</p><h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这么辛苦码字就是为了见你一面，留下你的脚印吧我的朋友,非常欢迎评论区或者留言互动！期待你的留言！</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flag </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
